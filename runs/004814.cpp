#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cmath>
using namespace std;

typedef vector<vector<int> > MatrixT;
namespace Color{enum{White, LightGray, DarkGray, Black, Colors, Mask = 0xff};};// Перечисления цветов и общее их число в соответствии с условием

const int Chars = 10;// Количество распознаваемых символов (10 цифр)
const int PatternWidth = 32, PatternHeight = 48;// Размеры образцов

class Archive{// Содержит упакованные образцы символов и предоставляет функцию для их распаковки
	static const int MaxRepNum = 86;// Максимальное число повторов символа кодируемое одним символом
	static const int Strings = 154;// Число строк в архиве
	struct RepMap{// Проекция символа на число повторов
		RepMap(): mp(256, 0){
			int i, k = 2;
			for(i = '('; i < '\\'; ++i, ++k) mp[i] = k;
			for(i = ']'; i <= '~'; ++i, ++k) mp[i] = k;
		}
		int operator()(int ch){return mp[ch];}
		vector<int> mp;
	};// struct Table
public:
	static void UnpackToString(string& dest){// Распаковка архива в строку dest
		dest.clear();
		string a;
		for(int i = 0; i < Strings; ++i) a += Data[i];// Записываем архивные данные в string для удобства
		
		char curr = a[0];// Первый элемент архива - для установления начального символа		
		for(string::iterator it = a.begin()+1; it != a.end(); ++it){
			const char& c = *it;
			if(c == ' ' || c == '#')// Соответствует одиночному символу
				dest += c, curr = (curr == ' ') ? '#' : ' ';// Добавляем символ в выходную строку и изменяем текущий символ на противоположный
			else if(c == '$')// Означает - повторить текущий символ MaxRepNum+1 раз
				dest.insert(dest.end(), MaxRepNum+1, curr);
			else // Все остальные символы представляют закодированное количество повторов
				dest.insert(dest.end(), CharToRep(c), curr), curr = (curr == ' ') ? '#' : ' ';
		}// for it
	}// UnpackToString()
private:
	static RepMap CharToRep;// Проекция символа на число повторов
	static char* Data[Strings];// Архивные данные (в самом конце файла)
};// class Archive
Archive::RepMap Archive::CharToRep;

struct CharMap{// Проекция символа на значение цвета
	CharMap(): mp(256, 0){
		mp['.'] = Color::White;
		mp['%'] = Color::LightGray;
		mp['#'] = Color::DarkGray, 
		mp['@'] = Color::Black;
	}
	int operator()(int ch){return mp[ch];}
	vector<int> mp;
} CharToColor;

template<typename T> struct PT{// Класс точки
	PT(){}
	PT(T x_, T y_) : x(x_), y(y_){};
	T dist2(const PT<T> r)const {return dist2(r.x, r.y);}
	T dist2(const T& x_, const T& y_)const {return (x-x_)*(x-x_) + (y-y_)*(y-y_);}
	T x, y;
};
template<typename T> PT<T> MakePT(const T& x, const T& y){return PT<T>(x, y);}

void ReadInput(MatrixT& M, istream& is = cin){// Считывает входное изображение
	string str;
	string::iterator s, s_end;
	vector<int>::iterator v;
	while(is >> str){
		M.push_back(vector<int>());
		M.back().resize(str.size());
		for(v = M.back().begin(), s = str.begin(), s_end = str.end(); s != s_end; ++s, ++v)
			*v = CharToColor(*s);// Преобразуем символ к соответствующему цвету
	}// while		
}// ReadInput()

class Segment{// Сегментация. 
public:
	static void Segmentate(MatrixT& M, vector<Segment>& Segs){// Сегментация матрицы и запись сегментов в Segs
		VerticalSplit(M);// Пробуем вертикально разделить символы
		AddWhiteBorder(M);// Добавляем к M белую рамку для нормальной работы Mark()
		int id = Color::Mask+1;// Идентификатор сегмента будем хранить в старших битах, после цвета
		int cx = (int)M[0].size(), cy = (int)M.size();
		for(int y = 0; y < cy; ++y){
			for(int x = 0; x < cx; ++x){
				if((M[y][x] & ~Color::Mask) == 0 && (M[y][x] & Color::Mask) > Color::LightGray){// Если не принадлежит какому либо сегменту и цвет темнее светло-серого
					Segs.push_back(Segment());// Создаем новый сегмент
					Segment& s = Segs.back();
					s.Mark(M, MakePT(x, y), id);// Отмечаем точки принадлежащие данному сегменту					
					s.CopyData(M);// Копируем прямоугольник из матрицы М в матрицу сегмента С
					id += Color::Mask+1;
				}
			}// for x
		}// for y
	}// Segmentate()

	static void VerticalSplit(MatrixT& M){// Вертикальное разделение на отдельные символы
		int cx = (int)M[0].size(), cy = (int)M.size();
		MatrixT ColStat(Color::Colors, vector<int>(cx, 0));// Статистика по цветам в каждом столбце
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				++ColStat[ M[y][x] ][x];
		
		for(int x = 0; x < cx; ++x)
			if(ColStat[Color::Black][x] < 1 && ColStat[Color::DarkGray][x] < 2)
				for(int y = 0; y < cy; ++y)// То проводим вертикальную белую полосу
					M[y][x] = Color::White;		
	}//VerticalSplit()

	static void AddWhiteBorder(MatrixT& M){// Добавляем к M рамку толщиной в 1 пиксель с каждой стороны цветом Color::White
		int cy = (int)M.size();
		for(int y = 0; y < cy; ++y)// Добавляем слева и справа
			M[y].insert(M[y].begin(), Color::White), M[y].push_back(Color::White);
		M.insert(M.begin(), vector<int>(M.back().size(), Color::White));// Сверху
		M.push_back(vector<int>(M.back().size(), Color::White));// Снизу
	}// AddWhiteBorder()

	void EnumContourPoints(vector<PT<int> >& points){// Записывает в points контурные точки сегмента
		int cx = (int)C[0].size(), cy = (int)C.size();
		for(int y = 0; y < cy; ++y){
			int lx = 0, rx = cx-1;
			while(!C[y][lx] && lx < cx) ++lx;// Крайний левый закрашеный пиксель в строке
			while(!C[y][rx] && rx >= 0) --rx;// тоже  - правый
			if(C[y][lx]) points.push_back(MakePT(LeftTop.x+lx, LeftTop.y+y));
			if(C[y][rx] && lx != rx) points.push_back(MakePT(LeftTop.x+rx, LeftTop.y+y));
		}// for y
	}// EnumConturPoints()

	void Mark(MatrixT& M, const PT<int>& from, int id){// Отмечает все пикселы смежные с from значением id 
		//Для правильной работы Mark() все граничные пикселы входной матрицы должны иметь цвет Color::White
		this->id = id; cp = 0;
		LeftTop = RightBottom = from;
		vector<PT<int> > stk;

#define Insert(x, y) if((M[y][x] & Color::Mask) != Color::White && (M[y][x] & ~Color::Mask) == 0) M[y][x] |= id, stk.push_back(MakePT(x, y));
		Insert(from.x, from.y);
		while(!stk.empty()){
			int x = stk.back().x, y = stk.back().y; stk.pop_back();
			++cp;
			// Обновляем границы сегмента
			if(x > RightBottom.x) RightBottom.x = x;
			else if(x < LeftTop.x) LeftTop.x = x;
			if(y > RightBottom.y) RightBottom.y = y;
			else if(y < LeftTop.y) LeftTop.y = y;
			// Обрабатываем соседей
			if((M[y][x] & Color::Mask) == Color::LightGray) continue;// По светло-серым не переходим
			Insert(x, y-1);Insert(x-1, y); Insert(x+1, y); Insert(x, y+1);
			if((M[y][x] & Color::Mask) == Color::DarkGray) continue;// По темно-серым не делаем диагональные переходы
			Insert(x-1, y-1);  Insert(x+1, y-1);			
			Insert(x-1, y+1);  Insert(x+1, y+1);
		}// while
#undef Insert
	}// Mark()

	void CopyData(MatrixT& M){// Копируем минимальный прямоугольник матрицы M содержащий пиксели этого сегмента
		int cx = RightBottom.x - LeftTop.x + 1;
		int cy = RightBottom.y - LeftTop.y + 1;
		C.assign(cy, vector<int>(cx));
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				if((M[y+LeftTop.y][x+LeftTop.x] & ~Color::Mask) == id) C[y][x] = (M[y+LeftTop.y][x+LeftTop.x] & Color::Mask);
	}// CopyData()

	bool IsInside(const Segment& s){// Возвращает true если this внутри s
		if(this == &s) return false;
		return LeftTop.x > s.LeftTop.x && LeftTop.y > s.LeftTop.y && RightBottom.x < s.RightBottom.x && RightBottom.y < s.RightBottom.y;
	}// IsInside()
	Segment& operator +=(const Segment& r){// Объединение сегментов this и r
		// Вычисляем новые границы сегмента
		PT<int> lt = MakePT(min(LeftTop.x, r.LeftTop.x), min(LeftTop.y, r.LeftTop.y));
		PT<int> rb = MakePT(max(RightBottom.x, r.RightBottom.x), max(RightBottom.y, r.RightBottom.y));
		MatrixT W(rb.y - lt.y + 1, vector<int>(rb.x - lt.x + 1, 0));// Сюда будем записывать объединенные данные
		// Копируем данные из матрицы this->C в W
		int dx = LeftTop.x - lt.x, dy = LeftTop.y - lt.y;
		int cx = (int)C[0].size(), cy = (int)C.size();
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				if(C[y][x]) W[y+dy][x+dx] = C[y][x];
		// Копируем данные из матрицы r.C в W
		dx = r.LeftTop.x - lt.x, dy = r.LeftTop.y - lt.y;
		cx = (int)r.C[0].size(), cy = (int)r.C.size();
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				if(r.C[y][x]) W[y+dy][x+dx] = r.C[y][x];
		// Перезаписываем матрицу, устанавливаем новые границы и суммируем количество закрашенных пикселей
		C = W, LeftTop = lt, RightBottom = rb, cp += r.cp;
		return *this;
	}// operator +=()	
	static bool CmpPtrByX(const Segment* l, const Segment* r){ return l->LeftTop.x < r->LeftTop.x;}// Для сортировки указателей на сегменты по x координате

	int id, cp;//Идентификатор сегмента и количество закрашенных пикселов 
	PT<int> LeftTop, RightBottom;// Границы прямоугольника сегмента в исходной матрице Image 
	MatrixT C;// Минимальный прямоугольник из Image с началом в LeftTop содержащий только пикселы текущего сегмента. 
};//class Segment

class Heuristic{// Эвристические функции для сегментов
public:
	// Константы в процентах закрашенных пикселей сегмента от СРЕДНЕГО значения по всем сегментам:
	// LOW_CP_PERCENT - минимальный процент закрашенных пикселей в сегменте. Если значение меньше, то сегмент не рассматриваем
	// INNER_CP_PERCENT - если один сегмент внутри другого и у внутреннего процент закрашенных пикселей больше этого значения, то внешний сегмент считаем рамкой.
	enum{LOW_CP_PERCENT = 10, INNER_CP_PERCENT = 50};
	static void ApplyAll(vector<Segment*>& ps){
		RemoveFrameSegs(ps);// Удаляем рамки
		UnionOverlapedSegs(ps);// Объединяем сегменты перекрывающиеся по горизонтальным проекциям
		RemoveSmallSegs(ps);// Удаляем маленькие сегменты
		UnionNearestSegs(ps);// Объединяем относительно близко расположенные сегменты
	}//ApplyAll()

	static void UnionNearestSegs(vector<Segment*>& ps){// Объединение сегментов составляющих один символ
		int n = (int)ps.size();
		if(n < 2) return; 
		sort(ps.begin(), ps.end(), Segment::CmpPtrByX);// Сортировка сегментов по x координате
		vector<vector<PT<int> > > Contours(n);// Для хранения точек контуров сегментов
		for(int i = 0; i < n; ++i) ps[i]->EnumContourPoints(Contours[i]);// Находим точки контуров
		// Находим минимальные расстояния между контурами для всех пар сегментов
		vector<vector<double> > D(n, vector<double>(n, 0.0));
		for(int i = 0; i < n; ++i)	
			for(int j = i+1; j < n; ++j)
				D[i][j] = D[j][i] = sqrt((double)MinDist2(Contours[i], Contours[j]));
		// Находим максимальное расстояние между соседними сегментами отсортированными по x координате		
		double MaxDist = D[0][1];
		for(int i = 1; i < n; ++i)
			if(D[i-1][i] > MaxDist) MaxDist = D[i-1][i];
		// Если все сегменты слишком близко друг к другу то выходим
		if(MaxDist < 4.0) return;
		double Threshold = max(MaxDist*0.2, 1.1);// Если сегменты ближе чем эта величина то объединяем их		
		// Объединение
		vector<int> Consumed(n, 0);// Consumed[i] = true - если сегмент i поглощен другим в результате объединения
		for(int i = 0; i < n; ++i){
			if(Consumed[i]) continue;
			for(int j = i+1; j < n; ++j){
				if(Consumed[j]) continue;
				if(D[i][j] >  Threshold) continue;
				*ps[i] += *ps[j], Consumed[j] = 1;
				for(int k = 0; k < n; ++k)// Обновляем расстояния до нового объединенного сегмента
					D[i][k] = D[k][i] = min(D[i][k], D[j][k]);
				i = -1; break;// Т.к. расстояния поменялись начинаем все с начала
			}// for j
		}// for i
		Erase(ps, Consumed);
	}// UnionNearestSegs()

	static void UnionOverlapedSegs(vector<Segment*>& ps){
		int n = (int)ps.size();
		if(n < 2) return;
		vector<int> Consumed(n, 0);// Consumed[i] = true - если сегмент i поглощен другим в результате объединения
		for(int i = 0; i < n; ++i){
			if(Consumed[i]) continue;
			for(int j = i+1; j < n; ++j){
				if(Consumed[j]) continue;
				if(IsOverlaped(*ps[i], *ps[j])){
					*ps[i] += *ps[j], Consumed[j] = 1;
					i = -1; break;// Т.к. размеры сегментов поменялись начинаем все с начала
				}
			}// for j
		}// for i
		Erase(ps, Consumed);
	}// UnionOverlapedSegs()

	static bool IsOverlaped(const Segment& a, const Segment& b){// Возвращает true если относительно большая часть сегментов перекрывается		
		if(a.LeftTop.x > b.LeftTop.x) return IsOverlaped(b, a);
		int overlap = a.RightBottom.x - b.LeftTop.x + 1;
		if(overlap <= 0) return false;// Не перекрываются
		int la = a.RightBottom.x - a.LeftTop.x + 1, lb = b.RightBottom.x - b.LeftTop.x + 1;// Горизонтальные проекции длины сегментов
		int part_a = Percent(overlap, la), part_b = Percent(overlap, lb);// Проценты перекрытий
		int threshold = 90;// Если процент перекрытия какого либо сегмента больше этой величины, то считаем сегменты перекрывающимися
		return (part_a > threshold || part_b > threshold);
	}//IsOverlaped

	static void RemoveSmallSegs(vector<Segment*>& ps){	// Удаление слишком маленьких сегментов
		if(ps.empty()) return;
		int av_cp = AverageCp(ps), n = (int)ps.size();// Среднее число закрашенных пикселей на сегмент и общее число сегментов
		vector<int> Erased(n, 0);// Erased[i] = true если сегмент i удален
		for(int i = 0; i < n; ++i)
			if(Percent(ps[i]->cp, av_cp) < LOW_CP_PERCENT)
				Erased[i] = 1;
		Erase(ps, Erased);
	}// RemoveSmallSegs()

	static void RemoveFrameSegs(vector<Segment*>& ps){// Удаление сегментов похожих на рамки
		if(ps.empty()) return;
		int av_cp = AverageCp(ps), n = (int)ps.size();// Среднее число закрашенных пикселей на сегмент и общее число сегментов
		vector<int> Erased(n, 0);// Erased[i] = true если сегмент i удален
		for(int i = 0; i < n; ++i)
			for(int j = 0; j < n; ++j)
				if(ps[i]->IsInside(*ps[j]) && Percent(ps[i]->cp, av_cp) > INNER_CP_PERCENT)// Если сегмент достаточно большой и находится внутри другого то удаляем внешний
					Erased[j] = 1;
		Erase(ps, Erased);		
	}//RemoveFrameSegs()

	static int MinDist2(const vector<PT<int> >& a, const vector<PT<int> >& b){// Находит ближайшую пару точек и возвращает квадрат расстояния между ними
		int md = a.front().dist2(b.front());
		for(vector<PT<int> >::const_iterator it1 = a.begin(), end1 = a.end(); it1 != end1; ++it1){
			for(vector<PT<int> >::const_iterator it2 = b.begin(), end2 = b.end();  it2 != end2; ++it2){
				int d = it1->dist2(*it2);
				if(d < md) md = d;
			}// for it2
		}// for it1
		return md;
	}// MinDist2

	static void Erase(vector<Segment*>& ps, const vector<int>& Erased){// Удаляет сегменты i для которых Erased[i] = true
		vector<Segment*> copy_ps(ps);
		ps.clear();
		for(int i = 0; i < (int)copy_ps.size(); ++i)
			if(!Erased[i]) ps.push_back(copy_ps[i]);
	}// Erase()

	static int AverageCp(vector<Segment*>& ps){// Подсчитывает среднее число закрашенных писелей по сегментам
		int TotalCp = 0, n = (int)ps.size();
		for(int i = 0; i < n; ++i) TotalCp += ps[i]->cp;
		return TotalCp/n;
	}// AverageCp()
	static int Percent(int cmp, int to){	return (cmp*100)/to;}// Процент величины cmp в to
};// class Heuristic

class Recognizer{// Распознавание символа
public:
	Recognizer(const string& PatternsString){// Конструктор получает строку шаблонов состоящую из символов '#' и ' ' и строит из них матрицы шаблонов
		string::const_iterator it = PatternsString.begin();
		int PatternsPerChar = (int)PatternsString.length()/(PatternWidth*PatternHeight*Chars);// Количество образцов для каждого символа
		MatrixT M(PatternHeight, vector<int>(PatternWidth));
		PatternFields.resize(Chars);// Количество символов 
		for(int d = 0; d < Chars; ++d){
			PatternFields[d].resize(PatternsPerChar);// Количество шаблонов для каждого символа
			for(int k = 0; k < PatternsPerChar; ++k){
				for(int y = 0; y < PatternHeight; ++y)
					for(int x = 0; x < PatternWidth; ++x)
						M[y][x] = ((*it++ == '#') ? Color::Black : Color::White);
				CalcField(M, PatternFields[d][k]);// Вычисляем поле потенциалов создаваемое этим символом
			}// for k
		}// for d
	}// Recognizer();

	int Recognize(const MatrixT& M){// Распознавание. Возвращает число соответсвующее разпознанной цифре
		// Для распознания используется метод потенциалов
		MatrixT N;// Хранит нормализованную матрицу
		NormalizeMatrix(M, N);		
		vector<double> F;
		CalcField(N, F);// Вычисляем поле потенциалов
		vector<double> U(Chars, 0.0);// Хранит суммарное значение обратной разности потенциалов для каждой цифры
		for(int d = 0; d < (int)PatternFields.size(); ++d){
			for(int i = 0; i < (int)PatternFields[d].size(); ++i){
				double r = Distance(F, PatternFields[d][i]);				
				U[d] += 1e6/(1.0+r);
			}
		}// for d
		return (int)(max_element(U.begin(), U.end()) - U.begin());// Ответ: индекс цифры с наибольшим суммарным потенциалом		
	}// Recognize()
private:
	static double Distance(vector<double>& a, vector<double>& b){// Вычисляет квадрат расстояния между двумя векторами
		double d = 0.0;
		for(int i = 0; i < (int)a.size(); ++i){
			double r = a[i] - b[i];
			d += r*r;
		}
		return d;
	}// Distance()

	static void CalcField(const MatrixT& M, vector<double>& F){// Вычисляет значения потенциалов в матрице M. Результат в вектор F
		// Каждый элемент поля имеет собственный потенциал, который, в свою очередь, увеличивает потенциалы
		// всех соседних элементов по вертикали, горизонтали и диагоналям.
		int cx = (int)M[0].size(), cy = (int)M.size();
		F.clear();
		static const double ColorCoeff[Color::Colors] = {0.0, 0.8, 0.9, 1.0};// Коэффициенты для разных интенсивностей цвета
		const double A = 0.5, B = 0.4;// Коэффициенты для соседних по стороне пикселей и диагональных соответственно
		// Временная матрица для суммирования потенциалов. Больше исходной на 1 с каждого края, чтобы не обрабатывать выход за границы.
		vector<vector<double> > T(cy+2, vector<double>(cx+2, 0.0)); 
		for(int y = 0; y < cy; ++y){
			for(int x = 0; x < cx; ++x){
				if(M[y][x]){
					double k = ColorCoeff[ M[y][x] ];
					++x, ++y;// Приводим координыты матрцы M к координатам в матрице T
					T[y-1][x-1] += B*k; T[y-1][x] += A*k; T[y-1][x+1] += B*k;
					T[y][x-1] += A*k; T[y][x] += k; T[y][x+1] += A*k; 
					T[y+1][x-1]+= B*k; T[y+1][x] += A*k; T[y+1][x+1] += B*k;
					--x, --y;// Восстанавливаем прежние координаты
				}
			}// for x
		}// for y
		for(int y = 1; y <= cy; ++y)// Записываем результаты в вектор
			F.insert(F.end(), T[y].begin()+1, T[y].begin()+cx+1);		
	}// CalcField()

	static void NormalizeMatrix(const MatrixT& src, MatrixT& dest){// Нормализация//Вписываем исходуню матрицу src в dest.		
		dest.assign(PatternHeight, vector<int>(PatternWidth));		
		Fit(src, dest);
	}// NormalizeMatrix()

	static bool Fit(const MatrixT& src, MatrixT& dest){// Вписывает изображение src в dest
		int s_cx = (int)src[0].size(), s_cy = (int)src.size();
		int d_cx = (int)dest[0].size(), d_cy = (int)dest.size();
		int x_ratio = (s_cx << 16)/d_cx;
		int y_ratio = (s_cy << 16)/d_cy;		

		for(int y = 0, s_y = 0; y < d_cy; s_y += y_ratio, ++y)
			for(int x = 0, s_x = 0; x < d_cx; s_x += x_ratio, ++x)
				dest[y][x] = src[s_y >> 16][s_x >> 16];
		return true;
	}// Fit()

	vector<vector<vector<double> > > PatternFields;// Потенциальные поля создаваемые шаблонами символов для каждой цифры
};// class Recognizer

int main(){
	string str;
	Archive::UnpackToString(str);// Распаковка строки шаблонов
	Recognizer Rgz(str);//Распознавание будет на основе этой строки шаблонов

	MatrixT M;
	ReadInput(M);

	vector<Segment> Segs;// Память под сегменты
	Segment::Segmentate(M, Segs);// Сегментация
	// Далее работаем с указателями на эти сегменты
	vector<Segment*> PSegs;
	for(vector<Segment>::iterator it = Segs.begin(), end = Segs.end(); it != end; ++it)
		PSegs.push_back(&*it);

	Heuristic::ApplyAll(PSegs);// Применяем эвристические алгоритмы
	// Распознавание каждого сегмента
	for(vector<Segment*>::iterator it = PSegs.begin(), end = PSegs.end(); it != end; ++it)
		cout << Rgz.Recognize((*it)->C);
		
	cout << endl;
	return 0;
}// main()

// Упакованные данные шаблонов символов
char* Archive::Data[Strings] = {
	" 3-<377492;0=./-..-0.,-3,,,4-*-5,*,6-),7,(,8,(,8,(,9, ,9, ,9392:2:2:2:2:2:2:2:2:2:2:39, ,9, ,9, ,9, ,8,(,8,),7,),6-)-5,+,",
"4-+-3,,.0.-/-./=0;294773=+>19-(,6.+*4/-)20.)01/)/10(.21(-21(,32(+32(*42))43()43) 54( 54( 54( 548484857575757575757484( 54",
"( 54( 54( 54((43()43()43(*32(+32(,21(-21(.10(/1/)00.)2/-)4.+*7,(,91;(C+?/=0:38391,(31,(21-(11.)0/1(0.3)..4),.5),-7)+-8)*,",
"9*),:)(,;)(+<) ,<0=/=/=) *?( *?( *>)()>)()>)()=))*<))*=()*=(*)=(*)=(**<(**;(,*:(-):(-):(-*8(/*7(/*6(1+3)2,0)5-*+82<.>+?/;",
"376592;1;0=.?,@,A+A*B*3 5(3)4(3*4 3*4 3+3 2,@,@,@,@,@,@-@,@,@,@,2 3,2 3,2 3,2 4*3(3*3(4)2)5 3*B*A+A,@->/<0;2:385674;/>,=2",
"9468392;1.--/-0---(-),-,(0(,+,(2(+++(4(*++ 5(+)+(++, +)+ +-+(+(+ +.+ + + +/+(* + +/+(* + +0*(* *(*1*(* *(*1+ /(*1+ /(*1+ ",
"/(*1+ /(*1+ /(*1+ /(*1+ /(*1*(/(*1*(* *(*1*(* + *0+ + + +/+ + + +/*(+ +(+-+ +(, +-+ +)+ ,++(+)+(4(+*,(3 ,++(2(,+,(0(,,-(.",
"(---)*)-/--//<1:386582=->/;385583:2;02*-.3+--/ ),,,/)(-,+/)(,-*/*(+/)/00).1* +(/2#*+ /7+ .8+ 07756*+-3(#*+-2--)5--)5--)5 ",
"(++*9**.664839* .9* .4#** .3)(+ .)#.1(. (0.)20-)11-*/4*+.4+,.,)**-/+))+./*)(+0/)/29476583;/G(?.=0:29475674- 03-*/1-+00,-/",
"/,./.,0..+1/-+2.,+3/*,3/),5.),4/),4/(,5/(,5/(,5/ ,6/ +7/ +7/ +7/ +748. +8-(+848-(+7-)*8-)+7++*7,+*6,,*5,-*4,.*4,/*1-0+0,2",
"*.-2-+,4/ -65:0=.D.<286592.*//./-.,2-,-3-+,5,*,6,*,7,)+8,)+9, ,9, +:, +:2:2:2;1;1;1;1;1;1;1;1;1;1;1;1:2:, +:, +:, +:, ,9,",
"(+9+),7,),7+*,6,+,5,+-3,-,2,/-/-0.*/294691>+?/;+)+8*-*6)0*4)3)2*3*0*5*/*5*.+5+-+5+,+7+++7+*,7,),7,),7,),7,(-7- ,8- ,93939",
"39393939393939, ,9, -7- -7-(,7,),7,),7,*+7,*+7+++7+,+6*-+5+.*5*/*5*0*3*2)3)4*/*6*-*8+)+;/=.<2865.(/2.+.0.-../-.-0-/,0-0*0",
".0*0.1)0.1(1/0(1/1 1/1 1/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/1 1/1 1/1 2.1 2.1 2.1(1.1(1.0)1.0*0.0*0./,0,/.1(00;3773:0<09,)",
",6,,,3,.,1-.-/...-.0--.0.+/0.+/0/*/0/*/0/)000(000(000 10<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<01 000(000(000(000)/0/*/0/+.0/+.0.",
"--//.-../-.-1,.,4+,,6+)-90973;/./.+0/.+0/0 2/0 2/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/",
"1(0/1(0/0+./0+././;=-=23))33)(51<0<.?-?,1)2,-1/+,3.*-3.*,5-*,7+),8+),8+),8+),9*(-9*(-9*(-9*(-9*(,:*(,93939* .9* .7, .7, .",
"7, .6,(.6,(/4-(/4,)/4,)/3-)/2-*/2-*/0.+0/.-..-//,./0)/1:2:385672;8483:1</>-@+B)D $},@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@",
",@,@,@,$} D)B+@->/<1:38F->.=/<0:28466572:/=-?*7 C)@,>.;184480<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0",
"C)@,<093572:.>+A(K)>.<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<=(?2956657391;0</</=,A*2)",
"2*1,1)0-2)/.1).10(.20(-30(,40=/=/=/>.>.>-?-@,@,@,@,@+A+A*A+A+A+A+A+A*B*B*B*B*C)C*B*C*B)?,<2672:0</=->-=.=.>.>.=0<66666675",
"757575757575757575757575756666666757575758492<*$N E E(C-<I#B*@,=/:2755731 -/2*--2,-*2/-(2-#)- 0-*)-(-,-)-(+,/)-)*(3)-)9)-",
")9)-*. /)-*+*/)-+#-/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-3/)-393",
"939D(@,932:+b E(D(.(:2:2:2:2:2/,+3.+,3.*-3-+-3-*.3,*.4,*.5+*.5+)/5**/5*)05*)05*)05*)06))06) 26665758484848484848484848393",
"9393:2:2:2C(((?->-<0;192926547481.)/1-+/0.+.2(/-?,?,@+@+@,@+@+A+@,?,@,?,@+@,@,?-?-?->.>.=.>.>.=/=/=/=/=.=/<0:2:39,@*O->.<",
"0:2846.(,6++,6)-,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,2$/:#C)>.661;93<0=/=/=/=/=/=/=",
"/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=0<0<0;278,F:)@-<084481;.>0<487575757575757575757575757575757575",
"757575757575757575757575757575757575771=,D(C50<0.>.>848484848484848484848484848484848484848484848484848484848484848484848",
"484848484848484840$-57575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757>,>/<0;28",
"474756648392:0;00(0/0)0./+0,/+2+/,1+/-1+-/1).01)-1/+*30+)40<0</=/</=/=/=/=.=/=/=/=-?-=/=.>.=/=.>.=-?-?,>.>-?,>9391;0<.>,@",
",@,@,@,@,@,@,@,@39393939393939393939393939393939393939393939,$$$$J3-;5682;0=.?,0./+.1.*-5-)-5-),7,),7- -8, ,9,+(9,@,?-?,?",
"-?->->.>->.=.</</</</</</;/</</</</</<.=.>->->-?->E E $.3-<37,*-4*/,2)1./)3.-)4.-(5/,(50*(60*#62)#62((62((62((53((53((44(",
"(44)#35)(16)(16*#07*#065747575657574747574757474847565747574756575747475E7)A0962;0>-?,6 0*4.,*21+*03++-5+A+A+A+A+@,?,@+?,",
"?+@,?+@*A*A*A*A*A*A*A*B*A*A*A*B*A*B)B)B*B*@*B)B)B)C)A93E(*O-=186591;0=.?,A*B*B)C)C)C)C)/(8)-+7*+-6**.66656657565747484838",
"38384,)/4++-5++,6)-,@+A+A*B)C(D E $- E)B?-@+B)/)C.>1;4775))33),21*.00--//0+..4*.,5*-.5)-20*,4/),6.),6-),6-),7,),7,),7,),7",
",),7,),7,),7,(,8+),7,)+8+),8+)+8+)+8+),8+)+8+)+8+)+8+)+8+**)-/**5.+)6-**7,**8+**9*+:))+;)(e E E(D2,=2864-*/1+//.+1.-+3.,*",
"4/+*5.+*,(-)()*+,)+)*))+,)+)*)*++)+)*)*,)+)1*3*1+2*)(,,0*)**/,+*+):*+)9,))92:(*+:)**9+*):,(*91:1:1;0;/</</</=->-?,@,?,9)*",
",3/),.5),(;)C(D($.(D93A)C)A+>/</<0:1:- *9,)):+*)9+*)9*+*8*,*8),*9(-*:#,)B)B)B)C)C(B)C(C(D(C(C)B)B*B)C(C(D(C(C*A->01*,10,*",
"5-,)7,,)7,,(. 1)-(,)2(- +/5(+04)*40*)C)P.;3782</0*0--1.+-3.*,6,),7-(,8, ,9, ,:+ ,:+A+A+A+@,@,?,@+@,@,?,?,@,?,?,?,?,?,>-?,",
">-?,>->,?,?,?,>->->->->->-?F E E2.;55*.-1*2-.*5,,*6-*+7-)*8-)*9,(+9- +9- +9- ,8- ,8-(,7-(-6-).)(/-*10-+.1-?->-?,>-?+@+@+@",
"+@*A*A)B(C(C(B)B)B(C(C(C(CA*B)C)C(D DD(D(D(40:3691=..-0,./0*/00(001 /2:2:2:2;1;1?-0 4,1 3-1(2-1)0-1-+/1:1;0;0;0<0;0;/</;0",
";1;0;0;/</</=.=.4),.4+*.4,*-4-).3.(/2/(.2/(D(D D(D)C31;18*)/5)..1*0/.*10-*2/,,10+./0*0/0)0/0)1.0)1.0)1.0)1.0)1.0)1-1*0-1+",
"..0-+00;0</<0<.>.=.=.>->,?,?,?+@+@+5(/*6).*7).*7)-*7*,)8++A*B)C(C E E E E E/73;/./.+0/.+0/0 2/0 2/=/=/=/=/=/=/=/=/=/=/1;1",
";1;1;1;19363137190<.<0<0/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/=/Q-36:1=.?-@*B*C)C)1*4)-20),5.+*5.+*6-,(7->.>-?->-?->->.>,>.=.>",
"->.=.=.>.=.=.<.>.=.=.=/=.=.=/=.=/=$L D(B,<58483:1</>-@+B)D $},@,@,@,@,@+A*5665748391:1:1:1:1929291:1:2:1:1:2$$$$J2-<37749",
"2;0=./-/--1.+-3-+,5,*-5-),7,),7,-(7,@,?,?->->.;082:1:39576?.@-@-@,@-@,@,@,@,*(:3939, ,8- -7,(-6-)-4.).2.+/./->/<1:38645<0",
"<B)A*A)B)A*A)B)A*@.=2;#)/=0<1;2:3948485757666)(16)(16((26((26 (36 (3938484848484936 (35((35()25)(24*(23,(12.(02.)/10).02*",
",/5**.72@(.--?(})*)9+**4/*0,1)C(B)B*B)A)B)B)B)C(C(C(C)C)B.;4866776=0?.A+B*C)C*B*B*B*B*B*B)B*B*B)B*A*A*5(0*6)-*:(**=,?.;46",
"83:1</>.?-?-?-?-+)7.(,67575757484747474692;0>.>.?-@-?-?48576666757575666656)+-7(C(D(C)B*B+?.=1:454+A1;5693<0*(8.*.3--0/,2",
",/+5+.*7).,6).10).4-).5,).5,)-6,)-6+)-6,(-5-)-2.*-/0+,1/*-2,,.2)/10/+0.1+/-3*/4-)/4-).5,).6,(.6,(.5-(.4.(.2/(/.3(C). 8)/(",
"6*/)4+/*0-1**/3,*+5.=084571=+B=/@,A+A+B+@,6),-0.,.+2,@,?,?,?,?,?,?,?-?,)(:. )9294<1>/>.((<0<.?-?-?-?-+(8-+(8-+)7-(,7650 #",
"(*4. #*,1..,/./=0;0;/* 80()770(*7)/(8)C)F,.)34 *391;0;0:1:4(--6#.,?+?+A+@+@+((<666582;1;1.(#(.0-.-/*3+1)2,@+A*B*@+@+@*A+>",
"+A+>,?,?+?,?,>+@+@,?.>.<.>.=-?-?+B*M.<3683;/0+/-.0.+-4-*,6,*+8,)+8,)*:+A+A+A+A+@,@,?,?,?,>-<.:0<.>1<3?/@-@-@,A,A+A+A+A+A+",
"A1;1;1:, ,8,(-7,),6-).2-,1+0-=1963=.=18*)/4)/-1*1..*3-.*3--*4.,*5-,*5-,+4-,+4-,+3---*#,-.0-,0.-,@+@+@+@)B)A/<37)--3*0,1*1",
"-/+2-/(4-@-?-?-?-?-?-?-?-?-?,@,)+7,),7,(.6+).5++-5*--2*0-0*2.+*82:+A>-@,@+@,0,/-,//-,//.+///*//1)/.=.=/</</</</<1:569393;",
"1,(4:2;2;2:2:2;1;1+..1)1-1(3,1 3-1 1/<0;1;1;0<0<01(//2(0.1*/-1,0)2.<286493937+*.3+..0+0..,0/--/0+///+//0*0.0*0.0+/.0+/.0+",
"./0,-/0-*10</<0</<.4**.55767+)/5+)/@.?/=0<0=0<0,(41),21(.1<0<0<0<0<0<0;10 /11),20*+3/,*2/.*0/1+*0630t/=/=/=/=/=/=/=/=/=/=",
"/=/=/=/=/0<0</=-?-?+4575D+A-?/=/==/=/=/=/=/=/=/=/=/=/=/=/=/=/0(1/0(1//+///+//-/;763;.?,@,@+A+A*B*5*.+.2-,*4->-?,>.=-?,?,?",
",?->-?+?,?,?-?,?39579495984<1>.?->.=/;19283747456454737463755>8483:1</>-@+B)D $],@,@,@,3 2 8 2 84848484757584848484E,@,@,",
"@,@,@,@,@,$} D)B+@->/<1:38D*A+@,?->.>.=/<0;1;1:2:2938- ,7-(,7-(,6-),5-*,4-+,4-+,3-,,3-,,2--,1-.,0-/,0-/,/-0,.-1,--2,--2,,",
"-3,+$$8;,@,@,@,@,@,@,@,@,@,@,E#E#D(C)C)B*B*A+@,?-?->.>.=/<0;1;1:2:28484757566664) 44((43)(43()42(*42(*40)+40(,4/),4/(-4.(",
".4.(.4,)/4,(04+g348484848484848(C*A-?.>.=.=/=-?->-?,?,?,?,+#:,*)9,**8++*7+,*7+,*6+-*6+,+5*.+5*/*4+/7 b*=/,/+3(3*B*B*A+A+B",
"*B+A*B)C)C)C(D(D(D(D)D(C)C)D#M(B,>/<0;1;1:28484756666574839392:2:1,(30,)3/,*2/,+2/,+2.,,2.+-2-,-2,--2,,.2+,/2+.,6(D E E E",
" E E E E E(D6484848484848484=#D*B,?.=/=/<* +<))*;*)*;)**:***:)+*9*(#(*9)(((*8))((*7*()(*7*()(*6*(*(*5*(+(*5*(+(*4*)+(*4*(",
",(*3*(-(*2*)-(*2*() *(*1*(* *(*1*()(*(*0*(*(*(*/*)))*(*/*(*)*(*.*))**(*-+(2(/(*(3(/ +(3(/ *(4(3@( )@( )@( :(/ :(/(9(/7*(*",
"<*(*<*(*<*(*<0<0<06#E+A*A+A+A+@+A+A+)+8,)+8,(-7+*+7,+*7,@,?-?-/*2-/*1-0*3++())4+)*))1#(+)*))1.*)))1-+)))3++)))4*+)))0C(D)",
"C+A ((=+>-; )/8()3++*()=*()=*()=*()=*()=*()=*((>*B*B*B*B*B*B*J#D)B*B*@+A+@+A+A+@,>-?->.=/<* +<)(*<))*<))*;)**:)+*9),)9)-)",
"0#.)-)/(,*.)-*++.)-**-,*-*)2().))4 ++*)B(C)B*@<*B*B*B*A*B*B*B*B*A+A+A+A*A*B)C(K+@,@,?-?->.=/<+ *<*(*;+(*;*)*:+)*9+**9*+*8",
"++*8*,*7+,*6+-*6+-*5+.*5*/*4+/*3+0*2,0*2+1*1+2*0,2*0+3*/,3*/+4*.+5*-,5*-+6*-F E E E;*B*B*B*B*B*B*B*B*B*B*D#D(D(C)B*B*A+@,",
"?->.>( +=((+<)(+;))+:)*+:(++9(,+9(,+8(-+7(.+6).+5)/+5(0+4(1+3)1+3(2+2(3+1)3+0)4+/)5+/(6+.g9+A+A+A+A+A+A+A+A+A+A+A,?-<26;:",
",?->/<0;1:2:2938484847575665- /4. /4-(/3-)/2.)/2-*/2,+/1-+/0.+/0-,//.,/..-/.-./-../,.//,-0/+.0/+-1/+-1/+-1/+$/8/=/=/=/=/=",
"/=/=/;45947:.>.=/<0;1;1:2939( 08) 07)(07()07()06))05)*05(+04)+03),02)-02)-01).00)/00)/0/)00/)00.)10.(20-)20,)30,(40+$$X70",
"<0<0<0<0<0<0<0<0<06;-*10,+10*-10*-10(/10(/1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1q<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<0<",
"0<03*?.=.=/<0;0<0;0=/=/</=/=.=/0*//..,//.,/./,-0/,-0/+.0.,-0/,-0.-,1.+.1.+.1-,.1-,-2-,-1.,.0--3*T D(C)A.;3.)-?-?-?-?+A+@,",
"@,@+A+A+A+A*B57566574848392:2:1;0</=/=.>-?,@,@,@+A*B*4(2(5)2(4*2($$$$*6484593939393939393939393939,>.>.>.>-?-?-,@,@,?-?,@",
",@,@,?-?,@,,,4,)21, 5/?-@,A+0.0*.2.).5-,(8,@-@,@,@,@,@,@,@,@2:38- ,8,(,8,(-6-)-4-*.2-,/./,?.=0;37747:2:2(D(D#D(D(D(C(D(D(",
"(0784+,/2).01).11#/2:3939485757666)(16)(16((26((26 (36 (3938484848484936 (35((35()25)(24*(23,(12.(02.)/10).02*,/5**.725(B",
",?0<49D E D C)@-0=,@,@,@,@+A+A+A+A+A+A-?1<57767A,B+C)C)D)C)D)D)C)C)B*A*A*B*A*A*A*A*4#2+4(/+6),,74:/A=.?-?,@,@+A+A*B*B*B*A",
"*A+@,0;0<0<3884;1>.?-A*C)D(E E(E E*B.>1;2:394848484847)(/8(,*9)B*B*A+@,>/<1946K-+A+A+A*B*B*,8**,8**,8**,(:*,(:*+):*+(*(5*",
"+(*;+(*:,(-7,(13+)40+)5/+-4,+10,1-/*6+.)8*.(9).(9*-.4)-20)-4.)-5-)-5-)-5-)-5,).4-)-3.)./1).,4*-)5+.+2+/,/-/---0.*,20+(419",
"466390<-A+A67:2<3:2,,//.0,-/1,-.2*1+3(2+3#0.>-?-B*A+@,@,@,@+)/5+ 24:2;2;1+,13(+23(+) /8)).9(*.>.?-=/;1;5;1(#856. ,7. +0)+",
"-)*0*).)**(+)(.+*)(+3+/,1-.,0/<195591@*1(5748392938475.>,@,@,?,@,@+A294856666757*+,@+A+@+A+A*@*B*A*B)A*A*A*B*@+@*A*A+@*A*",
"A->.=->.>-?,@+A*DB*B*B*B**B*B*B*B*B*B*B*B*B*B*A+A+A+.-2+)5/+ 9-A+0/.+.3-*-6,-#8,A,A,@,@,A+A+A+A+A+A+@,@,@2:+ ,9, ,8,)-6,*",
"-3-+//.->/<2863L(/(8(0*5)0-0+0;1:293846557)C)C)C)C(D(D(D(D(D(,13(*51((++//( */..( (3--*4--)6-,)6-,)7-+)7-+)7-,#8-?-?-?-?-",
"?-?-?,?-*#:,)+8,(-6,)-6+*-5+,-3+.-1+0-.+45L)A+0<0<0<0;0<0-?-?,?-?-?-?-?,?-?-)-5:2<0>-@--*5,*/493:393:2:2:2;1+-/1)0.1(2-1 ",
"3-1 00;1:2:2:2:1;12 /01(//1*/-1,0)2/<1954L(D(-)8*-/-..>.=/<0;1938366)C)C)C)C)C)C)C)C(+14()61( ,)1/,.0.*10-)30<0<1;1;2;1;1",
"+*21).01).01(/0=/=/=/=/=/0 2.1 1/0*-1/+,1/-+1./*0.2+*/631r;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;g<0<0<0<0<<0<0<0<0<0<0<0",
"<0<0<0<0<0<0<00(00/)00/+.0--.0-/;3>-?,@+@,@+@,?,=/480;0<.>.>-?-?-?,@,@-?-@-?0=0=0=1<1=1<1>1<1=0=1=/>/>.@,A,?-=/;17547,@+@",
"*@.<18724E E E E E E E E E E E E 393939A+B*B*C)C)D(E $O939@,@,@,@,@,@,@,@,$} D)B+@->/<0;29<,<377492;0=./-/,.1-,-3-*-4-*,6",
",)-6-(,8,(,?,@,@,@,-/0,*4-,*7+,)9*,(;), .*1(20.(03. /5- .74939392;1;+ +;+ +;+ ,:+ ,9,(+9,(,8,(,7-),6,*-4-+-1.,/./->/<1:46",
"83=,=28,+*6--)4./(2/0(000).11(-2:2:293938484757575*,-5(0+8.()80((72( 63( 63948484857575# 55# 55# 55# 54((44((44((44()33(*",
"33(+23(+22(,21(.11(/0/)1/.)3.-)5-)+92A+@->/=/=-=.>.>,>->-?+@,?->,>.>-?,?,?-?,@+@+A+A+A+A*B*/-1+./0+,4-++8*+*;(**<(**,)3(*",
")-*2(***.0(*60(*7/ +7/ ,666/ -4/)-3.*.1/+.0.,?/<1954=*A,@.=0;2947574747574747484757484 ..?-A+B)C)D(D($=)C)B+A+A+A,2 4+2 4",
"+2 4+2 5)3(4)3(C*B*A+A,?.=0;1:4764:0D#D(B+@->.=0;1:-(*8-)*8,),6,)-5,(.5,)-6+)-6+),8*),8+(-7+(-8*)/5+(32+(50*/1-+2/,+4.+*)",
"---)+(2*,)+(3*,(+(,(,*+(+(,*+)2(,++)0),++)0)+-+(0)+-+(0)+-+(0)+-+(0),,+(+ +(,,*)+ +(,++(, +),)+)+)**3(,)+)2),)+*0),++5,-,",
"2,.-./0:3773E(B*@->.=0;19475674565639291:1;0;0</</=.=.>-?-.-0,,2--+5+,+7)-*9(,*+,/(,**/. ,)*1- ,)*23)*+#,3)*+(+3)+))+3), ",
"*+- +*0+- +*0+-(*,-,-(*-+--(+7-*+6-*+5-,+2/-,///<1:4682E)A+A+>.=/=/</=.=-?-?->.>-?->.>.>,?->-?-@+@+A*A+@+A+@+A+A*A+@*10-*",
".4++):*+(;)7)/)21,(04, -6-(,7-(,6+*-4,+-3,,-,#*+/<193853:0G-=196492--./,1,.+4,,,5,++6,*+7,*+@,@+A+A*A+A+A+A+,2.,*6,,(9+, ",
".*0)21,)04,(05, /6, .8+ .92:2:1<0<0<* +<* +<* +<*(+:+(+:+(,9+(,9**,7++,5,+,4,--0-//*/1:3782?-<37**.4*.-2*0-0+1,/*3,/*4+.*",
"5*/*A+A+@+A+@,@,@,@,?-,0/-+3--)**.,-()/,*. (2,)- (4,(/6, .7, -84849393939, ,9, ,9, ,9,(+9,(,8,(,7,*+7,*+7,+*7+,+6+-*5+/*4",
"*1*2*3*/+5,*+:/>/;3684.*.0/--/./--.0.+/0.*0//*0.0)1+2*1,1*1-.+20(.2:2:1;1;1:2)./?-A+C)4,0(3./(3.0 2/=/=0<0<0<0<0<0<00 100",
" 100 100 100(000(000(0/0*0.0+/./-0*0/<2864:2:28,*,5+.,1-.-/-./.--0-.-1+/-1+..0+///+//.,//.,/0,,03#.0<0:2:2)/.2 3,5)0*4+0)",
"3-0(3-0(3-0(3.0 2/0 2/=/=/=/=/=/=/1(0/1(0/1(0/1(0/1)//0*//0+./0+.//-../.--/0,-.2,,-5+)-91674:0-0,/-0.+/0.+/00 100 10<0<0<",
"0<0<0<0<0<0<0<;1;1;1;1;>.@,10,+10.)10.)100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100)/00)/0.--0.--0,1:F",
"+?.</</</</</;0;1:0:0;0;0:2:1:1:0;1;0;0;0;0<2:39/ *60),30*,20*-10+-0.....0.,.1.+-2.+-3.,+3.,+4.+,3.,+4.+-2.+.2-,/0-,0..-4",
"(/.>/<1;386529392:1</>-@+B)D $},@,@,2 3939A+B*C)D(E $$E,@,@,@,@,@,@,$} D)B+@->/<1:38-$$8?,?,?->->-?,?-?,?->-?,?-?,?-?,?-?",
",?-?,?-?-?,?-?,@,?-?,@,?-?,@,@,@,?-?,@,@,@,?-?-?,@,8g:2939293938393848483848474848384847575747575747575657575666665756666",
"5666666666566657575747574)B+@1 9 F E(D)B/#6+@*B)B*B)B)B)C)B)C)C)B)C(D(D(C(C)C(D(C)C(D#E#D(C)C(D(D(D(C(D(D(D#D(D(D#E#D(D(C",
"(D(?(B+AA*D(D E E $M E E D(D(0/1).10)-2/++3/<0</=/<0</<0<0;1;0<0;1;0;1;0;1;1:2:292:2939293938483:2;1</22:$N E *07 *;+(*;+",
"(= ,(<(+)<(+);(,);(+:+(+:*(,9+(+:+(+:*(+:+(+:*)+9+(,9+(+9+)+9+(+:*)+9+(,9+(,8+)+9+(,8,(,8+(,8,(,8+)+9+(,8,(,8+)+8,(,8,(,7",
",(-7,(,8,(,74:2;1>-A+C)7*B2:;1C)D(D D(> +(7-, 14, *:,@,@,?-?,?-?-0(2./+0-/,/./-../--//,..1*/.=/=.=* *<+ *<*(*;+()<*(*;+(*",
";*(+:+(*;+(*;*(+:*)+:*)*:+)*:*)+9- +92939392=/@,C)M(C*,-2.)C)C(c(D)B=.>.>->,@+A*A+A+@*A+A*A*B*A*B)C)C(B*B*B)C(C)C)B)C)C)B",
")C)B,@,?-?-?-?,@+A+A+@*B*<$OA+A+@,@+A+@+@,@,@+@+A+@,@+A+@+@,@,@+@+A+@,@+A+@+@,@,@+@+A+@,@,@+@+A+@,@+A*A+@,@+A+@+@,@,<(D(D",
"(D(D(C*BC)C)B)C)B*+;(*)=#+(=(*(=(+(=(*)<(+(=#D(C)C(C)B)C)B*B*A*B*A*A+@+A+@,@,?,@,?-?,?-?-?->->.>.>->.?,@,;+A@+B)C)C(C)03+",
").6+),7+),7,)+7,+)8,?,@,?,?->->.>->.=/=.=/</=/<0;1;1;1;1:1;1:2:1:2:29393938393938484848484836D(D(D(D(D(D(C)C E D(,<((+<)(",
"+<)(*=()*;*)*;*));**);*A+@,@+@,>.=-?-?->.=/</=/<0:2:29293939384847574846666666666662D(D=/;1;1;0<0;1;/;1;1;1;0:2:2:291;1;1",
";/;1;1;0<0;1;/=/;1;1;0:2:2:0;1;1;1;/;1;1;0;1;1;/=/;1;1;0<0:.>396693;3<0>/?2<76<0?.?-?->.>.=/=/=/=.<0<0<0</<0</<0<0</=/<.>",
".</=/=/=.=/=/=.>.=/=-?->-?-?-?,@,3$$$$y)4 4(5 3)47575756575657574757466656666566665756664757475756575747574757466C-;4683:",
"1</>-/./,-2.*-4-*-5,*,6-),7,),7,),7,),7,),6,+,4-+-2--../.=0:47482</>-/./+.2.*-5-(-6-(,8- ,8492:2:2:2:39, ,9, ,8- -6-)-5-)",
".2.+///,?.=0;2864=-<37,+,3+1*1+4)/+6(.,7(,-8#,.7(*06(*15()34()43()61#*8.(*9-(*;*(+= )+@,@,A,A+B*B+B+B+A+A*B)) ?())> ),< (",
".; (0;2:395772 )71((9.)(:-))9,+(9+-(8*/)5*1*2*3,,+73A)B+?.>.;0(+5.)-2.,-1-0+/-2+.,4*.,4*.+6)-,6*-+7)-+7)-+7)-,6).+6).,5(/",
"-3)./1*,2.*->-0(1./*2-/+3+.3.).6, .9* .9* .94848474848+ ./(.* /.-)* //-()).0,())//+(**0.)(*,01*.0/*/1-*294772</;3782;0>-@",
"+A+B)C)4)3 4+2 4,1 4,1 4,1 5+1 6)1(D(C)C*A+?.?-@-@,@,A*C(D(D E 0(9 /*B,@.?.>.>.3 1-3 2,3 3)4)C*A+A,?.<294691=.:6582</0+/-",
"-2-+,*.)-)-)0),),)2(,)+(+++(, ,(*,+(, ,(*,+(, ,(*-*(, ,(*-*(, ,(*-*(, ,(*,+(+(,(*,+(+(,(*,*)+),(+)*)+*,)1)+++*/)+,,).),.,",
"1+1,.-0,1--,),*,,,)/),++)1),),(+(,)+)+)**,(, ,(*,+(, ,(*-+(+ , +-+(1(*.+(1(*.+(1(*.+(1(+-+(2(*-+(2(*,+(, ,(+*,(, -)1),),*",
"/*,)-*-*,+-2--0*0/<1955<,>/;37,).4-,,2-/+1-0+/.0+/.0,../--//--//--.0--./..-/..-/-0,..0---2.*.37674,)02-+/0*((+( -.*)(+( .",
",+)(*)(.+**())*-*+0(*.)*7.(.21 .19748484((3:.((/ //) / .*(+2(,+(,0).)(+1*.(()2+A,?.=0;295591<#D)*# / #2)(6/+ 7.>.>->-0/,-",
"/1*-00*.0/*/-1*0-0+0-/*3,.*4-,*6-**7-**8,(*:- );0</>-?-?.>.>/=/<) -;) -:* -8**,8*+,7),,6*,+6)/*6)/*5*/*5)/*5*.+5*-+6*,+64",
"9392;.>-@+J/;3773;/./.-,3,+-5-),7,),8+(,9, +;+ +;+ +;+ +;+ ,9,(+9+),7,),7,*,5,,,3,/,/,296393773.+./-1,.,3,+,7+*,7,(,9+(+;",
"1;1;1;1;1;1;1;+ ,9, -7-(,7,).3.*.1.,0+0/;2873<,>19+*,5*0+2)4*0)6*.)7+,)9*,)9+**9+**:***:***:**,8**,8**-6*,.4*,/2*.1/)/3,)",
"15()377685773))40*-2.*01,*30**6.)*8.(*9- +;+ *<0=/=/=/=0<* +<)(+<))*;)*+:)++7*-+5*/+3*3,++82=.<2774.)/0/,../..-.0.+/0.*00",
"/)00/)00/)1//)1//)2..+2,.,3+-.2*-/3(.0:38567676764:1<..)4,.+3+.-3)/.3 /02 /1;1:2:393939393:20 /11 /10)/00*/-1,0)2.<286493",
"936-*-3+/-/-1,--2-,-3,+-4-*-5,*-5,)/4,)03,)03,)20-)3/,+4,-+5+,,7 -.=0:3859584:2:0=.- 7+-*7)--5)-.5 -1:39576584939393:39, ",
",8,(,8,),7++,5+-,3+/,1+2.*,73773;/./.+0/.+0/0)0/0 2/=/=/=/=/=/=/=/=/=/=/=/1(0/1(0/0+./0-,/./;1;/./.+0/0)0/0 2/=/=/=/=/=/=",
"/=/=/=/=/=/=/=/=/=/1(0/1(0/0+./0+././;;(B096492;.?,@,4+.*11,*-7+)+9+*#:-?-)+6.)+6.(,5/(,57493/ /20 /2/(0/1(0.1+/-0,0+1.;2",
"9477492:0;37658492:12(./0,-//.,-0/,-0/,-//--./-...../)1/<2764<8483:1</>-@+B)D(D(D(D(D(D(3*3(3*3(3*3(3*3(3*3(D(D(D)B*B)D $",
"^*B*B*B*B*B*B*B*$~ D)B+@->/<1:389-<377492;0=.0-.,/1-+.3,*.5,)-7+),8,(,9+ -9+ ,:2:2:2:2:39, ,8- -7- -6.(-4/(.20)/.2*; ,+: ",
",,8(,-5*,/1,,2,.,@,?,@,@,(,7-(-6,*,5-*-4,+-3-,-1--/-/.=0;294682>,=29+)-5*,.3)./1)/0/)01.(12,(22+(32+(33*(33)(44((44((44 )",
"4757575757575845 (45 (45 )35((35((26)(07*(.8**)+ 5-,*575757484848392:2,#32+(31-(20/)0/1)/.3).-5,)-82;.<54:1=.?,6(/+2/-)12",
"-(/5- /6, .740+(- -.6 -.6 .,2 *(.+1(*(0(1)*)<)*):+*+6,+.1-+A+@+A+@,?,@+A+@+@+@,@+?,@+@,?+@+A+?+A+@*@+A*A*A)C(D(D#J-<3773;",
"0=.?,A+A*B*C(E 4(5 4)B*B+A+A+B+A+A+2 5*2 6(3 E E(D(C*B*B+A,?.>0<3#)4848392939383838384748492;0=.?,A-<3683:1..,.-2,-,4,+,)",
"0*+),)2)+)+)4)*(,(,*+)+ ,(++,(+ +(,,+(1(+-,(0(+-,(0(+-,(0(+-,(0(+-,(0(,,,(* ,(+,+(+ ,)+*,(+(,),(,(+(-)2)+)-*0)+).+.)*+0.#",
")+,2/+-5+*04)+22)+6.(+8,(+8,)+8,(+7-)+6-)+6-),4-*+6-),6,),8))-:)(,;0=.>-?-@*C(L#9(/)9(.(**2( /**22*+05(+/7 +.>()(?(3,1*.1",
"/+-2.+,3.+,4-*,5-*,5-*,6,*,6,(.5- /5-(#)+4-,,2.-+10-+/1,.+3+) =*))3 .*(,/(/4),/4),/4),/5(,/=/=/@,@,=/=/<0@,>.<0<0@,@,<0</",
"=*<,?.=0;284(+1;0<0+(4/+*4/++2/*-2.+-1.+.0/*/0.*0/.+/0.*.0/*.1.+*5.+). ,.4*+02++0/,,1,/+4(1*A*B)B*B*A)C)B)C)A+A+A+A+A+A+A",
"*A+A+(*;1:1;1;.>-?+E-=2864:1/*//-0--,4,+,5,+,6,*+8,(+9,(+:+ ,:+ +<0<0<0<0<0<1:, +:, +9-(+8-(,6.(,6.(-4/*,11*0*. +,9(+-6*+",
"/2,+A+A+@,@+A+@,@,@+*+7,*+6,+,5,+,4,--1,/.--294691>,?/:+*,5+/*3*2*1*4*/+5*.*6+,+7*+,7+*,7+*,7,(,8, -8, -93939393939, -8, ",
"-8,(,8,(,7-(,6.),5.*+4( ,++1)(,,,-*),-4*-0/,,@,@,@,@+A+A+@+A+A*/*5*.,3*/,3)0-0*1..*3.,*5591?.;3774:0/+0-/-0+0.0*//0)0/1(0",
"01 00<0<0<0<0<0<0<0<0<01 1/1 1/1 1/1(0.2)0-2)1+3*B,@.2 13(,1;1;1;1;1;1.)01+/-0*2,0*2,0)/0/*.00*.0/+.0/,../..,/0:4773:1;19",
"-(,5-,,2.-,0/--./..-//.+0/.+0//*0//(2/0 2/0 2/0 2/0 2/=/=/=/=/=/=/1(0/1(0.2(0.2)0-2)0-2*0+3+0)4-3 1//)1;1;0<0.#30+-00+-00",
"+.//+///+0..+1-/+1-.-0--./.-/-.-1,.+5,)-81;54;/-1---1-+/1/)/1/ 11;1;1;1;1;1;1;1;1;1;1;10(/10(/10*-10*-10-?/=<0<0<0<0<;1;1",
";1;1;1;1;1;1;1;1;1;1;1;10(/1/)/1/+-1---1-/;@.=0:37566547472929273-+,3-,,2,.+1-/*1-0*0-1)0-2(0,3)/+5).+6 .+-(.(-*.).(- 0)/",
"(5,.)4-.+0/.,-1.=.>.>->.>.>-?-?->,@,@,@+?-?,?-?,@,?-?,?-?,:8483:1</>-@+B)D $},@,@,@,@,$$E E(D)C*B+A939@,@,@,@,@,$} D)B+@-",
">/<1:38-"
};