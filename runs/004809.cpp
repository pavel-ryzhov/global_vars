#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cmath>
using namespace std;

typedef vector<vector<int> > MatrixT;
namespace Color{enum{White, LightGray, DarkGray, Black, Colors, Mask = 0xff};};// Перечисления цветов и общее их число в соответствии с условием

const int Chars = 10;// Количество распознаваемых символов (10 цифр)
const int PatternWidth = 32, PatternHeight = 48;// Размеры образцов
const int PatternsPerChar = 27;// Количество образцов для каждого символа

class Archive{// Содержит упакованные образцы символов и предоставляет функцию для их распаковки
	static const int MaxRepNum = 87;// Максимальное число повторов символа кодируемое одним символом
	static const int Strings = 330;// Число строк в архиве
	struct RepMap{// Проекция символа на число повторов
		RepMap(): mp(256, 0){
			int i, k = 2;
			for(i = '('; i < '\\'; ++i, ++k) mp[i] = k;
			for(i = ']'; i <= '~'; ++i, ++k) mp[i] = k;
		}
		int operator()(int ch){return mp[ch];}
		vector<int> mp;
	};// struct Table
public:
	static void UnpackToString(string& dest){// Распаковка архива в строку dest
		dest.clear();
		string a;
		for(int i = 0; i < Strings; ++i) a += Data[i];// Записываем архивные данные в string для удобства
		
		char curr = a[0];// Первый элемент архива - для установления начального символа		
		for(string::iterator it = a.begin()+1; it != a.end(); ++it){
			const char& c = *it;
			if(c == ' ' || c == '#')// Соответствует одиночному символу
				dest += c, curr = (curr == ' ') ? '#' : ' ';// Добавляем символ в выходную строку и изменяем текущий символ на противоположный
			else if(c == '$')// Означает - повторить текущий символ MaxRepNum+1 раз
				dest.insert(dest.end(), MaxRepNum+1, curr);
			else // Все остальные символы представляют закодированное количество повторов
				dest.insert(dest.end(), CharToRep(c), curr), curr = (curr == ' ') ? '#' : ' ';
		}// for it
	}// UnpackToString()
private:
	static RepMap CharToRep;// Проекция символа на число повторов
	static char* Data[Strings];// Архивные данные (в самом конце файла)
};// class Archive
Archive::RepMap Archive::CharToRep;

struct CharMap{// Проекция символа на значение цвета
	CharMap(): mp(256, 0){
		mp['.'] = Color::White;
		mp['%'] = Color::LightGray;
		mp['#'] = Color::DarkGray, 
		mp['@'] = Color::Black;
	}
	int operator()(int ch){return mp[ch];}
	vector<int> mp;
} CharToColor;

template<typename T> struct PT{// Класс точки
	PT(){}
	PT(T x_, T y_) : x(x_), y(y_){};
	T dist2(const PT<T> r)const {return dist2(r.x, r.y);}
	T dist2(const T& x_, const T& y_)const {return (x-x_)*(x-x_) + (y-y_)*(y-y_);}
	T x, y;
};
template<typename T> PT<T> MakePT(const T& x, const T& y){return PT<T>(x, y);}

void ReadInput(MatrixT& M, istream& is = cin){// Считывает входное изображение
	string str;
	string::iterator s, s_end;
	vector<int>::iterator v;
	while(is >> str){
		M.push_back(vector<int>());
		M.back().resize(str.size());
		for(v = M.back().begin(), s = str.begin(), s_end = str.end(); s != s_end; ++s, ++v)
			*v = CharToColor(*s);// Преобразуем символ к соответствующему цвету
	}// while		
}// ReadInput()

class Segment{// Сегментация. 
public:
	// Константы в процентах закрашенных пикселей сегмента от СРЕДНЕГО значения по всем сегментам:
	// LOW_CP_PERCENT - минимальный процент закрашенных пикселей в сегменте. Если значение меньше, то сегмент не рассматриваем
	// INNER_CP_PERCENT - если один сегмент внутри другого и у внутреннего процент закрашенных пикселей больше этого значения, то внешний сегмент считаем рамкой.
	enum{LOW_CP_PERCENT = 10, INNER_CP_PERCENT = 50};
	static void Segmentate(MatrixT& M, vector<Segment>& Segs){// Сегментация матрицы и запись сегментов в Segs
		VerticalSplit(M);// Пробуем вертикально разделить символы
		AddWhiteBorder(M);// Добавляем к M белую рамку для нормальной работы Mark()
		//PrintMatrix(M);
		int id = Color::Mask+1;// Идентификатор сегмента будем хранить в старших битах, после цвета
		int cx = (int)M[0].size(), cy = (int)M.size();
		for(int y = 0; y < cy; ++y){
			for(int x = 0; x < cx; ++x){
				if((M[y][x] & ~Color::Mask) == 0 && (M[y][x] & Color::Mask) > Color::LightGray){// Если не принадлежит какому либо сегменту и цвет темнее светло-серого
					//cout << x << " " << y << " id = " << id << endl;
					Segs.push_back(Segment());// Создаем новый сегмент
					Segment& s = Segs.back();
					s.Mark(M, MakePT(x, y), id);// Отмечаем точки принадлежащие данному сегменту					
					s.CopyData(M);// Копируем прямоугольник из матрицы М в матрицу сегмента С
					id += Color::Mask+1;
					//PrintMatrix(s.C);
				}
			}// for x
		}// for y
		//PrintMatrix(M);
	}// Segmentate()

	static void ApplyHeuristic(vector<Segment*>& ps){
		RemoveFrameSegs(ps);// Удаляем рамки
		UnionOverlapedSegs(ps);// Объединяем сегменты перекрывающиеся по горизонтальным проекциям
		RemoveSmallSegs(ps);// Удаляем маленькие сегменты
		UnionNearestSegs(ps);// Объединяем относительно близко расположенные сегменты
	}//ApplyHeuristic()

	static void VerticalSplit(MatrixT& M){// Вертикальное разделение на отдельные символы
		int cx = (int)M[0].size(), cy = (int)M.size();
		MatrixT ColStat(Color::Colors, vector<int>(cx, 0));// Статистика по цветам в каждом столбце
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				++ColStat[ M[y][x] ][x];
		
		for(int x = 0; x < cx; ++x)
			if(ColStat[Color::Black][x] < 1 && ColStat[Color::DarkGray][x] < 2)
				for(int y = 0; y < cy; ++y)// То проводим вертикальную белую полосу
					M[y][x] = Color::White;		
	}//VerticalSplit()

	static void AddWhiteBorder(MatrixT& M){// Добавляем к M рамку толщиной в 1 пиксель с каждой стороны цветом Color::White
		int cy = (int)M.size();
		for(int y = 0; y < cy; ++y)// Добавляем слева и справа
			M[y].insert(M[y].begin(), Color::White), M[y].push_back(Color::White);
		M.insert(M.begin(), vector<int>(M.back().size(), Color::White));// Сверху
		M.push_back(vector<int>(M.back().size(), Color::White));// Снизу
	}// AddWhiteBorder()

	static void UnionNearestSegs(vector<Segment*>& ps){// Объединение сегментов составляющих один символ
		int n = (int)ps.size();
		if(n < 2) return; 
		sort(ps.begin(), ps.end(), Segment::CmpPtrByX);// Сортировка сегментов по x координате
		vector<vector<PT<int> > > Contours(n);// Для хранения точек контуров сегментов
		for(int i = 0; i < n; ++i) ps[i]->EnumContourPoints(Contours[i]);// Находим точки контуров
		// Находим минимальные расстояния между контурами для всех пар сегментов
		vector<vector<double> > D(n, vector<double>(n, 0.0));
		for(int i = 0; i < n; ++i)	
			for(int j = i+1; j < n; ++j)
				D[i][j] = D[j][i] = sqrt((double)MinDist2(Contours[i], Contours[j]));
		// Находим максимальное расстояние между соседними сегментами отсортированными по x координате		
		double MaxDist = D[0][1];
		for(int i = 1; i < n; ++i)
			if(D[i-1][i] > MaxDist) MaxDist = D[i-1][i];
		// Если все сегменты слишком близко друг к другу то выходим
		if(MaxDist < 4.0) return;
		double Threshold = max(MaxDist*0.2, 1.1);// Если сегменты ближе чем эта величина то объединяем их		
		// Объединение
		vector<int> Consumed(n, 0);// Consumed[i] = true - если сегмент i поглощен другим в результате объединения
		for(int i = 0; i < n; ++i){
			if(Consumed[i]) continue;
			for(int j = i+1; j < n; ++j){
				if(Consumed[j]) continue;
				if(D[i][j] >  Threshold) continue;
				*ps[i] += *ps[j], Consumed[j] = 1;
				for(int k = 0; k < n; ++k)// Обновляем расстояния до нового объединенного сегмента
					D[i][k] = D[k][i] = min(D[i][k], D[j][k]);
				i = -1; break;// Т.к. расстояния поменялись начинаем все с начала
			}// for j
		}// for i
		Erase(ps, Consumed);
	}// UnionNearestSegs()

	static void UnionOverlapedSegs(vector<Segment*>& ps){
		int n = (int)ps.size();
		if(n < 2) return;
		vector<int> Consumed(n, 0);// Consumed[i] = true - если сегмент i поглощен другим в результате объединения
		for(int i = 0; i < n; ++i){
			if(Consumed[i]) continue;
			for(int j = i+1; j < n; ++j){
				if(Consumed[j]) continue;
				if(IsOverlaped(*ps[i], *ps[j])){
					//cout << "Overlaped\n"; PrintMatrix(ps[i]->C); PrintMatrix(ps[j]->C);
					*ps[i] += *ps[j], Consumed[j] = 1;
					i = -1; break;// Т.к. размеры сегментов поменялись начинаем все с начала
				}
			}// for j
		}// for i
		Erase(ps, Consumed);
	}// UnionOverlapedSegs()

	static bool IsOverlaped(const Segment& a, const Segment& b){// Возвращает true если относительно большая часть сегментов перекрывается		
		if(a.LeftTop.x > b.LeftTop.x) return IsOverlaped(b, a);
		int overlap = a.RightBottom.x - b.LeftTop.x + 1;
		if(overlap <= 0) return false;// Не перекрываются
		int la = a.RightBottom.x - a.LeftTop.x + 1, lb = b.RightBottom.x - b.LeftTop.x + 1;// Горизонтальные проекции длины сегментов
		int part_a = Percent(overlap, la), part_b = Percent(overlap, lb);// Проценты перекрытий
		int threshold = 90;// Если процент перекрытия какого либо сегмента больше этой величины, то считаем сегменты перекрывающимися
		return (part_a > threshold || part_b > threshold);
	}//IsOverlaped

	static void RemoveSmallSegs(vector<Segment*>& ps){	// Удаление слишком маленьких сегментов
		int av_cp = AverageCp(ps), n = (int)ps.size();// Среднее число закрашенных пикселей на сегмент и общее число сегментов
		vector<int> Erased(n, 0);// Erased[i] = true если сегмент i удален
		for(int i = 0; i < n; ++i)
			if(Percent(ps[i]->cp, av_cp) < LOW_CP_PERCENT)
				Erased[i] = 1;
		Erase(ps, Erased);
	}// RemoveSmallSegs()

	static void RemoveFrameSegs(vector<Segment*>& ps){// Удаление сегментов похожих на рамки
		int av_cp = AverageCp(ps), n = (int)ps.size();// Среднее число закрашенных пикселей на сегмент и общее число сегментов
		vector<int> Erased(n, 0);// Erased[i] = true если сегмент i удален
		for(int i = 0; i < n; ++i)
			for(int j = 0; j < n; ++j)
				if(ps[i]->IsInside(*ps[j]) && Percent(ps[i]->cp, av_cp) > INNER_CP_PERCENT)// Если сегмент достаточно большой и находится внутри другого то удаляем внешний
					Erased[j] = 1;//, cout << "RemoveFrameSegs " << j << endl;
		Erase(ps, Erased);		
	}//RemoveFrameSegs()

	static int MinDist2(const vector<PT<int> >& a, const vector<PT<int> >& b){// Находит ближайшую пару точек и возвращает квадрат расстояния между ними
		int md = a.front().dist2(b.front());
		for(vector<PT<int> >::const_iterator it1 = a.begin(), end1 = a.end(); it1 != end1; ++it1){
			for(vector<PT<int> >::const_iterator it2 = b.begin(), end2 = b.end();  it2 != end2; ++it2){
				int d = it1->dist2(*it2);
				if(d < md) md = d;
			}// for it2
		}// for it1
		return md;
	}// MinDist2

	void EnumContourPoints(vector<PT<int> >& points){// Записывает в points контурные точки сегмента
		int cx = (int)C[0].size(), cy = (int)C.size();
		for(int y = 0; y < cy; ++y){
			int lx = 0, rx = cx-1;
			while(!C[y][lx] && lx < cx) ++lx;// Крайний левый закрашеный пиксель в строке
			while(!C[y][rx] && rx >= 0) --rx;// тоже  - правый
			if(C[y][lx]) points.push_back(MakePT(LeftTop.x+lx, LeftTop.y+y));
			if(C[y][rx] && lx != rx) points.push_back(MakePT(LeftTop.x+rx, LeftTop.y+y));
		}// for y
	}// EnumConturPoints()

	static int AverageCp(vector<Segment*>& ps){// Подсчитывает среднее число закрашенных писелей по сегментам
		int TotalCp = 0, n = (int)ps.size();
		for(int i = 0; i < n; ++i) TotalCp += ps[i]->cp;
		return TotalCp/n;
	}// AverageCp()

	static void Erase(vector<Segment*>& ps, const vector<int>& Erased){// Удаляет сегменты i для которых Erased[i] = true
		//for(int i = 0; i < Erased.size(); ++i) cout << Erased[i] << " "; cout << endl;cout << "Erase " << ps.size() << endl;
		vector<Segment*> copy_ps(ps);
		ps.clear();
		for(int i = 0; i < (int)copy_ps.size(); ++i)
			if(!Erased[i]) ps.push_back(copy_ps[i]);
		//cout << "After Erased " << ps.size() << endl;
	}// Erase()

	void Mark(MatrixT& M, const PT<int>& from, int id){// Отмечает все пикселы смежные с from значением id 
		//Для правильной работы Mark() все граничные пикселы входной матрицы должны иметь цвет Color::White
		this->id = id; cp = 0;
		LeftTop = RightBottom = from;
		vector<PT<int> > stk;

#define Insert(x, y) if((M[y][x] & Color::Mask) != Color::White && (M[y][x] & ~Color::Mask) == 0) M[y][x] |= id, stk.push_back(MakePT(x, y));
		Insert(from.x, from.y);
		while(!stk.empty()){
			int x = stk.back().x, y = stk.back().y; stk.pop_back();
			++cp;
			// Обновляем границы сегмента
			if(x > RightBottom.x) RightBottom.x = x;
			else if(x < LeftTop.x) LeftTop.x = x;
			if(y > RightBottom.y) RightBottom.y = y;
			else if(y < LeftTop.y) LeftTop.y = y;
			// Обрабатываем соседей
			if((M[y][x] & Color::Mask) == Color::LightGray) continue;// По светло-серым не переходим
			Insert(x, y-1);Insert(x-1, y); Insert(x+1, y); Insert(x, y+1);
			if((M[y][x] & Color::Mask) == Color::DarkGray) continue;// По темно-серым не делаем диагональные переходы
			Insert(x-1, y-1);  Insert(x+1, y-1);			
			Insert(x-1, y+1);  Insert(x+1, y+1);
		}// while
#undef Insert
	}// Mark()

	void CopyData(MatrixT& M){// Копируем минимальный прямоугольник матрицы M содержащий пиксели этого сегмента
		int cx = RightBottom.x - LeftTop.x + 1;
		int cy = RightBottom.y - LeftTop.y + 1;
		C.assign(cy, vector<int>(cx));
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				if((M[y+LeftTop.y][x+LeftTop.x] & ~Color::Mask) == id) C[y][x] = (M[y+LeftTop.y][x+LeftTop.x] & Color::Mask);
	}// CopyData()

	bool IsInside(const Segment& s){// Возвращает true если this внутри s
		if(this == &s) return false;
		return LeftTop.x > s.LeftTop.x && LeftTop.y > s.LeftTop.y && RightBottom.x < s.RightBottom.x && RightBottom.y < s.RightBottom.y;
	}// IsInside()
	Segment& operator +=(const Segment& r){// Объединение сегментов this и r
		// Вычисляем новые границы сегмента
		PT<int> lt = MakePT(min(LeftTop.x, r.LeftTop.x), min(LeftTop.y, r.LeftTop.y));
		PT<int> rb = MakePT(max(RightBottom.x, r.RightBottom.x), max(RightBottom.y, r.RightBottom.y));
		MatrixT W(rb.y - lt.y + 1, vector<int>(rb.x - lt.x + 1, 0));// Сюда будем записывать объединенные данные
		// Копируем данные из матрицы this->C в W
		int dx = LeftTop.x - lt.x, dy = LeftTop.y - lt.y;
		int cx = (int)C[0].size(), cy = (int)C.size();
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				if(C[y][x]) W[y+dy][x+dx] = C[y][x];
		// Копируем данные из матрицы r.C в W
		dx = r.LeftTop.x - lt.x, dy = r.LeftTop.y - lt.y;
		cx = (int)r.C[0].size(), cy = (int)r.C.size();
		for(int y = 0; y < cy; ++y)
			for(int x = 0; x < cx; ++x)
				if(r.C[y][x]) W[y+dy][x+dx] = r.C[y][x];
		// Перезаписываем матрицу, устанавливаем новые границы и суммируем количество закрашенных пикселей
		C = W, LeftTop = lt, RightBottom = rb, cp += r.cp;
		return *this;
	}// operator +=()
	static int Percent(int cmp, int to){	return (cmp*100)/to;}// Процент величины cmp в to
	static bool CmpPtrByX(const Segment* l, const Segment* r){ return l->LeftTop.x < r->LeftTop.x;}// Для сортировки указателей на сегменты по x координате

	int id, cp;//Идентификатор сегмента и количество закрашенных пикселов 
	PT<int> LeftTop, RightBottom;// Границы прямоугольника сегмента в исходной матрице Image 
	MatrixT C;// Минимальный прямоугольник из Image с началом в LeftTop содержащий только пикселы текущего сегмента. 
};//class Segment

class Recognizer{// Распознавание символа
public:
	Recognizer(const string& PatternsString){// Конструктор получает строку шаблонов состоящую из символов '#' и ' ' и строит из них матрицы шаблонов
		string::const_iterator it = PatternsString.begin();
		MatrixT M(PatternHeight, vector<int>(PatternWidth));
		PatternFields.resize(Chars);// Количество символов 
		for(int d = 0; d < Chars; ++d){
			PatternFields[d].resize(PatternsPerChar);// Количество шаблонов для каждого символа
			for(int k = 0; k < PatternsPerChar; ++k){
				for(int y = 0; y < PatternHeight; ++y)
					for(int x = 0; x < PatternWidth; ++x)
						M[y][x] = ((*it++ == '#') ? Color::Black : Color::White);
				CalcField(M, PatternFields[d][k]);// Вычисляем поле потенциалов создаваемое этим символом
			}// for k
		}// for d
	}// Recognizer();

	int Recognize(const MatrixT& M){// Распознавание. Возвращает число соответсвующее разпознанной цифре
		// Для распознания используется метод потенциалов
		MatrixT N;// Хранит нормализованную матрицу
		NormalizeMatrix(M, N);
		vector<double> F;
		CalcField(N, F);// Вычисляем поле потенциалов
		vector<double> U(Chars, 0.0);// Хранит суммарное значение обратной разности потенциалов для каждой цифры
		for(int d = 0; d < (int)PatternFields.size(); ++d){
			for(int i = 0; i < (int)PatternFields[d].size(); ++i){
				double r = Distance(F, PatternFields[d][i]);				
				U[d] += 1e6/(1.0+r);
			}
		}// for d
		return (int)(max_element(U.begin(), U.end()) - U.begin());// Ответ: индекс цифры с наибольшим суммарным потенциалом		
	}// Recognize()
private:
	static double Distance(vector<double>& a, vector<double>& b){// Вычисляет квадрат расстояния между двумя векторами
		double d = 0.0;
		for(int i = 0; i < (int)a.size(); ++i){
			double r = a[i] - b[i];
			d += r*r;
		}
		return d;
	}// Distance()

	static void CalcField(const MatrixT& M, vector<double>& F){// Вычисляет значения потенциалов в матрице M. Результат в вектор F
		// Каждый элемент поля имеет собственный потенциал, равный единице и который, в свою очередь, увеличивает потенциалы
		// всех соседних элементов по вертикали, горизонтали и диагоналям на 0,5.
		int cx = (int)M[0].size(), cy = (int)M.size();
		F.clear();
		// Временная матрица для суммирования потенциалов. Больше исходной на 1 с каждого края, чтобы не обрабатывать выход за границы.
		vector<vector<double> > T(cy+2, vector<double>(cx+2, 0.0)); 
		for(int y = 0; y < cy; ++y){
			for(int x = 0; x < cx; ++x){
				if(M[y][x]){
					++x, ++y;// Приводим координыты матрцы M к координатам в матрице T
					T[y-1][x-1] += 0.5; T[y-1][x] += 0.5; T[y-1][x+1] += 0.5;
					T[y][x-1] += 0.5; T[y][x] += 1.0; T[y][x+1] += 0.5; 
					T[y+1][x-1]+= 0.5; T[y+1][x] += 0.5; T[y+1][x+1] += 0.5;
					--x, --y;// Восстанавливаем прежние координаты
				}
			}// for x
		}// for y
		for(int y = 1; y <= cy; ++y)// Записываем результаты в вектор
			F.insert(F.end(), T[y].begin()+1, T[y].begin()+cx+1);		
	}// CalcField()

	static void NormalizeMatrix(const MatrixT& src, MatrixT& dest){// Нормализация
		//Вписываем исходуню матрицу src в dest по высоте, изменяя пропорционально ширину. Если новая ширина больше то сжимаем изображение и по ширине.
		// Если же новая ширина оказалась меньше PatternWidth, то располагаем изображение по центру, а края заполняем цветом Color::White
		int cx = (int)src[0].size(), cy = (int)src.size();
		float ratio = (float)PatternHeight/(float)cy;
		int new_cx = (int)(ratio*cx);// Новое значение ширины
		dest.assign(PatternHeight, vector<int>(min(new_cx, PatternWidth)));// Новый размер ширины не больше ширины шаблона
		Fit(src, dest);// Вписываем
		if(new_cx < PatternWidth){//Если новая ширина меньше
			int dx = PatternWidth - new_cx;
			int lb = dx/2, rb = dx-lb;// Ширины левой и правой полос соответвенно
			for(MatrixT::iterator it = dest.begin(), end = dest.end(); it != end; ++it)// Вставляем справа и слева белые полосы
				it->insert(it->begin(), lb, Color::White), it->insert(it->end(), rb, Color::White);
		}
	}// NormalizeMatrix()

	static bool Fit(const MatrixT& src, MatrixT& dest){// Вписывает изображение src в dest
		int s_cx = (int)src[0].size(), s_cy = (int)src.size();
		int d_cx = (int)dest[0].size(), d_cy = (int)dest.size();
		int x_ratio = (s_cx << 16)/d_cx;
		int y_ratio = (s_cy << 16)/d_cy;		

		for(int y = 0, s_y = 0; y < d_cy; s_y += y_ratio, ++y)
			for(int x = 0, s_x = 0; x < d_cx; s_x += x_ratio, ++x)
				dest[y][x] = src[s_y >> 16][s_x >> 16];
		return true;
	}// Fit()

	vector<vector<vector<double> > > PatternFields;// Потенциальные поля создаваемые шаблонами символов для каждой цифры
};// class Recognizer

int main(){
	string str;
	Archive::UnpackToString(str);// Распаковка строки шаблонов
	Recognizer Rgz(str);//Распознавание будет на основе этой строки шаблонов

	MatrixT M;
	ReadInput(M);

	vector<Segment> Segs;// Память под сегменты
	Segment::Segmentate(M, Segs);// Сегментация
	// Далее работаем с указателями на эти сегменты
	vector<Segment*> PSegs;
	for(vector<Segment>::iterator it = Segs.begin(), end = Segs.end(); it != end; ++it)
		PSegs.push_back(&*it);

	Segment::ApplyHeuristic(PSegs);// Применяем эвристические алгоритмы
	// Распознавание каждого сегмента
	for(vector<Segment*>::iterator it = PSegs.begin(), end = PSegs.end(); it != end; ++it)
		cout << Rgz.Recognize((*it)->C);
		
	cout << endl;
	return 0;
}// main()

// Упакованные данные шаблонов символов
char* Archive::Data[Strings] = {
	" 3,=286583:1<//,/.-0---2-,,4,+-4-*,6,*,6,),8,(,8,(,8,(,8,(,8, -8, ,:+ ,:+ ,:+ ,:+ ,:+ ,:+ ,:+ ,:+ ,:+ ,:+ ,:+ -8,(,8,(,8,",
"(,8,(,8,(,8,),6,*,6,*-4-+,4,,-2-,.0-./,//<1:385682>+>19-(,6.+*4/-)20.)01/)/10(.21(-21(,32(+32(*42))43()43) 54( 54( 54( 54",
"8484857575757575757484( 54( 54( 54( 54((43()43()43(*32(+32(,21(-21(.10(/1/)00.)2/-)4.+*7,(,91A-?->0<2:3857567;20(1/0(1//)",
"2..)5,-*5,,*7+,*8*+*9**+9***:*)+;))+;)(,;)(,;)(+<) ,<) ,<) ,<0<0;1;1;) -;) .:((.9)(.9()/7))/6)+/4*+02*,02*,2/*.3++/<1:385",
"673<-A(C+?/=0;1:291+#50,#5/-(3/.)2.0(2-1)1-3(/-4).-5(.,6)-+8),+8)++:(++:(*+;))+;))+;))+;)**<(**<(**;)+);)+);)+);(,);(,);(",
",);(-):(-):(-):(-):#/)9#/)8(/)8(0)7#1*5(2)5(2+2(4+/)7-)+91=-?+?/;376592;1;0=.?,@,A+A*B*3 5(3)4(3*4 3*4 3+3 2,@,@,@,@,@,@-",
"@,@,@,@,2 3,2 3,2 3,2 4*3(3*3(4)2)5 3*B*A+A,@->/<0;2:385674;/>,=29468392;1.--/-0---(-),-,(0(,+,(2(+++(4(*++ 5(+)+(++, +)+",
" +-+(+(+ +.+ + + +/+(* + +/+(* + +0*(* *(*1*(* *(*1+ /(*1+ /(*1+ /(*1+ /(*1+ /(*1+ /(*1+ /(*1*(/(*1*(* *(*1*(* + *0+ + + ",
"+/+ + + +/*(+ +(+-+ +(, +-+ +)+ ,++(+)+(4(+*,(3 ,++(2(,+,(0(,,-(.(---)*)-/--//<1:386582=->/;385583:2;02*-.3+--/ ),,,/)(-,",
"+/)(,-*/*(+/)/00).1* +(/2#*+ /7+ .8+ 07756*+-3(#*+-2--)5--)5--)5 (++*9**.664839* .9* .4#** .3)(+ .)#.1(. (0.)20-)11-*/4*+",
".4+,.,)**-/+))+./*)(+0/)/29476583;/?*?0;),)8*.*5*0*3( (1*2# (2# (1( (2# )/( )2( ).#()3#((-(((4#(),#()4#()+(()4#))*(()4#))",
"*#))4#)))())4#)*(((*4())(#)*4())(#)*4())(#)*4()) ()*4()) ()*4()) ()*4()) ()*4()) ()*4()) ()*4()) ()*4()) ()*4()) ()*4())(",
"#)*4())(#)*4())(#*)4())(())4())(())4()))#))4(()*(()4(()*(()4(()+#)(4#)(,(((4#()-( )2(((.(((2( )/( (2( (1*2# (2( (0+3*0*5*",
".*8),);0F(@->.<0<1:2947, .7+).4,*.4+,-4+,-3+.,3*/-2*0,1*1-/+1-/+1-/+1-/+1-.+2-.+2-.*3--+3--*4--*4--*4--*4-,*5,-*5+.*5-,*5",
"+.*4,.)5,.*4*0)4+0)3+1)3+1)2+2)2*4)0+4*.+6),,6+++7- ,92<.?,D,?/:3865,-+(#0+**(+(#.+)()) +0*)#.# *(#-*((/# * #,+(#2+ #++ #",
"3+ #*+(#4*(#)+(#4+ #(, (4+(# , #5+(# , #5+(# , #5, # , #5, # +(#5, -(#5,(,(#5,(,(#5,(,(#5,(,(#5,(,(#5,(,(#5,(,(#5,(,(#5,)",
", #5, # , #5, # , #5, # , #5+(#(+ #5+(#(+ (4+(#(, #4+ #), #3+(#*+ #3+(#*+(#2+ #,+ #1, #,+(#/, #.+(#.+(#/, #,+(#1-)-((25((",
"2#(1)(4#*,*(7(.);/>,?/;2956-),5,-+4+/+2+0+2+1+1*2+0+3*0*4*0*4+/*4+/*5*/*5*.+5*.+5*.*6*.*6*.*6*.*6*.*6*.*6*.*6*.*6*.*6*.*6",
"*.*6*.*6*.*6*.+5*/*5*/*5*/*5*/*4+/*4*0+3*0+3*1*2+1+1*2+0+3+/*5+-+5-),7492<.@*A-=*));)-(9)/(7)0)6)1)4)2)4)3)3)3)2*3)2)4*0*",
"4*0*5)0*5)0*5*.+5*.+5*.+5*.*6*-+6*-+6*-+6*-+6*-+6*-+6*-+6*-+6*-+6*.*6*.+5*.+5*/*5*/*5*/*5)0*5)1)4*1)4*1*3)3)3)3)2)4)2)5)1",
"(6*/)7).)9*+);0>-@+?/;+)+8*-*6)0*4*1*2*3*1*3*0+3+/*5*.+5+-+5+,,5,++6,++7+*,7,),7,),7,),7,),7,(-7,(-7,(-7,(-7,(-7,(-7,(-7,",
"(-7,(-7,),7,),7,),7,),7,),7,*+7++,6++,5,,+5+-+5+.*5*/+3+0*3*2)3*2*1*4*/*6*-*9*)+;/?*A,?/<*(+:+)*:**+8+*+8+*+8+*,6,*,6,*,6",
",*,6,++6,+,5,+,5,+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,5,+,5,+,5,+,5,+,5,+,5,+,5,++6,++7+",
"++7+++7,)+9, ,92;0>->/=/;4683.*-3,--1,/-/,1---2-+-4,+-4-)-5-)-5-)-6- .6- .6- -7- -75758484839393939393848575757- -7- -7- ",
"-6.(-5-)-5-)-5-*,4.*-3-,,2---0..-/-0---2.).4764;/>,>0;2948,(,7,*,6+,+5,-+4+.+3,.,2,/+2+0+2+0+1,0+1,0+1,0+1,0+1,1*1,1*1+2*",
"1+2*1+2*1+2*1+2*1+2*1+2*1+2*1+2*1+2*1+2*1,0+1,0+1,0+1,0+1,0+1,0+1,0+2+0+2,.,2,.,3+.+4,-+4,,+6,*,7,(,8492;0?+A+@)()=*()<**",
");**):+**9+**9+**9+*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+",
"6-*+6-*+6-*+6-*+6-*+8+**9+**9+**:**);**)<)*(=*()?,=0<09,),6,,,3,.,1-.-/...-.0--.0.+/0.+/0/*/0/*/0/)000(000(000 10<0<0<0<0",
"<0<0<0<0<0<0<0<0<0<0<0<01 000(000(000(000)/0/*/0/+.0/+.0.--//.-../-.-1,.,4+,,6+)-90A0<0:,)*7,,+4,.+2-.+1..,/..-./..,0..,/",
"/.+0./+0./+0./*0//)1//)1.0)1.0(1/0(1/0 2.1 2.1 1/1 1/1 1/=.1 2.1 1/1 1/1 1.1(1.1(0/1(0.1)0.1)//0*//0*//0*/.0+/./,.//--/..",
"-../-.-1,.,2,-,4+,,6+),:0B/=/;+)+7*.+4+/+2+1+0+2+0+3+.,3,-,3,,-3-+-3-+-3-*-5-)-5-)-5- /575757575757575757575757575757575.",
"(-5-)-5-)-5-)-5-*-3-+-3-,,3,-,3,.+3+0*3*1+1+2*0+4*/)8**+;/=.<29476665,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5",
",,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+66667492<.=0;***9+",
"**9+*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*",
"+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+8+*+8+*+9**+9***;0A1;1946757492;/=/=.3)/,2,.,//.,//.+/2,+.3,+.3,*/3,*.4,).3.).3.).3.",
"(.4.(.4.(.4.(.3. .5. .5. .5. .4.(.4.(.4.(-4.)-4.)-3.*-3.*.1/*.0/+.0/+..1+1(3.<0<0;2938486490G,?/7)(07) 258483:2:1/(01,.-1",
"+0,0,0,0+2+0+3*/+4*/+4*/+4*/+5).,5).,5).,5).,5).+6).+5*-,5*-,5*-,5*-,4+-,4+-,4+-,3+.,3+.-1,.-1+/-1+/-0,/-/,0-/,0-.,1.-,2-",
",,3.*-3/(-56667492;/@0<0;2:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:**",
"*:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:2;0=* *=* *;, ,7. -6. .4.).2.+.0/+///+/.0+0",
",1+1+1+1*2+2)2+2)2+2(3+3 3+3 3+3 3+3 3+3 3+3 3+A+A+A+A+A+3 3+3 3+3 3+3 3+3 3+3 3+3 3+3(2+2)2+2)2+2*1+1+1+1,0+0./+///+/0.+",
".2.).4. .5. -8, ,;* *=.=*(*<*(*<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)",
"*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*<*(*=.G)B*A+A+@,?->.=/<0:2937/ +50(+5/)",
"+5.*+5,,+5*.+5(0+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+H(A+?-<0:275572:/=.+)6.#-6666666666666666666",
"66666666666666666666666666666666666666666666666666666666C)C)?-=/<0;1847+(.6+).5*+.5*+.3+,.2*..0+/./*1.-+1/-)3/=/=.>.>.>.>",
".>.>.>.>.>.>.>.>.>.>.>.>.>.=/=/=.>.>.>.>.>.>.>.>.>+B#C,?.>.=/<0;1:2:1:2947,(,8+*+7+*,7+*,7*,+6*-+6*-+6).+A+A+A+B*B*B)C)C)",
"C)C)C)C)C)C(D(D(D(D(D(D(D(D(D(D(D(D(D(E(D#E,<2672:0</=->-=.=.>.>.=0<66666675757575757575757575757575756666666757575758492",
"<*$M E E(C-<E#C)A+?-=/:293754/),20*,00,,.0.,..+)(,.,++(,.*+-(,/)(0(,/5(,04(,04(,1))-(,1#+-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7",
"-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,7-(,757575A#C)?-;1845766666* 1;1;1;1;1;+))<*))<*(*<*(*<*(*",
"<)(*=)(*=)(*=)(*=)(*=) +=) +=) +=) +>( +>.>.>.>.>.>.>.>.>.>.>.?-?-?,@,@,@,@,@,@,B#D(C)A+@,?-=/>.@,A+A+A+A+A+A+A+A+A+A+A+A",
"+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A,>/<1;1F( #B*A+?->.=.=.<0:1:28+(,8+),8+),8(,*B*A*B)B*B*B)B)C)B*B*B*A*B)B*",
"B*B*B*B*A+A+@,@,@,@,@,@,@,@+@,?->.>/=*B)O*A+ #>, #=- #4)+. #3**/ #46 #55 #6*)- #5#,. #64 #=- #=- #=- #=- #=- #=- #=- #=- ",
"#=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- #=- (:384F#F#678*B*@,?->.<, )",
"<*))<(+)<#,)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)::2:2:>#D(B*@,>.<* +;*)*9*+*9(-*B*B*B",
"*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*A,@,:757?#D(A+<093>.@,@,A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+",
"A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+@-?-?-?-=16:>#D(C)A+@,?-=/>.@,A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A",
"+A+A+A+A+A+A+A+A,>/<1;1>*B*@,?->.<, )<*))<(+)<#,)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)",
"::2:2:70<0;1;1B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*A)C)C)B*A+@,=/A+A+A",
"+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+=2>*B*@,?->.<, )<*))<(+)<#,)C)C)C)C)C)C)C)C)C)",
"C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)::2:2:9757575#+1;0<0<0<0;0<0<0<0<0;0<0<0<0:1;1;1;1:1;1;1;1;1:1;1;1;",
"1:1;1;1;1:1;1;1;1;1:1;1;1;1:1;1;1;14=3575=/>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.>.",
">.>.>.>.>.98=#D(C)B*A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+?/=/B*B*B*B*B",
"*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*K+A+@-=/=/=/<0<0;0<0929383936637484847",
"5748484,(/5**/;/=/=/</=/=/</=/;1;1;/<0;0<0<0:1;1;1:1;1:0<0</;1P+@->.=/<0;1:293847566565. .4.(.3-*.2-*/1-+.1-,.1,-.0,..0+/",
"-1)0.1(1.>.>-?->-?-?-?-?,?-?-?-?,@,?-?,@,?-?,@,?,@,@+@,@+A*C.>.>.B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*",
"B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*;48448484866939393939393939393939393939393939393939393939393939393939393939393939393939",
"4591<0<2:<(A+@,C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)C)@-;4773;0=.>-0-/",
",.1.*-4-*-5-),6-),7,(-7,(,8,,(8,@,@,?-?->-?->->.=.=.=.=.=.=.=.=.</</</<.=/</<.=.>->->-?->D(D(D E E4-<37,*-4*/,2)1./)3.-)4",
".-(5/,(50*(60*#62)#62((62((62((53((53((44((44)#35)(16)(16*#07*#065747575657574747574757474847565747574756575747475E50<095",
"491<.>.?,@,@,/,1,/,1,+10+*4/+(6.>.>-?->-?-?,@,?-?,?,@,?,?+A*A+A+@+A*A*A*B*@+@+@+ 23<0<0?,@+@+A*B)B(/2/()>(:(B.;4583:1;04 ",
"./1-+.1/*/.1*/,3*B*B*B*B*A+@+A*A*A*A+@*A*A*B)B)B)B)B)B*B)B*B)B)C)B)C(C)B)C)B)B)C(C(D(B66@-)N-=186591;0=.?,A*B*B)C)C)C)C)/",
"(8)-+7*+-6**.6665665756574748483838384,)/4++-5++,6)-,@+A+A*B)C(D E $, E)B?-@+B)/)C.>1;4775))33),21*.00--//0+..4*.,5*-.5)-",
"20*,4/),6.),6-),6-),7,),7,),7,),7,),7,),7,),7,(,8+),7,)+8+),8+)+8+)+8+),8+)+8+)+8+)+8+)+8+**)-/**5.+)6-**7,**8+**9*+:))+;",
")(e E E(D2,>0:55,*.3*/.0*1-/+2-.*3.-*3.-*+(,* ),+,(+)))+++)+))),+*)+))),,(+)+ *,2*0-1*)(+./*)*)1++)+);)+):+)):1;()+;)**:*",
")*:,();0;0;0;0;/=.=.=.>->-?,@,?,7),+3.+,-4++)9+A*B*C(D(D*B:24-;46,+( *3( (.(()1#()/(()/#()1#))-(((2((*,#()3#))+(()3#)**#)",
")3())*#))3()*)#))3()*)#))3()*)((*2()*)())2()**#**0#***(*-,#*),(-)+()*-*(*,()*0*/#*)=()*=#)*=())>#))>((*=(()>(()?#()?( )@#",
" )@# (A*A*A*A*B)B)8#/(:#.(:(-):(-(9)-?,@+@,(;)+(<)*)<(+AE)C)A+>/</<0:1:- *9,)):+*)9+*)9*+*8*,*8),*9(-*:#,)B)B)B)C)C(B)C(C",
"(D(C(C)B)B*B)C(C(D(C(C*A->01*,10,*5-,)7,,)7,,(. 1)-(,)2(- +/5(+04)*40*)C)N-=195682--- #.,**), #-+)))) , #+,((-( , #*, (0#",
" +(#(,(#1# , #(,(#3, ( ,(#2-(# - #3,(# - #3,(#(,(#2,(#(-(#)#-,(#(4 #+,(#)2(#*-(#*1 #+,)#,-)#*-(#+#(+/,)#,#.(*-((-(*)*-)#0",
"++-)#:-)#:-)#9-)(9-)(8-*#9-*(8-)(9,)(:+*#;+)(<*)#=*((=*(#8#,* #9#+* (8(+* #8)**(#5,*B)C)C)C(DKC4,>/;3856-)-5+-,3+/,2*1+1*",
"3*1*3*1*3*1*4)1*4)C)C)C)B*B*B*A*B*B*A*A+A*B*A*A*A+A*A*A+@+A*A*A*A+@+A*A*A+@+@+A*A+A<1;1;9,>/<28**.5).,4(2+3(2+2(4+1(5*0(6",
"+/(6+/#7+A+A+A+A+A*B*A+A*A+A*A+A*A*B*A)C)B)B)B)B)C)B)C(C(C(4#5#5#4(5#3(6#2(6(2#7(1;1;0</=/=.>6-<38)-,4*0+2*2+1)4+/*4,-*6,",
",*6,,*6,,*6,,*6,,+5,,+5,,,4,-+4,--)(-,.0.,/-0,?,@+@+@+A*A*A+@+@*B)B(C(C(C(C(C(C(C(C(D#C>.>->-?-?,@D(D(D#9+@-=1:39**+8+*,7",
"*,+6+,,5+,,4,,,4,,,4,,,4,,,4,,,4/),5.),5-*,6,*,6,),9)*,@,@+@,@+A+@,@+@+@,@+@,@+@+A+@+A+A*.#8+-)7*.)7*-*6*.*6*-+6*,+666657",
"57666393681=/1)0/-/..,1-.+3--*5,-)6--(6--(6--(6--(6-.#6-.#6-?-?-?,?-?,?-?->->-?,?->-?,?->,@+@+A+@+@+5#1+5#0+5(/+5)-,5)-,1",
".-?,?,@+A)B)CD(6-=195675. .6++-6)-,7#/+A+B*B*B*B*A+A+A+@,@,@,?,@,?-?,?-?,@+A+@+A+@,@+@,@+@,@+@,@+@,@,?,@,?-?,?-?,?9392:;+",
"A+?.=()+;(*+;(*,:#+,9(+,9#,-8#,-8#,-6),-6),-6),-6. -6. -6684848, -9+ -:(),@,@+A+A+A*B)B*B)B)B)C(C(.#:(/#:(/#:(/#9(0#9(0#8",
"(1#8(1#8#2#6)2#666666666691;18*)/5)..1*0/.*10-*2/,,10+./0*0/0)0/0)1.0)1.0)1.0)1.0)1.0)1-1*0-1+..0-+00;0</<0<.>.=.=.>->,?,",
"?,?+@+@+5(/*6).*7).*7)-*7*,)8++A*B)C(C E E E E E9/=/;))-7(-.4).-2*/.1*/.0,/-0,/-/-/-/..-./.-./.-./-../-../-../-...-//--.2",
"*-.>.>->->-?->->->,?,?,?+@+?+A+1(3*3(2)5(2)5(0*5(0*5)0(6*/<.>-?,@+A+A+A+@52:28*)/4)0-1)2-/)4--*5-,+4-*.3.)/3-)/3.(/3.(/3.",
"(/3.(/3.(/2/*,3/,(5/=/=/</=/</=/=/</=->-=.=.=->->->+@+4)/+5)/+5).*7)-*8),*9)+):)+):**B(D(D(D(D(D/3957667575,,+5,,+5,,+5,,",
"+5,,+A+A+A+A+A+A+A+A+A+A+A+A+:2847474829,@,@,@,@,@,@,@,@,@,@,@,,+5,,+5,,+5,,+5,,+5,,+57575757:.=0;***9+**9+*+7,*+7,*+7,*+",
"7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+A+A+A+A+A+@,?,<,?+@+A*A+A+*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7",
",*+7,*+7,*+75B/=/;3765757492:11(.11(.1.,-0..,/./,/./,/-/-/-/-1*0,2*0,3(0-?->-?->.>->.>.=.=.>.>.=.=.=.>.1/).1:1:2:1:1?)0*B",
"*$3(D(6 1,3).1/01883:1<0=.>.?-?-/*2-,0/-+3-.*3-.*4,/(5,?-?,@,?,@,?,?-?,?->-?,?->->-?->->->-?->->->.>->->.>->.>@+A+A+A+@,>",
"/::0<0;2:***:***:***:***:***:***:***:***:***:***B*B*B*A+A+A*B*A+A+A*A+A+A+A*A+A+A+A*A+A+A+A*A+A+A+A*A+A+A*A+A+A+A*B2:29)(",
".9)(.6,(03-(2//(3..*3,/+3*1+3)2*3)3)4 4)4 4)4(3)4(3)4(2*4)1*4*/+4+,-483848393838393838291:0:/<.=->,?)=(*#>)/-3),6,*+A*B)C",
"(D(C(D(C)B*+)9+)/4;.:.>)()=*(*<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)C)C)B*B*B*B)C)B*B)C)B)C)B)C)B*B)C)B*B)B*B*B",
"*B*B)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<0=,=286592;0=./-/--1-,-3-+,4-*-5,*,6,*,6,.(6,@,@,?,?-=.;092:0;39576>/?.?-@-@,@,@,",
"A+A++(:+ -8, -8,(,8,(-6-(-6-)-4-*.1.,/./->/<1:37736<0<B)A*A)B)A*A)B)A*@.=2;#)/=0<1;2:3948485757666)(16)(16((26((26 (36 (3",
"938484848484936 (35((35()25)(24*(23,(12.(02.)/10).02*,/5**.72@,>093856757484)0+4#2+A*B*B)C)C(C(C(C)C(B(C)B-=2:2<1=0>/>.?-",
"@,@,@,@,@,@,@,@+A*A*A+@+A)B*@*A*A*?*A)A*K(.,/=*B(D(=))+7,),3/)2,0)B)B(C)B)B)B)B)B)C(C(C(D(C)B-=3867585>/@-B*C)C)D)C)C)C)C",
")B*B)C)C)B)B*B*A)6).*8(-*:(*)?+?.;4683:1</>.?-?-?-?-+)7.(,67575757484747474692;0>.>.?-@-?-?48576666757575666656)+-7(C(D(C",
")B*B+?.=1:455*B1;4784:2*(60*.1/,0/-1,/,4*.,5*-.5(.3/)-5-)-7+)-7+(-8+(-7+)-6+)-5-),3.*,10)-2.*,4,+.3(/01/+//1+..3*.5-).6,(",
".6,(.7+)-7+)-6,)-6,(.3/(./3(.(9(.)7).*5*/*3+/+/-0,*.2.*+30;275480=+B=/@,A+A+B+@,6),-0.,.+2,@,?,?,?,?,?,?,?-?,)(:. )9294<1",
">/>.((<0<.?-?-?-?-+(8-+(8-+)7-(,7650 #(*4. #*,1..,/./=0;0;/* 80()770(*7)/(8)C)>=.>.=/#9(/(8(0#9(/( 90*5(1(6(1(6(2(6#3#6(C",
"(C(C(D#D#D(D#D#D(C/<)),9(-# *7#/#()6#/(()@#))?(()?())>())?#*)>#*)-)4#*)+) )2#*)+#*(2#*)*(*)1#*)*(*)1#*)*(*)1#*)*(*)0(*)+#",
"*)0()),()(1()),()(1#)).(((1#))/( (0(()1( (/#()3( #.#()5*,+91@,.)34 *391;0;0:1:4(--6#.,?+?+A+@+@+((<666582;1;1.(#(.0-.-/*3",
"+1)2,@+A*B*@+@+@*A+>+A+>,?,?+?,?,>+@+@,?.>.<.>.=-?-?+B*P565753-*01-*0/,//.,//,,1/,,1/*.3-*.3-*,3/*,3/*,3.+,3.+,,)(.-,,)(.",
"-.()*,/.()*,10 .30 .=3937+*.5+*.5+*.3*/-2*/-?-?-?-?-?-?-=/=75759393730 .30 .10).10+.-./.-.3575>-=19*).5).-3)0-1)2,0*2,0)3",
"-.*4,.*4,.+3,.+3,.+2,0,)(+,1/,+3-,+A*A*A*A)B)B-=38),,5*.,3*0,1*1-1(3,@-?-@,@,@,@,@,@,?-?,@,++6+,+6++-4+,-4*.,3*/-1*1-/)5-",
"**91B+?.<)),9),+7(/*7(/*6(1*5#2*B*B*A*B*A*A)B*A)B)B(B/<2947)-,5)/,4#2+B+A+B*B*B*C)C)C)C)C)C)B*B*B)B)C)B)C(6)0(6*/(7+-)7,+",
")9+(*<.D-=19*).5).-3)0-1)2,0*2,0)3-.*4,.*4,.+3,.+3,.+2,0,)(+,1/,+3-,+A*A*A*A)B)B-=38),,5*.,3*0,1*1-1(3,@-?-@,@,@,@,@,@,?-",
"?,@,++6+,+6++-4+,-4*.,3*/-1*1-/)5-**91?)C38575748+*+8)++8*++8)++9)++:#,*A+@+A+@+A+@+A,?/=0<0;2:* .?-@,@-?-?-@,@,7*+,6,*,5",
"-*,5-*,5,+,4,,,4,,,4,,,4,+-4,+-4,+,6++,6++,6+*,8+(-83:1=-:#E#E<0=/=.=/;1*0,2#3,1(2+3#2+4#1+?,?.=2:38575592;;1<1=0=/>.?-@,",
"@,@,@,@,@,,#9,,#9,+(9,+(9,*)9,)*9,)*8,)+7-(,6-)-4-)/2-*1/-,2*//<3772=/;385675.(.4,,,5*-,6).+A+A+B*B*B*A+A+A+A+@,>-</91:3>",
"/?.?-@-@,A+A+A+A+A+B*B*B*B*B*A+A+A+6(.,5).,4+,-3.)-575674:1?+A+@((*=(**;(+*;#,+:#,+9(,+9+),8,(,8,(,8,(,8,(,9+(,9+(,:))+A+",
"A+A*B*A*B)=.?/=/B+B*B+A+A,@,@,9*),8+),8,(,6.(,6.(,6.(,6.(,6.(,6-),6) (*,8#-+9#-+:#,+:#,*<#**>-;3937+*.3+..0+0..,0/--/0+//",
"/+//0*0.0*0.0+/.0+/.0+./0,-/0-*10</<0</<.4**.55767+)/5+)/@.?/=0<0=0<0,(41),21(.1<0<0<0<0<0<0;10 /11),20*+3/,*2/.*0/1+*063",
"@1;19+).5).-2+..0,../-../.,/./,/./,/./,/./+0./+0..,0/-,02#/0;0</</<.5482:5@-?-@.>.>/=/=0;1,+01*./1)0.1(1-2(1-1)1-1)1-1)1-",
"1)0-1*/.0+./0+,00-*1//)1-1*/-4+).81?2:27++-4*/-1*1-0+0..-0-../.-./.-./.-./.-./.-./..,0.>.=.>.>->-=-648,**8*.*C+A+B+A-@,@-",
"?-?.>.>.**6.),5. /4. /4. /4. /4. /3/ /3.(.4.*+5-+*5--*3-/*1-2+*/6383957667575-++5-++5-++5-++5-++A+A+A+A+A+A+A+A+A+A+A+A+;",
"1;1;1;1;1A+A+A+A+A+A+A+A+A+A+A+5,,+5-++5-++5-++5-++5-++5757566586666-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-",
"*+6-*+A+A+A*B*B)=-?-E)C*B+A+A+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+7,*+7,*+8+*+8+**:1C/=/;3765757492:0",
"1*-01*-/0-,/./,/-/-/-/-0+0-3#0->.>.;0574757375757575875>.>.?-?-*-4-*-4-*-3.*-2/*.0/+.0/+./0+0*2,@,@.=/<18485591B2773:1;1;",
"0<0</=/2)-0-/,1)1,?,@+@,?,@+@+A*A+@+A*A*A*A+A+@0<2:58595:2=/@,A+@,?-=/<0:1:1:192828373837392B0<0;2:***:***:***:***:***:**",
"*:***:***:***B*B*B*?,@,C*B*B*:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***",
":***:***:***:2;0A#E#?)(.7+(12-(20.)3---2+.-3*/-2)1,3(2+3(2+3(2+3(2+3(2+3)0,3)/-3*-.3-(02:292926482:2:3:4<1;3:2:3+)13)-/3(",
"0-3 1-3 2,@,@,@,@,3 1-3 1-3(/-3).-3+0)3-/(30-(15*(.;.>)()=*(*<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)C)C)C)C)C)C)",
"B*B)?,D)C*C)C)C)C)C)C)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*<*(*=.I*A+@,?->.>.=/<0;1;1:2:2938- ,7-(,7-(",
",6-),5-*,4-+,4-+,3-,,3-,,2--,1-.,0-/,0-/,/-0,.-1,--2,--2,,-3,+$$6;,@,@,@,@,@,@,@,@,@,@,E#E#D(C)C)B*B*A+@,?-?->.>.=/<0;1;1",
":2:28484757566664) 44((43)(43()42(*42(*40)+40(,4/),4/(-4.(.4.(.4,)/4,(04+g34848484848484=#D(D#D(C),#<(+)<(**:)*+:(++9)++9",
")++8)+,8)+,8(,,6)-,6)-,5).,5).,5).,4)/,4).-3)/,3*/,3*/,3*/,2>.>.>0<39<,@+A+A+A+A+A+A+@,@,@+A+A+A+A+A+A+@,=#D)B,@-?->-?-?,",
"?,@+@+A+@+@+*#<+*(;+*):*+)9++)9*,)9*+*8*,*8)-*7*-*7*-5,@+=/93+.*6(0*B*B*B*B*B*B*B*B)C)D(D#E#E#E#E(D(D(D(D#N(B,>/<0;1;1:28",
"484756666574839392:2:1,(30,)3/,*2/,+2/,+2.,,2.+-2-,-2,--2,,.2+,/2+.,6(D E E E E E E E E(D6484848484848484=#D*B,?.=/=/<* +",
"<))*;*)*;)**:***:)+*9*(#(*9)(((*8))((*7*()(*7*()(*6*(*(*5*(+(*5*(+(*4*)+(*4*(,(*3*(-(*2*)-(*2*() *(*1*(* *(*1*()(*(*0*(*(",
"*(*/*)))*(*/*(*)*(*.*))**(*-+(2(/(*(3(/ +(3(/ *(4(3@( )@( )@( :(/ :(/(9(/7*(*<*(*<*(*<*(*<0<0<06#E+A*A+A+A+@+A+A+)+8,)+8,",
"(-7+*+7,+*7,@,?-?-/*2-/*1-0*3++())4+)*))1#(+)*))1.*)))1-+)))3++)))4*+)))0C(D)C+A ((=+>-; )/8()3++*()=*()=*()=*()=*()=*()=",
"*((>*B*B*B*B*B*B*N*B*4+/*3,.+2--,1.-,0-.,1,/,0,/-/,0,/-/-.-0,..0,.-1+/,2+.,2,.,2,--2,,-2-,-2,,-2-,-2,,-3,,-1$} 5(,@+@,@,@",
",?-?-?,?-?-?->-?-?-?-?-?,@,A*K#D)B*B*@+A+@+A+A+@,>-?->.=/<* +<)(*<))*<))*;)**:)+*9),)9)-)0#.)-)/(,*.)-*++.)-**-,*-*)2().)",
")4 ++*)B(C)B*@<*B*B*B*A*B*B*B*B*A+A+A+A*A*B)C(B-?-?-?- #=,(#=,?- #=,(#=,(#=,?,(#*#8,(#*# #6, #*( #6+(#(* #5,(#(* #5+(#(+ ",
"#5+(#(+ #5*,+ #4+(#)+ #4*(#*+ #4*(#*+ #3+(#*+ #3*(#++ #2*(#,+ #2))#,+ #1*(#-+ #1)((-+ #0*(#.+ #0)(#/+ #/))#/+ #/)(#0+ #.A",
"*C)D #8+*):+)*)< # *:+ #((;+ #,#8+ #*(9+ #?+ #>, #=. #;0 #F#F#84<*A+A+@,@,?-?->.=* *=* *<*(*<*(*;*)*;*)*:***:***9*+*9*+*8",
"*,*8*,*7*-*7*-*6*.*5+.*5*/*4+/*4*0*3+0*3*1*2+1*2*2*1+2*1*3*1A,@,@,@<*B*B*B*B*B*B*B*B*B*B*G(D(C(D#D(C(D(C(C(D(C(D(C(C(D(C(",
"D#+)<(**;(+*;(+*:(,*:#-*9(-*8(.*8(.*7(/*7#0*6(0*5(1*5#2*4(2*4#3*3(3*3=.>=+B*B*B*B*B*B*B*B*B*B*A+>27#D)B,@-?->-?-?,?,@+@+A",
"+@+@+*#<+*(;+*):*+)9++)9*,)9*+*8*,*8)-*7*-*7*-5,@+=/93+.*6(0*B*B*B*B*B*B*B*B)C)D(D#E#E#E#E(D(D(D(D#G)B+A+@,@,?-?-?->.>.>.",
"=/=/=/<* +<* +<* +;*(+;*(+:+(+:*)+:*)+9+)+9**+9**+8+*+8*++8*++7+++7*,+6+,+6+,+6*-+6*-+693939>+A+A+A+A+A+A+A+@.<1</?#D(C)B",
"*A+?-?-,#8-+(8-+(8,+)8,+)8++*8+**9+(,9+(,9*),8+),8**,8**,7*+,6*,,6*,,5*-,5*-,4+-,4*.,3*/,3*/,2*0,1*1,1)2,0*2,-# +2,** $O6",
",,(8,@,@,@,@,@,?.>.>.=0B#C)C)B*B*A+A+@,?-?->.>.=/=/<+ *<+ *<*(*<))*;*)*;*)*:***:***9*+*9*+*8*,*7+,*7+,*6,,*6,,*6+-*5,-*5+",
".*5:3939?*B*B*B*B*B*B*B*B*B*B*B*B*@)C)B*B*B*A+A+A+@,@,@,@,@,?-?-?->.>( +>( +=) +=((+=((+=((+<()+<()+<()+<()+;(*+;(*+;(*+9",
")++9)++9)++97=+A+A+A+A+A+A+A+A+A+A+A+A+?/C.>.=/<0;1;1:2939( 08) 07)(07()07()06))05)*05(+04)+03),02)-02)-01).00)/00)/0/)00",
"/)00.)10.(20-)20,)30,(40+$$V70<0<0<0<0<0<0<0<0<06;@,@,?->.=/<0;1:2929) /8)(/8((08((07()/7(*/6(+/5(+04)+/4),/3)-/2)-01)./1",
")//0)0/0)0//)00.)1/.)2/-*2/-)20,E D(D E E D(D8/<0</=/=/<0</=/=/<06;>*B*A+A+@,>.>.=/=/<0;1;1:2:29) /8* /8)(/8)(/7))/7))/6)",
"*/5**/5)+/4),/4),/3)-/2)./2)./1)//1)//0)0/.*1/.$N5/=/=/=/=/=/=/=/=/=/=/7:;,@,@,@,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,",
"4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4:394866>,@,@,@,@,@,@,@,@,@,@,@,@,@,@,:(++9)++8*++8*++7+++7++",
"+6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6666A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+=/=/",
"=.>.=.>.>.>-,+3.,+3.+,3.+,3-+-2.+,3-+-2.+,3.+,3-+-2.+,3,,-2-,,3-,,3,,-2-,,2-,-2-,-2-,,2-,-1A*B*B(C E D(D(D(.-4)--.2*..>.>",
".=.>.=.>.>.>.=.?-A)A,?,?->.>-?->-@,@,?,@,@,?--)5-,,2--,2-,-2,--2,--1--,2,.,2,.+3+/+2,/+2,/+2,/+2+0+2+/,2,.+30)1.>.=/<0:46",
"8,(+A+A+A+A*B*A+A+A*B*B*B*B*=***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:",
"***:***:***:***:***:***:***:2;1B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*B*D-?->.>.=/<0;1;1;1:2:2:2:2:27#(26((25)(25)(25)(24*(23+(23*",
")23)*22)+21*+21),20)-2/*-2.+-2.*.2-*/2,+/2,*02,*02+3(D(D(D(752:2:2:2:2:2783:2:398(D(D(C)C)C)C)B*B*B*B*A+A+A+A+@( )@( )@( ",
")@( )?(()?(()?(()>)()>())>())>())=)))=(*)=(*)=(*)<)*)<(+)<393@)C)C)C)C)C)C)C)C)C)C)C)C)C)9=/=/=/=.>.>.,@,@,?-?,@,@,@,?-?,",
"@,,+5,)12, 5/>.?-@,0./+.2.).4--(7-@,@,@,A+A+A+A+A+@, ,9, -8,(,8,(,7-(-5-*-4-*.1.,/-/->/<1:47738:2:2(D(D#D(D(D(C(D(D((0784",
"+,/2).01).11#/2:3939485757666)(16)(16((26((26 (36 (3938484848484936 (35((35()25)(24*(23,(12.(02.)/10).02*,/5**.72E.575757",
"47575660;(D(D(C)C)C(D(D(D)B.>0<3857685;2=0<0?-?-@,@,A+A+A+A*A*A+A*A*A*A*B)A)B)B*A)@*A*A)C(B+@/=3:B)C)B)B*>//>,@,@+A+A+A+A",
"+A+A+A+A-?1<48667A,B*C*C)D(D)D)C)C)C)C)B*A*A*B)B*A*A*5#1*6(.+7)+,83:/A=.?-?,@,@+A+A*B*B*B*A*A+@,0;0<0<3884;1>.?-A*C)D(E E",
"(E E*B.>1;2:394848484847)(/8(,*9)B*B*A+@,>/<1946K-+A+A+A*B*B*,8**,8**,8**,(:*,(:*+):*+(*(5*+(*;+(*:,(-7,(13+)40+)5/+-4,+1",
"0,1-/*6+.)8*.(9).(9*-.4)-20)-4.)-5-)-5-)-5-)-5,).4-)-3.)./1).,4*-)5+.+2+/,/-/---0.*,20+(419466390<-A+A67:2<3:2,,//.0,-/1,",
"-.2*1+3(2+3#0.>-?-B*A+@,@,@,@+)/5+ 24:2;2;1+,13(+23(+) /8)).9(*.>.?-=/;1;5;1(#856. ,7. +0)+-)*0*).)**(+)(.+*)(+3+/,1-.,0/",
"<195591;#E).*74839# ,)#9(/#:(-):0<-?#E#D(D(D(D(D(D#D(D(D(D(D()/8# **,6)/+4)1# )3(2#()2#4#()@#))?#))?#*)>())>())-+2(*(,(()",
"1(*(,#*)0(*(+(*)0(*(+(*)0(*(+(*)0())+(*)0()),#))1#*),(()1#)).#()1#)).(((1#()0( )/#()2( (/# )4*.# )6*,+91@*1(5748392938475",
".>,@,@,?,@,@+A294856666757*+,@+A+@+A+A*@*B*A*B)A*A*A*B*@+@*A*A+@*A*A->.=->.>-?,@+A*Z)C)C*D( #B( #,> #,=(#,=(#,;)#-8+#.)8(",
"/)(61)(#@)(#@)(#@)(#@)(#@)(# 05)(43) 71-.-0,0-/+)-(, #-*((,((, #-#)#1# , #/#4,@- #=- #>, #>,@,@,.#)#3,,)(#4,*+(#3-(-(#3- ",
".(#3,(# ,)#2,(# -(#1-(# -(#1,(#*,((.,((*-)#,,)#--,-)#/8)#15*#6.+(4#3)7),*5:1;1;1;1*B*B*B*B*B*B*B*B*B)C)C)C)C),,7))15) 53:",
"2--,2,0+1+2*4#3+B*B+B*B*B*B*B*B*B*B*B*B*B*.*5*/+4*/+3+0+2*1,0+2,-,385674:0H)>.847484739.>(D#D(D#E#E#D(D#E*B1:486:3>/@-@,A",
",A+B*B*C)C)C)C)C)C)C)C)B*B)C)B)B)C(C)B)B(B)A*?+=,T#2(6(2*3)2,/*393847566482:(D(D(D(D#E#E#E#E#E#,/6#*34#(+).2( )/,1( (1,0*",
"2-/)4,/)4-.)5,.)5,.)5,/#6,@,@,@,@,@,@,@,?,.#7,,*6+,,4,,,4+-,3+/,2*1,/+3,-*64H#D(:2:2:2:2939*B*B*B*B*B*B*B)B*B*(*<2:394848",
"*(/7(,-?-@-?-?-?-?-@,7*+,6++,5-*,5-*,5+,,4,,,4+-,4+-,4+-,4+,-4+,-5++,6++,6+*,8+(-92:1=-8(D(D;2:2:2:2:2:2)4)2)5#3)5#3)B*B)",
"C)C669393;0=/>.?,.*5+)41<1=/>.>.?-?-@,@,@,@,+(9,+(8-*(9-))9-)*7.(+7-)+6-),5-).2.*/0.+3)0.=2863<57575747,@+A+A+A+A+A+A+@,@",
"+A+A+A+A+A+@2:485766+)/5(.-A,A,@,A+A+A+A+B*B*B*B*B*A+A+A+@,@,?,5)--4. .475683G(D(83939393939(D(D#E#E#E#E#E#E#**=#(-<# ()*",
"9) #+*8+++7*,+7*,+7)-,6)-,6)-,6)-,6)-,@,@,@,@,@,@,8**,6-),6-),6-),6-),6-),6-),6-),6,*+7,*+9#-+9(,*;#,)=()*>,O(D(-)8*-/-..",
">.=/<0;1938366)C)C)C)C)C)C)C)C(+14()61( ,)1/,.0.*10-)30<0<1;1;2;1;1+*21).01).01(/0=/=/=/=/=/0 2.1 1/0*-1/+,1/-+1./*0.2+*/",
"63P#E#1)5)1.+.0;1:29384755738(D#E#E#D(D(D(D(C))06((35( *(/4*-.2*/.1)0.>/=/=/=/=/=//)1/--.0--.0,..0+/./,/./+0-/,0-/,0-.-0,",
"../-..-../+/.1*/-3).,6*).90=)6*/)6*/.--0</<0:28448(D(D(D(D(D(D(D(D#E#*25#(*)/3*0-0*2-/)4-.(6-?.>.>.?-?.>.>.>.>.>.>.++4.*-",
"3.*-3.(/3.(/3-)/2.)/2-*.3-*-4,-*4-.)3-0)1,3+*/7296666666666,++6,++6,++6,++6,++6,@,@,@,@,@,@,@,@,@,@,@,@2:4857666A+A+A+A+A",
"+A+A+A+A+A+A+6,++6,++6,++6,++6,++6,++757583:186666,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@,@666A+A+A+A+A+6,++6,++6,++6,++6,",
"++6,++6,++6,++6,++6,++6,++6,++6,++6,++7+++7+++8*+*9*+*:1=9392:2:2:1:2:1;1;1/=.=-?-?->57577492;1;0<0=.2*..2*../.-.-1,.-1,.",
"-1,/+1-?-?-?->->.>./)1.,-.1,-.1,--1-.)3.=/=/<29375763;/@</=.>->.>->.=.;139/</=.>.>-?-?-?,@,@-?-@-?/>/>/>0=0>0=0>0=0>/>0>.",
"?.?-@,A,?->.<08456.>->-=0:3781?2:2:2:*B*B*B*B0<1;***:***:***B*B*B*B*B*B*B*B*:***:***:***:***:***:***:***:***:***:***:***:",
"***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:2;04-7)+-7)+@,@,?-?->.>.=/</;1:36;,;(C*B*B*B**((-3*(*(/10(1/0",
"(2.0(3-/*3,,.3+*12:3939484+*/4).-4(0,4(1+4 2+4 2+4 2+3(2+3(2+3(1,2)1,2*/-1+/,2,0(3/.(12-(06*(-@#A/=(D(D(D(D(D(D(D(D(D(D(D",
"(D(D/=()+B*C)C)C)C)C)C)C)C)C)C)C)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*=)()>.A,<377492;",
"0=./-/,.1-,-3-*-4-*,6,)-6-(,8,(,?,@,@,@,-/0,*4-,*7+,)9*,(;), .*1(20.(03. /5- .74939392;1;+ +;+ +;+ ,:+ ,9,(+9,(,8,(,7-),6",
",*-4-+-1.,/./->/<1:4683=,=28,+*6--)4./(2/0(000).11(-2:2:293938484757575*,-5(0+8.()80((72( 63( 63948484857575# 55# 55# 55#",
" 54((44((44((44()33(*33(+23(+22(,21(.11(/0/)1/.)3.-)5-)+92F(C)B)C(C(C(C)C(B(C)B*B)B)B)B*B)B*A*B*A*A+A*B*+,6+*/3,)21,)21,(",
"4/,(6.,1---3+--4*--4*--5)--5)--5)-.4)-.4)-.4)-.4).-4(//1(1//)1/.)30+*466583;0D)B,@,?-?+@+A+@+@,@+@+A+@+@+@+A+@+A+@+A+A*B*",
"B*A*B*B)C)-+7),.5)+13)*41))60))60))+ 00)(+)/0))(,.0)2-0)2-/*2-/*2-.+2-/+1,1+0,1,.,2--,38566590?*A,@.=0;294757474757474748",
"4757484 ..?-A+B)C)D(D($<)C)B+A+A+A,2 4+2 4+2 4+2 5)3(4)3(C*B*A+A,?.=0;1:4764:0D#D(B+@->.=0;1:-(*8-)*8,),6,)-5,(.5,)-6+)-6",
"+),8*),8+(-7+(-8*)/5+(32+(50*/1-+2/,+4.+*)---)+(2*,)+(3*,(+(,(,*+(+(,*+)2(,++)0),++)0)+-+(0)+-+(0)+-+(0)+-+(0),,+(+ +(,,*",
")+ +(,++(, +),)+)+)**3(,)+)2),)+*0),++5,-,2,.-./0:3773E#C*@,?.=/<19385666473829291;0;0</</=.=.>-?->-.,1-+2.,+4-,*6+,*8*,*",
"*,/),)*/-)+*)0.(+*)1-(+*)+#+-(+*)+(+,(+**))+,(+*+ *+,)**0+,)*+/+,)++-,,**,+,-**7-*+5-,+4--+1..,/.0;385591G#A+>+@(B)B)B)B*",
"A*A*A( (@( )?) (@( )?(()?(()>(()?(()>())>())>())>#)*).3#)* *),/(),.+.()+0# )-()*1( ),())3#()+())3(()*())3(()*())3()))())4",
"#)))())4#))*#))4#*(*()(4#*(*()(4#*(*())3#*(+#))3#*(+(()2()),#)(2()),(((2())-#((2(().(((1#))/( (0(()1*0#))1+.(()3+-# )7**,",
"91D(C)B*@,@,@,?-?,?,@,@,@,?,@+@,@,@+A+@+A+B*A*B)B*B*B*A)C)B*B*A)..3),11*(60*(602)-0/.+/-1+.,2+/+3+/*3*0+2*1+1*2+/*4765749",
"0=-G+?/;467 #3+,- #1*/- #/*),(,(#-+((+( ,(#++(#0,)#*+(#0+*#)+(#1)+()+(#2#*(*,7),, #4(., #=,(#++3,(#(10,*3/,)+)---(*-,,- *",
"))),+- ))#)((+(#(- )(#+( , #(- ((#-#(+(# - ((#.# , # - (3,)- #(#0-(.*#2+(# ,)#3+(# , (4+(# , #5+(# ,7+(#(+(#4+(#(+(#3,(#(",
", #3,(#)+ #3,(#)+(#1,(#+*(#1,(#++(#0+)#,*)#.,(#.*)#,,((/+)#),)#1,)-)#34)#60)(6#2(8(.);/>,?.<2947+,+5*/+3*1*3*1+1*3*1*3*1)",
"B*B*B*B)B*B*B*B*+/3+)22+(41+ ,)-0//+/.1*/.1+.-3*.-3*.,5*-,5*-,5*-+7)-+7)-+7).*7).*7).*7)/*5*/*5*/*5*/+4)1*3*1+1+2*1*3,-+5",
"-)-6583;/J#C)A)B(B)C(C(B)B)C(C(C(C)B)C)B)C)B)C)B)C)C)+,7**.6*)(**5*)#,*4*1*2*3)2*3*1*3*1*3*1*3*1*3*1*4)1*4)2*3)2*3)2*3)2*",
"3)3)2*3)2*3*1*4)1)5)1)6)/)8).(9)-(;)+)=.A-<28**.5).-3)0,2*0-0*2,/*3,/*4*/+A*A+A+@,@,@,?,@,@,,/1,+2/,)**.-,()/,+- (2,*/4,)",
".5,).5-(-7,(-7,(-7,(-7,(-7,(-7,),7,),7,),7,),7,),7,*+7,*+7,++6+,+5,-*5+.+4*0*3*2*1*4*/*7+*+:/?+@.=0;+(+9+**9++*8*,*7+,*7+",
"++7+++6,)-6,*,6,*+7,,#9,@,@,@,@,?- +9485766.),5-++5-++5-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,4-+,5,+,5,+,5,+,5,+,5,+,5,+,5,++7++",
"+7+++8+)+93:1=-@393691;0/*.0..,/.0+.-2*.-4).-4(.-5(--6(--6(--6#--?-?->.,0..)4-. 8+6)/*3/.(12-(04- 04- /575675757584848, -",
"8, -8, -7- -7-(,7-(,7-),5.)-4-+-3-,-1-.-..0/(0285592@(C+A+@+A+A*A+A+@,@+A+A*A+A*A+A*A+A*A+A*B* ,:394856,,+5,,,4,,,4+.+3,.",
"+3,.+3,.+3,.+3+0*3+0*3+0*3+0*3+0*3,.+3,.+3,.+4+.+4,,,4,,,5+,+7, .7492;0?+A+@())=(,(;)-#;)+*9**+9**,8*)-6,)-6,)-6,*+7,*+7,",
"*+7,+)8,@,@,@,@,@,(+9, -8.)*7-**7-**7-**7-*+6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++8*++8*+*9*+*:)+);)+)<",
")))>,?2:28,*,5+.,1-.-/-./.--0-.-1+/-1+..0+///+//.,//.,/0,,03#.0<0:2:2)/.2 3,5)0*4+0)3-0(3-0(3-0(3.0 2/0 2/=/=/=/=/=/=/1(0",
"/1(0/1(0/1(0/1)//0*//0+./0+.//-../.--/0,-.2,,-5+)-91@1;19,),5+.,2+.-0--.0,-//--/.-./-../,/./,//.,//.+/0-,/3#.0<0;0<0(/0>.",
"3)/-2+/+2-.+1./*1./*1./*0.0)1.0)1.0)1.0)0.1)0.1)0.1)//1)/.1*/.1*/.1*/.1*./0+..1+..0,../.--//,..1+.-3+,-5+)-90B2:28-*+4+0+",
"1+2+/+2--,2--+2.,,2.,,2.+-2.+,3-,,3-+-4,+-?-=/=/=/+///))*,-/((-,,/ (/,+11,*02-)02-)02-)02.(/4-(/4. /4. /4. /4. /4. /4. /4",
".)-4.)-4.)-4.)-4.*,4-+-2.,,2--,2-.,1,0+0,2,-,5,*+91<2938475756,++6,++6,++6,++6,++6,@,@,@,@,@,@48576666,++6,++6,++6,++6,++",
"6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++667583:1<.=0;*+):*+*8++*8+++6,++6,++6,++6,++6",
",++6,++6,++6,++6,++6,++6,++6,@,@,@,@,@2:39,+)8,+*7,+*7,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++7+++",
"7++*9*+*9*+);0M)C)@-=/;1:2:292738382:291:191:1;0<0;0;/)0.0)2-0 5,0 5+0 7)0(7)0 8(0),).(0),).(.+++-(.56575757574. .30 /10(",
"/01(/01(//1)2(5)B,>.>/<0:4691J+@,>.>->->->->->.=.<.>.=.=/=.=.=.=/=.=.=.=.>0<1;29.(+7.)+6.),5.*+5-,,3--,2-.,1,/,1,0,1+0,1+",
"1,0,0,1+0-0,/-0-/,1-.,1.,-21(-394766749290<0;2:***:***:***:***:***:***:***:***:***:***:*B*B1;2:***:***:***:***:***:***:**",
"*:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:2;0>) ,<) ,9, .6- 02/(00/+/./,/",
"./,0,0+1+1*3*1*3)2*3)2*2)3*2)3+1)3+0)4-,+4-,+4848484)/,4(2*4(3)4(4(4(5 4+A+A+A+A+A+3 3+3 3+3 3+3 3+3(2+3(2+3)1+3)1+3*0+2+",
"0+2,/+1..+00/ 12. 05, .9* ,;.>)()=*(*<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)C)C)C)C)C)C)C/=*(*<)*)<)*)<)*)<)*)",
"<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*<*(*=.2E E E E E E?->->-?,?->-?,?->-?,?-?,?-?,?-?",
",?-?,?-?,@,?-?,?-?-?,@,?-?,@,?-?,@,@,@,?-?,@,@,@,@,@,8g:29392939383938484838484748483848475757475757475756575756666657566",
"66566666666656665757574757:#E,0*1;0</</=/<66C)B)C)B)B*B)C)C)B*B)B)C)B)C)C)B*B)B*B)B*B)C)C)B*A*B*B)B*B)C)B*B*A+A*A+A+A*B*A",
"*B*=)B+@1 8(E(D)C*A0#5+A)B)B*B)B)C)B)C(C)C)C(D(C(D(C)C(C)C)C(D#D(D(D#D(D(D(C(D(D(D(C)C(D#E#D(D(D#E#D(D#@(B+AA*D(D E E $L ",
"E E D(D(0/1).10)-2/++3/<0</=/<0</<0<0;1;0<0;1;0;1;0;1;1:2:292:2939293938483:2;1</22:$M E *07 *;+(*;+(= ,(<(+)<(+);(,);(+:",
"+(+:*(,9+(+:+(+:*(+:+(+:*)+9+(,9+(+9+)+9+(+:*)+9+(,9+(,8+)+9+(,8,(,8+(,8,(,8+)+9+(,8,(,8+)+8,(,8,(,7,(-7,(,8,(,74:2;1>-A+",
"C)7*B2::1C)D(D(C)= +)6-,(04,(*9,@,@,?-?,?-?-1(1./+0-0,../-..0,-/0,-.2*..=/=.=* *=* *<*(*<*()<*(*<*(*;*(+;*(*;+(*;*(+;*(+:",
"+(*;*)*:+(+:, +92:29392=/@,C)5C)C)B*#?()(>(*B*A+(<(+(=(+(<(,#<)+(<(,#<)B)C(C)B)B*B)B*A*B*A*A+A# (A+@( (A# )@#((@( )@#()?#",
"()@#()?#)(?(()?#))>#))?#))>#*)>#))>#*)>#*)=#**=#*)=(*)=#+)=#+)<0V(C*,-2.)C)C(c(D)B=.>.>->,@+A*A+A+@*A+A*A*B*A*B)C)C(B*B*B",
")C(C)C)B)C)C)B)C)B,@,?-?-?-?,@+A+A+@*B*@@,@,@,@,?(#*?(#*(:)(#*(:()#*((:(#+( #7)(#+( #6))#(( ( #6)(#(, #5))#(+(#4*(#*))#4*",
"(#>+ #,+4*(#>*(#?*(#>*A+(#>+(#=+(#>*)#=+(#=,(#=+(#=,(#=,(#=, #=- #=,(#=,(#<- #=- #=- #=- #<-(#<-(#<-(#<-(#<-(#;.(#;.(#;.(",
"#E#E#=/5>.>.>.>B*B*B*A*B*B*A*B*B*A*B*B*A*B*B*A*B*B*A*B*B*A*B*B*A*B*B*A*B*B*B*A*B*B)B*B*B)B*B*A*B*B*A*B*<>-?-?-?->.>/#9)C(",
"D(D(C(D(D(C(D(D(C(D(D(C(D(D#D(D(D(C(D(D(C(D(D#D(C)C(D(C)C)C(C(D(D(C(D(D(C(D(D#D(@#E#D(D(D(D)C>-?-?->.>.*8#.)9(.(:#/(9(/#:",
"#/(9(/(9#D(D(C(D(C)C)B)C)B*B)B*A+A*B*A+A+@+A+@,@+@,@,@,?,@,?-?,@,@,A+@)C4856666657+-)6*/)6)0(6*/)6)0)7(/*B)C)B*B*A*B*B*A+",
"A+A*A+A+A+@,@+A+@,@,@,@,?-?,@,@,?-?-?-?-?-?->.>.>.>.>.>-8#@()#@()C(D(D(D E ,;* (?,?-?,?+A+@+@,@+@+A+@,?,?-?,?->->.>->->.>",
"->.=.>.=.>.>.=/=.>.=/=.=/=/=/=/=/</=/=/<8483939@,@,@+A+@+A+A+@,@+A+@,@+A+@+A+A+@+A+A+@,@,@,@+A+A+@+A+A+@+A+A+@+A+A+@+A+@+",
"A+A+@,@,@,@,@+B666666666666(2(6(2(6(2#7(2#7(2#7(1(7(1(7(1#D(D(D#D(D(C(D(D(D(C(D(C)B*B)B*B*B*A+A+@,@,?-?-?-?-?-?-?->.?-?-?",
",@,A*9A+A+A+A+A+A+@,@*B*A+,9(++9)++9)+*:(,*9),*9),)9)-)9)B*A+A*A+@,?,@,@,?-=/</=/<0;1;1:1:2:2:293938483938484848484846A+A",
"+A+A*A+A+@+A+@,+7),*9),)9)-)9)-)8*,)9)-)8*-(8*-)7*B*A*A+@+@,?,@,?->->.=.=/=.=/</<0;0<0<0;1:1;1:1;1:2:1:2:292:2>@,@+A+A+A+",
"@,@,*9)**;(+*:)+);)+);(,);(,):)C(C)C)B)C)B)C)B*B)B*B*A+A*A+A+?-?,?-?-?->-?-?->.>.>.=/=/=.>.=/=/=/=/:3957667575,,+5,,+5,,+",
"5,,+5,,+5,,+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+A+6666A+A+A+A+A+@,@+@,@,@,@+@,@,@,?,@",
",@,@+@,@,@+A+@,@,@,@,@,@+@,@,@+@,@,@,@+@,@,@+@,@,@+A+@,@,@+A+A)C)A,@@+A+A+A*A*A+@+1+1)00.*00.*00-+.1.+.0.,-1..*0.0*0.>.=.",
">.=.>.>.=.=/=.=/=.>.=/=.<0<.=/=/=.=/</=/</=/=/</=/>-@+@,@/=2:48676685886;2?-@,A+A+@,@,?-?-?-?-?-?-?-?,?-?,?-?-?,@,?,@,?,@",
",@,@+@,@,@+A+@,@,@,?,@,@,@+A+?0<0<0B*A+A+A+A+A+A+A*B*A+A+A+A+A+A*B*A+A+A+A+A+A+A*B*A+A+A+A+A+A*B*A+A+A+A+A+A+A*B*A+A+A+A+",
"A+A*B.>.6))3,)*)(=*B*B*A*B*B*A+@,@,*)8-).3,*3-.*9),*7*A*A+A+@+@,?->-?->.=/=/<0;0;1;1:3939384848485757575748493:1;0>->0<)+",
"(<)*)<)*)<)*)<)*)C)C)C(D(C)C)C)C)C)C)C)C(D(C)C)C)C)C)C)C)C)B)C)C)C)C)C)C)C)B*B)C)C)C)C)C)C)B*B*B*B)C)C,<4683:1</>-/./,-2-",
"+-4-*-4-*,6,*,6,*,6,*,6,*,6,*,6,+,4,,-2--.../<1:46582</>-/./+.2.*-4-)-6-(,8,(,8, -8, ,:+ ,:+ ,:+ ,:+ -8,(,8,(,8,(-6-)-4-*",
".2.+/./->/<1:3864=-<37,+,3+1*1+4)/+6(.,7(,-8#,.7(*06(*15()34()43()61#*8.(*9-(*;*(+= )+@,@,A,A+B*B+B+B+A+A*B)) ?())> ),< (",
".; (0;2:395772 )71((9.)(:-))9,+(9+-(8*/)5*1*2*3,,+73D+@.=08#)15()34()33)-/3(1,2(3+1)3+1)4*1)4*0+3*0+3)1,1*1-0(4-.)4.-)5.,",
"(7/((93:1<0>0=0;28)*.6),.4)..2*/-0+2+0*4*/*5*.+6)-,6),-6),-6),-6),-6),-6(--6(.-4(/.2(1.0)2-/)4674:0A)C*@->.</(+6-),5,,-2-",
"/*2,1*0,3)0,3)0+4)/,5)/+5)/+5)/+5)0+4)0+4)1+3(2,1)1.0)/1-*/</.)00.*1/.+2--2-,-5+*-7**-8)*-8))/6*)/6*)/6*).7*).7**-.(-**.-",
",)**..,(),-/+(),./)))-..) *.00*/0.*1/-*377491=/;3782;0>-@+A+B)C)4)3 4+2 4,1 4,1 4,1 5+1 6)1(D(C)C*A+?.?-@-@,@,A*C(D(D E 0",
"(9 /*B,@.?.>.>.3 1-3 2,3 3)4)C*A+A,?.<294691>-?-=+(*;+(*9-(+8-(+8-(+8-(+8-(+8-(+8-(+8-(+8-(+8393;1;1;1;1;/=/?-?-?/=/=/=/=",
"/;2:2:2:284848, -8, -8, -6. -6. -6. -6. -8, -8, -8, -8, -:* ,;* ,;/=/=/;+)+7,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,",
"++6,++6,++6,++6,++6,++8+)+9+)+;/;+)+7,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++8",
"*++9*)*</?,=29)-*6*/+3*1+1( #3+0)5# (/( #5+.*6# (.# (6# (-( (6+,( (6( (,(((5( (,(((5( (,(()4( (-#))3*.())2# (.))*/*0(**.#",
" (1(*++*2)*+*)4)++ )6)+,9),+7( (,+4)))++2),(,*0*-)+*/# (/(+*-# (1(+),( (2(+)+#((3)*(+# )5()(*( )6(((*( )6()#*( )7((#*( )8",
"#(#*( )8#(#+#((8# (+( (8# (+( )7*,( (7).# )5)/( (5)0+3)2+1)5*.)91<#D)*# / #2)(6/+ 7.>.>->-0/,-/1*-00*.0/*/-1*0-0+0-/*3,.*",
"4-,*6-**7-**8,(*:- );0</>-?-?.>.>/=/<) -;) -:* -8**,8*+,7),,6*,+6)/*6)/*5*/*5)/*5*.+5*-+6*,+649392;.>-@+P#D) #A+B)C(C) #?",
"* #?)(#=*((=**#;*)-7)*04))# )+) #0* ((#(+ ) #.*(#)#-# ( #.*(#+#-)/*6) #-+ #3) #-+5(0,3) #..0)(#//,*(#11 +)#24)#62(#83773+",
"*11*)(*/ #-*)#.-.+(#1, #*+(#3, #)+7+ #(+(#5+ #(+(#6**+(#6**+(#6**, #6*++8* #)+8* #*+ #5* #++ #3* #,,3*(#.-.+(#07)#34)#3#4",
"(7),*<,>0:4765,,,3+0+1+2+0+3*0*4*/+4+.*6*.*6*.*6*.*6*.+4+/*4*0*4*0+2+1*2*3*0*5+,+74:0<0;28,*,5+.+3+0+1+2*1*4*/+4*/*6*-+6*",
"-+6*-+6*-+6*-+6*-+6*-+6*.+4+.+4+/+2+0,0,1,.,3-*-5674:0?,?/:**,7).+5)1*3)3*1)5)1)5*0)5*/)7)/)7)/)7)/)7)/*6)/*5*/*5*/+4)0,2",
")2,0)4--)50()83:2<2<27*(05)-.2*0-1)2,0*3+/*5+-+5+-*7*,+7*,+7*,+7*,+7*,+7*,+7*-*7)/)7)/*5)0*5)1)4)3)2)5)0)7+*+:/?,>0:*++6*",
"/+3)3*1)5*/)6*/)7*-*7*-)8+,*8*,*8*++8*,+7*,+7)-,5*-.3)/.1*/0/)12+)33()558594864))32),20)/1.)2/-)5.+*6-*+7,**9+**:*)+:*)+;",
"))+;))+;))+;)**:**+9**+9),*8).*6)0*4)2*2)5+++91?+@->/<*(+:+)+8++*8+++7+++6,++6,++6,++6,++6,++6-*+7,**8-)*8-(*9. *:1;0=/=0",
"=/>/<1:29*(.7+)-7**-6++-5++-5+,,4,,,4+-,4+-,4+-,4+-,4+-,4+-,4,,,5+,,5+,+6+,+7+*,7,(,92;0=.>1;1873:1/*//...-.1-,-3,+-4-*-4",
"-*,6,*,6,*,6,*,6,*-4-*-4-+-2-,.1--...//*/1956492/*/0/*/./..,.1/).3.(.5. -7575749393939394757- -7- .5.(.3.)/1.+//../*00:47",
"81=-=1:3857,),6+,,5+,,4,-+4,-+4,-+4+/*4+/*4+/*4+/*4,-+4,-+4,-+4,-+5+,,5+,+83:1;1:38,(-6+,+6+,,4,-+4+.+3,.+3,/*3,/*3+0*3+0",
"*3+0*3+0*3+0*3,/*3,.+3,.+3,.+4,-+4,,,5+,+6-(-7493:0>+A+@())=)*(<),(;),(9+,)8,+)8,+)8,,(8,,(8-*)8-*)8-*)8.)(;,)(;,)(;-(#=,",
" (=.>.?-?-@-?-?->/=/<( .;((-:()-:(*-9(*-7**-7*+-6),-6),-6)-,6)-,6)-,6)-,6*,,6*,+7*,+9(,*;(+*;))*>,=3936-*-3+/-/-1,--2-,-3",
",+-4-*-5,*-5,)/4,)03,)03,)20-)3/,+4,-+5+,,7 -.=0:3859584:2:0=.- 7+-*7)--5)-.5 -1:39576584939393:39, ,8,(,8,),7++,5+-,3+/,",
"1+2.*,73?2:28,*,5*.,2+0,0,0,/,2+.-2+.,3+.,3+-.1,-/0,-/0,-/0,-0.--2+-.3*,/4(+1:3756767667573:1, 4/,*4-,,3,,.2+,01+,2/*,4.*",
",5-),7,),7,),7,),7+*+7,*+7,*+7+++6+,,4+.+3+/,1,1+/+4,*,90?2:28,*-4*0+1+2+0*4+.*5,,+5,,+6+,,5+,,5+,,5+,,5+,-3,,.2+-00+.0.+",
"/3*+13(+376495956757491+)4/+-2-+/2++20*,4/)+6. -7- -8, ,9, ,9, ,9, ,:+ ,:+ -9+ -9**+8+*,7*,+6*.+4*1+1*3-++82<.<29476665,,",
"+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+6+,+66748394847+,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,,+5,",
",+5,,+5,,+5,,+5,,+5,,+66667492<.=0;***9+**9+*+8+*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+8+*+8+*+9**+:)**;0<0;**",
"*9+*+8+*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+7,*+8+*+8+*+9**+9***;0D1;176482:2:1;0;166651;.3).-2+",
".,2,.,2,.,0..--0.-+2.-+2..)3/<19393673828575583:10(/10(/00+-//---0/,-0/,-.1,--1---//-/*1./*1.>.=1:2:385680F(B.<29476492:2",
"1)-0./+0,2*0*4*1#5+A+0*2,0*2,/+1-/+1-.,0..-/..-/..-/-/.-./.,.1-,-2.*.467492;0=/=.=0;1:394756/(,4.++4--*3.-*3.-*3--+3,-+4,",
",,4-(.567491@0<0;2:***:***:***:***:***:***:***:***:***:***:***:***;0=/;***:***:***:***:***:***:***:***:***:***:***:***:**",
"*:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:2;0;, ,9, ,7. .30 001 1.1)1,1+1+1+1*2+2)2+2(3+3 3+3 3+3",
" 3+3 3+2)2+2)2+2)2+2*1+1+1+1,1)1.1 11/ /5- -6. .30 0/1)1,1+1*2+2)2+2(3+3 3+A+A+A+A+A+A+A+A+3 3+3 3+3(2+2)3)3*3 3,2 2/0 04",
"- -:.>)()=*(*<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*=)()?,?)()=*(*<)*)<)*)<)*)<)*)<)",
"*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*<*(*=.>,=286592;0=.0-.,/1,,.3,*.5+*-6,),8+),8, -8, ,:+ ,:+ ",
",:+ ,:+ ,9, -8,(,8,(-6-(-6-)-4.).2/*/.1+; +,9(+-7)+.5*+01+,3+.,@,@,@,?,),7,)-5-*,5,+-3-+-3,--0.-/,//<1:385682>,=29+)-5*,.",
"3)./1)/0/)01.(12,(22+(32+(33*(33)(44((44((44 )4757575757575845 (45 (45 )35((35((26)(07*(.8**)+ 5-,*575757484848392:2,#32+",
"(31-(20/)0/1)/.3).-5,)-82?->0:2:4674*+/4)-/1(2-1(2.0(2./(4-/(5,.)5,.)6+.)6+.*5+.*5+.*5+.+4+/,2+/5)+04(,03)+3/++4.+*7+++A+",
"@+A+A)B*B*A*A*B)C)B)B)B)C(C(C(C)B)C(B)C(C(I,>1:4765832 ,3/,+2-/+1,1*1,1*1+2*0,-) +1++11++11++11,*- )1-(. )25()24))32*)6-+",
"*B*B)B*B*A*B*B)B*B)B*B)B*A*B*A*B)B*A*B)B)B)C)B)C(D#D(D#H-<3773;0=.?,A+A*B*C(E 4(5 4)B*B+A+A+B+A+A+2 5*2 6(3 E E(D(C*B*B+A",
",?.>0<3#)4848392939383838384748492;0=.?,A-<3683:1..,.-2,-,4,+,)0*+),)2)+)+)4)*(,(,*+)+ ,(++,(+ +(,,+(1(+-,(0(+-,(0(+-,(0(",
"+-,(0(+-,(0(,,,(* ,(+,+(+ ,)+*,(+(,),(,(+(-)2)+)-*0)+).+.)*+0.#)+,2/+-5+*04)+22)+6.(+8,(+8,)+8,(+7-)+6-)+6-),4-*+6-),6,),",
"8))-:)(,;0=.>-?-@*C(A#/#:(.)9)-))*3( .**32)+05(+/=/=))(>)2,1+.0/,,2.,,3-,+4-+,5,+,5,+,5,+,5,).5,(/5,)#)+3--+2..+1/.+.1-.+",
"2,@+))2 .+(,.).5),.5),.5),.5(-.=/=/@,@,>.=/=/@,?-=/<0@,@,<0</=*:+>19+,)7( (.*3(((0*1(((1*1( )2# (/(((3+.#()4# (-(()4# ),#",
"(*4#((,#(*4#()*(()5#()*(()5( *)(()5(())(()6#())(()6#()*#()6#()*#()6#()*(()5#()+#()5#()+(((5#(),( )4#()-#((3(().( (1)()/( ",
"(/*()1+** (()3.*(()?#))?#))?#()@#()@#((@( )@#((A#((A# (A# )A# (A*B)B)B)B)B)B(@+>,H+@,?/<0:2(+392:2*(32*)31*+20*,11*,00+-0",
"0*//0)0-1*./0*-01*-00+*21+(- ,03)+21**3.,+3+/*5(1*A)B*B)C)B)B*B)C)B*B*B)C)B*B*B*A+A+()<0</=/=-?,@)F+>1:37+,, #2+)*(+ #0+(",
"(+# + #/*(#.# *(#-+ (0+/+ #2+ #++(#2+(#*+(#2, #),6+ ((,6+(#(,6+(#(,6+(#(,6, #(,(#1.++(#1.+, #0/+- #//,,(#.( ,,-(#,) ,..)+",
"(,.5(,(#.2(-(#,#).).(#-#2#(,(#0(*)*, (2+,, #=,(#=, (<,(#=,(#=+(#>*)#=+(#=+(#=+((<+)#<+)#;,)#;,)#:-)#9-)(5/*(8++)A)>+G+?/;",
"3856-)-5+-,3*1*2+1+1*3*1*3+/*5*/*5*.+5*.*7*-*7*-*7*-*7*-*7*-*7*-+5+.*5+.*5+/*3,/*3,/+2,/+1-0+/.1-), *24(*32)*4/+*B*B*A+A*",
"B*B*B*A*1*3*1*2+1*2*2+0+3+.+5+,+7492<.A*@.=)**:(.(9).)7)0)5*1)4*1)3*2*2*2*2*3*0+3*0+3*0+3*0+4)0+4)0+4)0+4)1*4)1+3)1+3)2*2",
"*2+1*3+0*4+*()*5/**6-**B*B*B)B*B)B*B)B)B*B*A*B)B)B)B)B)B)B)B(B)A*I,?/:+*+7*/*4*1*2*3*0*4+.+5*-,5+,+6++,7+*,7+*,7,(-7,(-7,",
"(-7,(-7,(-7,(-7,(-7,),7,),7,),7,)-6,*,5-++4.+,2( ,,+1((,-,-)),/3*,1/,,@,@,@+@,@,@+A+A*B*/+3*0+3*/-1*1,0*2-.*3.,*64:0A*@->",
"0;29+),8+*+7,*,6++,6++,6+,,5+,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,4,,,5,+,5,+,5,+,5,*-6+*-6,)-66758- ,;#*,@,@,@,@,@,8(,,7+*+",
"7,*+7,*+6+,+6++,6+++7+++8*++8+)+:1</>-=1;196582/)/0-/-.-2,,-4,+,6,)-6,)-6- .6- .6- .658484848566666. -6. -6.(-4/(-4/(.20)",
"./2*0)- -,8 --5)-/0,->.>.>.>-,(7-,(7-,(7,,)6-,)5--)4--+2.-+1.--..//*/0;1972A-=1:3856-(.5+-+4,-,3,-,2,/+2,/+2,/+2,/+2+1*2+",
"1*2+1*2+1*2,/+2,/+2,/+3+/+3+/+3,-,4+-,4+-,567584:, *B*A+A*A+@+A+@+A+@+A+@,@,?,@,@+A+@+A+@+A+D+A+?*()=*));**):+**9+**9+**7",
"-**7-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-*+6-),6-),8+),8+),9*(-9- +;))+A+A+A+A+A+9**+9**+8,)+8,)+8,)+8,)*",
"9,)*9,)*9+**:# #+);(,)<(*)?+=1;19-(,5-,,2.-,0/--./..-//.+0/.+0//*0//(2/0 2/0 2/0 2/0 2/=/=/=/=/=/=/1(0/1(0.2(0.2)0-2)0-2*",
"0+3+0)4-3 1//)1;1;0<0.#30+-00+-00+.//+///+0..+1-/+1-.-0--./.-/-.-1,.+5,)-81B0<0:,)+7+-*4--+2-.,0..,/...-/..-/..,0..,0-/,0",
"-/+1-/+1-/+1-/*1-0*1-0*1-0*1-0*0-1*0-1*0-1*0-1*0-1+/,1,/,1,/+2-/(3/=1.(1;0<0<//#20,-//--//,.//,/..,0-.-0-.-0,..0,-//-,1-.",
"+2,-+6+*,91@1;19+*,5,-,2,/,0,1,.-2,--2,,.2-+-4,)/4-(/4-(/4-(/4-(/4. /4. /4. /4. /4. /4. /4.)-4.).2/*-2/*-2/*-2/+,10,,/( .",
"-+.((..,*)).0/+.>.>-?-?-+,4-+,4-+-3,+.2-+.2,,.2,,.2+-.2+--2+/,1+1+0+4,++82>/<1:385756,++6,++6,++6,++6,++6,++6,++6,++6,++6",
",++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++667584:2A+A+A+A+A+A+6,++6,++6,++6,++6,++66666574=-=1:*+*9*+*8+",
"++7+++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++6,++7+++7+++8*++8*++:2;1A+A+A+A+A+6,++6,++6,++6,++6,++6,++6,++6,++6,++6",
",++6,++6,++6,++6,++7+++7+++8*+*9*+*:1?0<0:4763:1</=.2*/-0-.-0-.,0/-,/1,+/2,+.3,*-4-*-4-*-4-*-4-*,5-*,4-+,+*+-+-(,*.+6 /,5",
"(/-4 /.4 /.3(.01(/2-)/</<0;0;0<0;0:0;0;0;0;0;0<0:192:1;/=.@*S,?.<1:29381:1:0</</;0+*20++2/+,1/+-0/+.0.,./.,/..+1..*2.-*3-",
"-), -.,),(-., -)-.2+,/1,,0..,1,/,?,@,@+@,@,@+A+A+@+A+A+A*A+A*A+A+A+@,@+@,@+?0<0;2:***:***:***:***:***:***:***:***:***:***",
":***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:***:2;1B*B*B*:***:***:***:***:***:***:***:***:***:**",
"*:2;0<*(*<*(*9-(,5/(-30).00+..0-.-0-.,1-/+1-0)2-0)2-1 3-1 3-?-?-?-?-?-?-?-2 2-2 2-2(2(((2(6(2)5(2*4(2+2)2-.+2:2:2,+/2*/-2",
"*/-2*/-2)1,2)1,1)2,1)2,0*2,0+0-/,/....-./.,.1/).3/ .6- -9+ +=.>)()=*(*<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*",
")<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*=/C)C)C)C)C)C)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<)*)<*(*<*(*=.2"
};