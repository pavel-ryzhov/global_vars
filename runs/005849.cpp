// Программа для решения задачи "Сканер" из тестового задания Яндекса

#include <iostream>
#include <cstring>

using std::cout;
using std::cin;

#define SIZE 200	// Размер массива для хранения изображений
#define WHITE '.'
#define LIGHTGRAY '%'
#define DARKGRAY '#'
#define BLACK '@'
#define DIGITHEIGHT 10	// Минимальная высота цифры
#define OBJECTS 10	// Максимальное количество распозноваемых цифр
struct Image	// Хранит изображение и его границы
{
	char image[SIZE][SIZE];
	int left;	// Индекс самого левого символа
	int right;	// Индекс самого правого символа
	int top;	// Индекс самого верхнего символа
	int bottom;	// Индекс самого нижнего символа
};

bool isColour (char ch)	// Взвращает true, если символ не белый
{
	switch (ch)
		{
		case LIGHTGRAY:
		case DARKGRAY:
		case BLACK:
			return true;
			break;
		default:
			return false;
			break;
		}
}

bool haveColour(char* str)	// Взвращает true, если в строке есть цветноей символ
{
	for (int i = 0; str[i] != '\0'; i++)
	{
		if (isColour(str[i]))
			return true;		
	}
	return false;
}

int firstColourIndex(char* str)	// Ищет индекс первого символа в строке. Если не нашел, возвращает -1.
{
	for (int i = 0; str[i] != '\0'; i++)
	{
		if (isColour(str[i]))
			return i;
	}
	return -1;	// возвращает в случае, если в строке нет символа
}

int lastSymbIndex(char* str)	// Ищет индекс первого символа в строке. Если не нашел, возвращает -1.
{
	int result = -1;
	for (int i = 0; str[i] != '\0'; i++)
		if (isColour(str[i]))
			result = i;
	return result;	// возвращает -1 в случае, если в строке нет символа
}

// Определяет размер изображения
void setSize(Image& img)
{
	img.left = SIZE;
	img.right = -1;
	img.top = SIZE;
	img.bottom = -1;
	int i = 0;
	while (!haveColour(img.image[i]))
	{
		i++;
		if (i == SIZE)
			break;
	}
	img.top = i;
	if (i < SIZE)
	while (haveColour(img.image[i]))
		{
			if (firstColourIndex(img.image[i]) < img.left)
				img.left = firstColourIndex(img.image[i]);
			if (lastSymbIndex(img.image[i]) > img.right)
				img.right = lastSymbIndex(img.image[i]);
			i++;
			if (i == SIZE)
			{
				img.bottom = -1;
				return;
			}
		}
	img.bottom = --i;
}

void read(Image& input)	// Помещает изображение из входного потока в input
{
	char str[SIZE];	
	do	// Считать все пустые строки
	{
		cin.getline(str, SIZE);
	}
	while (!haveColour(str));
	int i = 0;
	while (haveColour(str))	// Считывать строки, пока они содержат цветные символы
	{
		strcpy(input.image[i],str);
		i++;
		cin.getline(str, SIZE);
	}
	input.bottom = --i;
	setSize(input);
}

// Считывает отдельный объект (группу сязанных цветных символов) из sourse, и помещает в obfect
// Возвращает true, ecли считал, false, если нет цветных символов в sourse
void getCluster(Image& source, Image& target, int i, int j)
{
	target.image[i][j] = source.image[i][j];
	source.image[i][j] = WHITE;
	if (i - 1 >= 0)
		if (isColour(source.image[i-1][j]))
			getCluster(source, target, i-1, j);
	if (i + 1 <= SIZE - 1)
		if (isColour(source.image[i+1][j]))
			getCluster(source, target, i+1, j);
	if (j - 1 >= 0)
		if (isColour(source.image[i][j-1]))
			getCluster(source, target, i, j-1);
	if (j + 1 <= SIZE - 1)
		if (isColour(source.image[i][j+1]))
			getCluster(source, target, i, j+1);
}

bool readObject(Image& source, Image& object)	// Помещает группу соседних цветных символов из source в object
{
	if (source.left < SIZE)
	{
		for (int i = source.top; i <= source.bottom; i++)
			if (isColour(source.image[i][source.left]))
				getCluster(source, object, i, source.left);
		setSize(source);
		setSize(object);
		return true;
	}
	else
		return false;
}

void clearImg(Image& img)	// Делает все символы img белыми
{
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE - 1; j++)
			img.image[i][j] = WHITE;
		img.image[i][SIZE-1] = '\0';
	}
	img.left = SIZE;
	img.right = -1;
	img.top = SIZE;
	img.bottom = -1;
}

int verticalSizeOfLine(Image& img, int horizontalIndex)	// Возвращает высоту цветной части вертикальной линии
{
	int topIndex = 0;
	int i = 0;
	while (!isColour(img.image[i][horizontalIndex]))
		i++;
	topIndex = i;
	i = img.bottom;
	while (!isColour(img.image[i][horizontalIndex]))
		i--;
	return i - topIndex + 1;
}

void devide(Image& img, Image& target)	// Рзаделяет изображение на 2 части по самому тонокому месту, помещая отделенную часть в target
{
	int min = SIZE;
	int indexOfMin = 0;
	for (int i = img.left + 6; i <= img.right - 6; i++)
	{
		if (verticalSizeOfLine(img, i) < min)
		{
			indexOfMin = i;
			min = verticalSizeOfLine(img, i);
		}
	}
	for (int i = img.top; i <= img.bottom; i++)
		for (int j = indexOfMin; j <= img.right; j++)
			if (isColour(img.image[i][j]))
			{
				target.image[i][j] = img.image[i][j];
				img.image[i][j] = WHITE;
			}
	setSize(img);
	setSize(target);
}

void putPixel(Image& img, int i, int j)	// Закрашивает определенным образом окрестность символа
{
	img.image[i][j] = BLACK;
	if (i - 1 >= 0)
		img.image[i-1][j] = BLACK;		
	if (i + 1 <= SIZE - 1)
		img.image[i+1][j] = BLACK;		
	if (j - 1 >= 0)
		img.image[i][j-1] = BLACK;		
	if (j + 1 <= SIZE - 1)
		img.image[i][j+1] = BLACK;		
}

void generate0(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <= bottom; i++)
	{
		putPixel(img, i, left);
		putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j);
		putPixel(img, bottom, j);
	}
}

void generate1(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <= bottom; i++)
	{
		putPixel(img, i, right);
	}
}

void generate2(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <=(top + bottom)/2; i++)
	{
		putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j); putPixel(img, bottom, j);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, bottom - static_cast<int>((j - left) * static_cast<double>(bottom - (top + bottom)/2 +1)/(right - left + 1)), j);
	}
}

void generate3(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <= bottom; i++)
	{
		putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j); 
		putPixel(img, bottom, j); 
		putPixel(img, (top+bottom)/2, j);
	}
	for (int i = top + static_cast<int>((bottom - top)*3.0/4.0) + 1; i <= bottom; i++)
	{
		putPixel(img, i, left);
	}
	for (int i = top ; i <= top + static_cast<int>((bottom - top)/4.0); i++)
	{
		putPixel(img, i, left);
	}
}

void generate4(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <=bottom; i++)
	{
		putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, (top+bottom)/2, j);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, (top + bottom)/2 - static_cast<int>((j - left) * static_cast<double>((top + bottom)/2 - top +1)/(right - left + 1)), j);
	}
}

void generate5(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <=(top + bottom)/2; i++)
	{
		putPixel(img, i, left);
	}
	for (int i = (top + bottom)/2 + 1; i <= bottom; i++)
	{
		putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j); 
		putPixel(img, bottom, j); 
		putPixel(img, (top+bottom)/2, j);
	}
	for (int i = top + static_cast<int>((bottom - top)*3.0/4.0) + 1; i <= bottom; i++)
	{
		putPixel(img, i, left);
	}
}

void generate6(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <=(top + bottom)/2; i++)
	{
		putPixel(img, i, left);
	}
	for (int i = (top + bottom)/2 + 1; i <= bottom; i++)
	{
		putPixel(img, i, left); 
		putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j); 
		putPixel(img, bottom, j); 
		putPixel(img, (top+bottom)/2, j);
	}
	for (int i = top; i <= top + static_cast<int>((bottom - top)/4.0); i++)
	{
		putPixel(img, i, right);
	}
}

void generate7(Image& img, int left, int right, int top, int bottom)
{
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, bottom - static_cast<int>((j - left) * static_cast<double>(bottom - top + 1)/(right - left + 1)), j);
	}
}

void generate8(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <= bottom; i++)
	{
		putPixel(img, i, left); 
		putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j); 
		putPixel(img, bottom, j); 
		putPixel(img, (top+bottom)/2, j);
	}
}

void generate9(Image& img, int left, int right, int top, int bottom)
{
	for (int i = top; i <=(top + bottom)/2; i++)
	{
		putPixel(img, i, left); 
		putPixel(img, i, right);
	}
	for (int i = (top + bottom)/2 + 1; i <= bottom; i++)
	{
		 putPixel(img, i, right);
	}
	for (int j = left; j <= right; j++)
	{
		putPixel(img, top, j); 
		putPixel(img, bottom, j); 
		putPixel(img, (top+bottom)/2, j);
	}
	for (int i = top + static_cast<int>((bottom - top)*3.0/4.0) + 1; i <= bottom; i++)
	{
		putPixel(img, i, left);
	}
}

void generateDigit(int Digit, Image& img, int left, int right, int top, int bottom)	// Генерирует изображение цифры Digit, помещая ее в прямоугольник left-right-top-bottom в img
{
	img.left = left;
	img.right = right;
	img.top = top;
	img.bottom = bottom;
	left++;
	right--;
	top++;
	bottom--;
	if (right - left + 1 > 9 || Digit == 1)
		switch (Digit)
		{
		case 0:
			generate0(img, left, right, top, bottom);
			break;
		case 1:
			generate1(img, left, right, top, bottom);
			break;
		case 2:
			generate2(img, left, right, top, bottom);
			break;
		case 3:
			generate3(img, left, right, top, bottom);
			break;
		case 4:
			generate4(img, left, right, top, bottom);
			break;
		case 5:
			generate5(img, left, right, top, bottom);
			break;
		case 6:
			generate6(img, left, right, top, bottom);
			break;
		case 7:
			generate7(img, left, right, top, bottom);
			break;
		case 8:
			generate8(img, left, right, top, bottom);
			break;
		case 9:
			generate9(img, left, right, top, bottom);
			break;
		}
}

double compare(const Image& img1, Image img2)	// Возвращает число, меньшее 1, показывающее, насколько похожи фигуры
{
	int square1 = 0;
	int square2 = 0;
	int intersectionSquare = 0;	// Площадь пересечения фигур
	for (int i = img1.top; i <= img1.bottom; i++)
		for (int j = img1.left; j <= img1.right; j++)
		{
			if (isColour(img1.image[i][j]))
				square1++;
			if (isColour(img2.image[i][j]))
				square2++;
			if (isColour(img1.image[i][j]) && isColour(img2.image[i][j]))
				intersectionSquare++;
		}
	return static_cast<double>(intersectionSquare)/(square1 + square2 - intersectionSquare);
}

double compareWithDigit(int digit,	// Цифра, с которой сравнивается объект img
						const Image& img)	// Изображение, которое надо распознать
{
	double maxIntersection = 0;
	Image tmp;
	int left = img.left;
	int right = img.right;
	int top = img.top;
	int bottom = img.bottom;
	//for (int i = 0; i <=  4 + (img.right - img.left)/4; i++)
	//{
	clearImg(tmp);
	generateDigit(digit, tmp, left, right, top, bottom);
	double intersection = compare(img, tmp);
	if (intersection > maxIntersection)
		maxIntersection = intersection;
	//left++;
	//right--;
	//top++;
	//bottom--;
	//if (left > right || top > bottom)
	//	break;
	//}
	return maxIntersection;
}

void recognize(const Image& img)
{
	double maxIntersection = 0;
	int result = -1;
	for (int digit = 0; digit < 10; digit++)
	{
		double intersection = compareWithDigit(digit, img);
		if (intersection > maxIntersection)
		{
			maxIntersection = intersection;
			result = digit;
		}
	}
	cout << result;
}


int main()
{
	// Считывание изображения
	Image input;
	clearImg(input);
	read(input);

	// Извлечение отдельных объектов
	int DigitsNumber = 0;
	Image object[OBJECTS];
	int i = 0;
	clearImg(object[0]);
	while (readObject(input, object[i]))
	{
		if (i == OBJECTS)
			break;
		if (object[i].bottom - object[i].top < DIGITHEIGHT)	// Объекты с высотой менше DIGITHEIGHT отбрасываются
		{
			clearImg(object[i]);
			continue;
		}
		if (i > 0)
			if (object[i].right < object[i-1].right)	// Обекты, которые содержат внутри цифру, отбрасываются
			{
				object[i-1] = object[i];
				clearImg(object[i]);
				continue;
			}
		i++;
		DigitsNumber++;
		if (i < OBJECTS)
			clearImg(object[i]);
	}

	// Распознавание объектов
	for (int j = 0; j < DigitsNumber; j++)
	{
		recognize(object[j]);
	}
	cout << "\n" ;
	return 0;
}