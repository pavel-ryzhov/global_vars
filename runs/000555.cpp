#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include <fstream>
#include <algorithm>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::pair;
using std::string;
using std::sort;
typedef vector< vector<char> > matrix;
void PrintDigit(vector< vector<char> > &d);

const unsigned char template_digits[10*10*16] = 
{
0x3e,0x7e,0x5f,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0x5f,0x7e,0x7e,0x3c,
0x3e,0x3f,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x7e,0xff,
0x7e,0xff,0xff,0xff,0xe7,0xf0,0xf0,0xf8,0x78,0x7c,0x3e,0x1e,0xff,0xff,0xff,0xff,
0x3e,0x7e,0xe7,0xc3,0xe0,0x60,0x78,0x78,0xe0,0xc0,0xc0,0xc3,0xc3,0xe7,0x7e,0x3c,
0x1c,0x1c,0x1c,0x3c,0x3e,0x3e,0x3e,0x3e,0x37,0x37,0xff,0xff,0xf0,0x78,0x78,0x78,
0xfe,0xfe,0xfe,0xff,0x07,0x7f,0xff,0xff,0xff,0xe0,0xe0,0xe7,0xff,0xff,0x7e,0x3c,
0x7c,0x06,0x02,0x02,0x03,0x3d,0x63,0x43,0xc1,0xc1,0xc1,0xc1,0x43,0x42,0x66,0x3c,
0xff,0xff,0x60,0x60,0x30,0x30,0x18,0x18,0x18,0x0c,0x0c,0x0c,0x0c,0x06,0x06,0x06,
0x38,0x38,0x3c,0x7e,0x7f,0x67,0x7f,0x7e,0x7e,0xff,0xe7,0xe7,0xe7,0xe7,0x7e,0x3e,
0x3e,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xe7,0xfe,0xfe,0xc0,0xc3,0xe3,0x7f,0x3e,0x1c,

0x7E,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x7E, //
0x78,0x7f,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0xff,
0x7e,0x7e,0xe7,0xc3,0xc3,0xc0,0xe0,0x60,0x70,0x38,0x1c,0x0e,0x0e,0x07,0xff,0xff,
0x7c,0xe6,0xe7,0xe3,0x7b,0x3f,0x7e,0x78,0xec,0xe0,0xe0,0xe3,0xe3,0x73,0x33,0x1e,
0x1c,0x1c,0x1c,0x3c,0x3e,0x3e,0x3e,0x3e,0x37,0x37,0xff,0xff,0xf0,0x78,0x78,0x78,
0xfe,0xfe,0xfe,0xff,0x07,0x7f,0xff,0xff,0xff,0xe0,0xe0,0xe7,0xff,0xff,0x7e,0x3c,
0x7c,0x4e,0x0e,0x0f,0x0f,0x7f,0x5f,0x8f,0x8f,0x8f,0x8f,0x8f,0xcf,0x4e,0x6e,0x3c,
0xff,0xff,0x60,0x60,0x30,0x30,0x38,0x18,0x18,0x0c,0x0c,0x0c,0x0c,0x0e,0x06,0x06,
0x7e,0xe6,0xc3,0xc3,0xe7,0x6f,0x3f,0x7c,0x7e,0xf7,0xe3,0xc3,0xc3,0xe3,0x76,0x3c,
0x3e,0x7e,0xe7,0xc3,0xc3,0xc3,0xc3,0xe7,0xfe,0xfe,0xc0,0xc3,0xe3,0x7f,0x3e,0x1c,

0x7E,0xFF,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xFF,0x7E, //
0x3c,0x3f,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0xff,
0x7c,0xc2,0xc3,0xc3,0xc7,0xc7,0xe6,0x60,0x70,0x10,0x18,0x8c,0x86,0x82,0xff,0xff,
0x3E,0x7F,0x61,0xC0,0xC0,0xC0,0x60,0x38,0x78,0xC0,0xC0,0xC0,0xE1,0x7F,0x3E,0x00, //
0x20,0x30,0x30,0x38,0x38,0x34,0x34,0x32,0x32,0x31,0x31,0xff,0x30,0x30,0x30,0xf8,
0x7f,0x7f,0x01,0x01,0x01,0x1f,0x21,0x60,0xc0,0xc0,0xc0,0xc1,0xc3,0x43,0x26,0x3c,
0x30,0x18,0x1c,0x0c,0x0e,0x77,0xff,0xff,0xf7,0xf7,0xef,0xef,0xff,0x7f,0x3e,0x1e,
0xff,0xff,0x41,0x41,0x21,0x20,0x30,0x10,0x18,0x18,0x08,0x0c,0x0c,0x04,0x04,0x04,
0xfc,0xfe,0xf6,0xf7,0x7f,0x7f,0x7f,0xfe,0xfc,0xfe,0xf7,0xe7,0x7f,0x3f,0x1f,0x0f,
0x3e,0x62,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xfe,0xc0,0xc0,0xc2,0xc7,0x67,0x73,0x1c,

0x7E,0xFF,0xE3,0xE3,0xE3,0xD3,0xD3,0xD3,0xCB,0xCB,0xCB,0xC7,0xC7,0xC7,0xFF,0x7E,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1f,0x3b,0x3f,0x7f,0x78,0x78,0x78,0x78,0x78,0x7c,0x3c,0x1e,0xff,0xc7,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x18,0x1c,0x6c,0x3e,0x36,0x36,0x37,0xff,0xff,0x7f,0x3f,0x38,0x38,0x38,0x18,
0xff,0xff,0x03,0x03,0x1f,0x7f,0xf9,0xe0,0xe0,0xc0,0xc0,0xe0,0xe0,0x70,0x3e,0x0f,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xff,0xff,0xc1,0x41,0x61,0x70,0x30,0x18,0x18,0x1c,0x1e,0x1e,0x1e,0x1f,0x1f,0x1e,
0x1c,0x7e,0x7e,0xc6,0xc6,0xc6,0xff,0x7f,0x7f,0xe7,0xc7,0xd7,0xf7,0x67,0x6e,0x3e,
0x7e,0xff,0xff,0xff,0xff,0xef,0xef,0xff,0xff,0xfe,0x7e,0x78,0x78,0x3c,0x3c,0x18,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7e,0x7e,0xc3,0xc3,0xc3,0xc0,0x60,0x60,0x70,0x38,0x1c,0x0e,0x06,0x03,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1c,0x0c,0x0e,0x0e,0x0a,0x1a,0x1b,0x1b,0x19,0xff,0x18,0x18,0x18,0x18,0x18,0x08,
0xff,0xff,0x03,0x03,0x1f,0x7f,0xf9,0xe0,0xe0,0xc0,0xc0,0xe0,0xe0,0x70,0x3e,0x0f,
0x1c,0x1e,0x0e,0x0f,0x3f,0x7f,0xff,0xff,0xf7,0xf7,0xf7,0xff,0x7f,0x7f,0x7e,0x3c,
0xff,0xff,0xff,0xff,0x78,0x78,0x78,0x3c,0x3c,0x3c,0x1e,0x1e,0x1f,0x1f,0x1e,0x18,
0x7e,0x7f,0xcf,0xcf,0xdf,0x7b,0x76,0x6e,0xff,0xdb,0xb1,0xb1,0xa1,0xf3,0xff,0x7e,
0xf6,0xfe,0xff,0xf7,0xe7,0xe7,0xe7,0xfe,0xff,0xff,0xf8,0xe0,0xe0,0xe0,0xe0,0xe0,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xe0,0xf0,0x78,0x78,0x7c,0x30,0x30,0x18,0x1c,0x0c,0x04,0xce,0xdf,0xff,0xfb,0x31,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1c,0x1c,0x06,0x06,0x1a,0x1b,0x1b,0x19,0xff,0x18,0x18,0x18,0x18,0x18,0x10,0x10,
0xc0,0x7c,0x3c,0x04,0x06,0x06,0x3e,0xfe,0xe6,0xe6,0xe0,0xe0,0xe3,0x73,0x33,0x1e,
0x1c,0x1e,0x0e,0x0f,0x3f,0x7f,0xff,0xff,0xf7,0xf7,0xf7,0xff,0x7f,0x7f,0x7e,0x3c,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7e,0x7f,0xcf,0xcf,0xdf,0x7b,0x76,0x6e,0xff,0xdb,0xb1,0xb1,0xa1,0xf3,0xff,0x7e,
0xf6,0xfe,0xff,0xf7,0xe7,0xe7,0xe7,0xfe,0xff,0xff,0xf8,0xe0,0xe0,0xe0,0xe0,0xe0,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x70,0x70,0x78,0x78,0x7c,0x7c,0x7e,0x76,0x77,0xff,0xff,0xc1,0xff,0x70,0x70,0x70,
0x7e,0x02,0x02,0x1e,0x7b,0x78,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xf9,0x79,0x7f,0x3c,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3c,0x7e,0x63,0xc3,0xc3,0x42,0x7e,0x7e,0xe7,0xc3,0xc3,0xc1,0xc3,0xe7,0x7e,0x3c,
0x3e,0x7e,0x63,0x43,0xc3,0xc3,0xc3,0xe3,0xfe,0xde,0x40,0x40,0x63,0x77,0x3e,0x1c,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7e,0xfc,0xee,0x4e,0x0e,0x0e,0x7e,0xfe,0xfc,0xf0,0xe0,0xe7,0xff,0xff,0x7e,0x3e,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xfc,0xfe,0xee,0x67,0x3e,0x3e,0x1e,0x1c,0x1c,0x1e,0x1f,0x1b,0x1b,0x1f,0x0f,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xfc,0x3c,0x3c,0x1e,0x1e,0x1e,0x7e,0xc0,0xc0,0xc0,0x80,0xc0,0xc1,0xe3,0x7f,0x3e,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xf8,0xfc,0x3c,0x1c,0x3c,0x7c,0x7c,0x30,0x38,0x18,0x1c,0x0c,0x06,0x07,0x07,0x03,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};



bool NotOfDots(string &S)
{
	for (unsigned int i = 0; i < S.length(); ++i)
		if (S.at(i) != '.')
			return true;
	return false;
}

void Input(matrix &all_points)
{
	vector<string> lines;
	while (1)
	{
		string input;
		getline(cin, input);
		if (NotOfDots(input))
		{
			lines.push_back(input);
		}
		else if (lines.size() > 0)
			break;
	}
	all_points.resize(lines.size());
	for (size_t line = 0; line < lines.size(); ++line)
	{
		for (size_t col = 0; col < lines[0].size(); ++col)
		{
			if (lines[line].at(col) == '.')
				all_points[line].push_back(0);
			else if (lines[line].at(col) == '%')
				all_points[line].push_back(1);
			else if (lines[line].at(col) == '#')
				all_points[line].push_back(2);
			else
				all_points[line].push_back(3);
		}
	}
}


void ResizeDigit(const matrix &old_digit, int new_w, int new_h, matrix &new_digit)
{
	double h_coeff = new_h/((double) old_digit.size());
	double w_coeff = new_w/((double) old_digit[0].size());

	new_digit.resize(0);
	for (int line = 0; line < new_h; ++line)
	{
		new_digit.push_back(vector<char> (new_w, 0));
	}

	for (size_t line = 0; line < old_digit.size(); ++line)
	{
		for (size_t col = 0; col < old_digit[0].size(); ++col)
		{
			if (old_digit[line][col] > 0)
			{
				//new_digit[line * h_coeff][col * w_coeff] += 1;
				new_digit[line * h_coeff][col * w_coeff] = 1;
				/*
				if (((int) (col * w_coeff)) != ((int) ((col + 1) * w_coeff)))
				{
					if ((col + 1) * w_coeff < new_w)
						new_digit[line * h_coeff][(col + 1) * w_coeff] += 1;
				}
				
				if ((((int) line * h_coeff)) != ((int) ((line + 1) * h_coeff)))
				{
					if ((line + 1) * h_coeff < new_h)
					{
						new_digit[(line + 1) * h_coeff][col * w_coeff] += 1;
	
						
						if (((int)(col * w_coeff)) != ((int) ((col + 1) * w_coeff)))
						{
							if ((col + 1) * w_coeff < new_w)
								new_digit[(line + 1) * h_coeff][(col + 1) * w_coeff] += 1;
						}
					}
				}
				*/
			}
		}
	}
	/*
	for (int line = 0; line < new_h; ++line)
	{
		for (int col = 0; col < new_w; ++col)
		{
			double blackness = new_digit[line][col] * h_coeff * w_coeff;
			new_digit[line][col] = 0;
			if (blackness > 0.6)
				new_digit[line][col] = 1;
		}
	}
	*/
}


unsigned char mask[8] = {128, 64, 32, 16, 8, 4, 2, 1};

int GetDigitsDifference(const matrix &digit, const unsigned char *template_digit)
{
	int result = 0;
	for (int line = 0; line < 16; ++line)
	{
		for (int col = 0; col < 8; ++col)
		{
			if (digit[line][col] == 1 && (*(template_digit + line) & mask[7 - col]) == 0)
				result += 1;
			if (digit[line][col] == 0 && (*(template_digit + line) & mask[7 - col]) != 0)
				result += 1;
		}
	}
	return result;
}

int RecognizeDigit (const matrix &resized_digit)
{
	vector<int> differences(10, std::numeric_limits<int>::max());
	for (int i = 0; i < 10; ++i)
	{
		for (int j = 0; j < sizeof(template_digits)/(10*16); ++j )
		{
			differences[i] = std::min(differences[i], GetDigitsDifference(resized_digit, template_digits + 10*16*j + 16*i));
		}
	}

	int real_digit = -1;
	int min_difference = std::numeric_limits<int>::max();
	for (int i = 0; i < 10; ++i)
	{
		if (differences[i] < min_difference)
		{
			min_difference = differences[i];
			real_digit = i;
		}
	}
	return real_digit;
}

bool IsValidPoint(int line, int col, int max_line, int max_col)
{
	if (line < 0 || line > max_line || col < 0 || col > max_col)
		return false;
	return true;
}

typedef struct {
	int size;
	pair<int, int> horizontal_margins;
	pair<int, int> vertical_margins;
	int label;
} area_params;

void VisitConnectedArea(const matrix &all_points, int line, int col, matrix &marked_areas, vector<area_params> &areas_parameters, int black_level_left, int black_level_right)
{
	int whole_heigth = all_points.size();
	int whole_width = all_points[0].size();

	for (int y_coord = line - 1; y_coord <= line + 1; ++y_coord)
	{
		for (int x_coord = col - 1; x_coord <= col + 1; ++x_coord)
		{
			if (IsValidPoint(y_coord, x_coord, whole_heigth - 1, whole_width - 1))
			{
				if (marked_areas[y_coord][x_coord] == -1)
				{
					if (x_coord <= whole_width/2 && all_points[y_coord][x_coord] <= black_level_left)
						marked_areas[y_coord][x_coord] = 0;
					else if (x_coord > whole_width/2 && all_points[y_coord][x_coord] <= black_level_right)
						marked_areas[y_coord][x_coord] = 0;
					else
					{
						marked_areas[y_coord][x_coord] = marked_areas[line][col];
						areas_parameters[marked_areas[line][col] - 1].label = marked_areas[line][col];
						areas_parameters[marked_areas[line][col] - 1].horizontal_margins.first = \
							 std::min(areas_parameters[marked_areas[line][col] - 1].horizontal_margins.first, x_coord);
						areas_parameters[marked_areas[line][col] - 1].horizontal_margins.second = \
							 std::max(areas_parameters[marked_areas[line][col] - 1].horizontal_margins.second, x_coord);
						areas_parameters[marked_areas[line][col] - 1].vertical_margins.first = \
							 std::min(areas_parameters[marked_areas[line][col] - 1].vertical_margins.first, y_coord);
						areas_parameters[marked_areas[line][col] - 1].vertical_margins.second = \
							 std::max(areas_parameters[marked_areas[line][col] - 1].vertical_margins.second, y_coord);
						areas_parameters[marked_areas[line][col] - 1].size += 1;
						VisitConnectedArea(all_points, y_coord, x_coord, marked_areas, areas_parameters,black_level_left, black_level_right);
					}
				}
			}
		}
	}
}

int	MarkConnectedAreas(const matrix &all_points, matrix &marked_areas, vector<area_params> &areas_parameters, int black_level_left, int black_level_right)
{
	size_t whole_heigth = all_points.size();
	size_t whole_width = all_points[0].size();

	if (black_level_left > 2)
		black_level_left = 2;
	if (black_level_right > 2)
		black_level_right = 2;

	areas_parameters.resize(0);
	marked_areas.resize(0);
	//fill marked_areas with '-1'
	for (size_t line = 0; line < whole_heigth; ++line)
		marked_areas.push_back(vector<char> (whole_width, -1));

	int areas_counter = 0;
	for (size_t line = 0; line < whole_heigth; ++line)
	{
		for (size_t col = 0; col < whole_width; ++col)
		{
			if (marked_areas[line][col] != -1)
				continue;

			if (col <= whole_width/2 && all_points[line][col] <= black_level_left)
			{
				marked_areas[line][col] = 0;
				continue;
			}
			if (col > whole_width/2 && all_points[line][col] <= black_level_right)
			{
				marked_areas[line][col] = 0;
				continue;
			}
			marked_areas[line][col] = ++areas_counter;
			areas_parameters.resize(areas_counter);
			areas_parameters[areas_counter - 1].label = marked_areas[line][col];
			areas_parameters[areas_counter - 1].horizontal_margins.first = areas_parameters[areas_counter - 1].horizontal_margins.second = col;
			areas_parameters[areas_counter - 1].vertical_margins.first = areas_parameters[areas_counter - 1].vertical_margins.second = line;
			areas_parameters[areas_counter - 1].size = 1;
			VisitConnectedArea(all_points, line, col, marked_areas, areas_parameters, black_level_left, black_level_right);
		}
	}

	return areas_counter;
}

void PrintDigit(vector< vector<char> > &d);

void ClearConnectedArea(matrix &marked_areas, int area_label)
{
	for (size_t line = 0; line < marked_areas.size(); ++line)
	{
		for (size_t col = 0; col < marked_areas[0].size(); ++col)
		{
			if (marked_areas[line][col] == area_label)
				marked_areas[line][col] = 0;
		}
	}
}

bool IsInArray(int key, const vector<int> keys_array)
{
	for (size_t i = 0; i < keys_array.size(); ++i)
		if (keys_array[i] == key)
			return true;
	return false;
}

void ExtractDigit (const matrix &marked_areas, int digit_label, matrix &digit)
{
	int left_margin = marked_areas[0].size() - 1;
	int right_margin = 0;
	int top_margin = marked_areas.size() - 1;
	int bottom_margin = 0;

	for (int line = 0; line < marked_areas.size(); ++line)
	{
		for (int col = 0; col < marked_areas[0].size(); ++col)
		{
			if (marked_areas[line][col] == digit_label)
			{
				left_margin = std::min(left_margin, col);
				right_margin = std::max(right_margin, col);
				top_margin = std::min(top_margin, line);
				bottom_margin = std::max(bottom_margin, line);
			}
		}
	}

	digit.resize(bottom_margin - top_margin + 1);
	for (int line = top_margin; line <= bottom_margin; ++line)
	{
		for (int col = left_margin; col <= right_margin; ++col)
		{
			char point = (marked_areas[line][col] == digit_label) ? 1 : 0;
			digit[line - top_margin].push_back(point);
		}
	}
}

bool IsNewDigit(const vector<area_params> &real_digits_parameters, const area_params &new_area)
{
	for (vector<area_params>::const_iterator area = real_digits_parameters.begin(); area != real_digits_parameters.end(); ++area)
	{
		if (new_area.vertical_margins.first >= area->vertical_margins.second ||
				new_area.vertical_margins.second <= area->vertical_margins.first)
			return false;
	}
	return true;
}

class CompareAreaSizes {
public:
	bool operator () (area_params area1, area_params area2)
	{
		if (area1.size < area2.size)
			return true;
		return false;
	}
};
/*
bool CompareAreaSizes(area_params area1, area_params area2)
{
	if (area1.size <= area2.size)
		return true;
	return false;
}
*/
int CountDigits(const matrix &all_points)
{
	matrix marked_areas;
	vector<area_params> areas_parameters;
	MarkConnectedAreas(all_points, marked_areas, areas_parameters, 2, 2);
	vector<area_params> real_digits_parameters(0);
	sort(areas_parameters.begin(), areas_parameters.end(), CompareAreaSizes());
	for (vector<area_params>::iterator area = areas_parameters.begin(); area != areas_parameters.end(); ++area)
	{
		if (((float)area->size)/areas_parameters[0].size > 0.25)
			if (IsNewDigit(real_digits_parameters, *area))
			{
				real_digits_parameters.push_back(*area);
				if (real_digits_parameters.size() == 3)
					break;
			}
	}
	return real_digits_parameters.size();
}

void SeparateIntelligently (const matrix &all_points, vector <matrix> &digits)
{
	matrix marked_areas;
	vector<area_params> areas_parameters;
	int digits_quantity =  CountDigits(all_points);
	//cout << digits_quantity << " digits" << endl;
	for (int black_level = 0; black_level < 3; ++black_level)
	{
		{
			int big_areas_counter = 0;
			MarkConnectedAreas(all_points, marked_areas, areas_parameters, black_level, black_level);

			sort(areas_parameters.begin(), areas_parameters.end(), CompareAreaSizes());

			int max_area_size = areas_parameters[areas_parameters.size() - 1].size;
			big_areas_counter = 0;
			for (size_t i = 0; i < areas_parameters.size(); ++i)
				if (((double) areas_parameters[i].size)/max_area_size >= 0.25)
					++big_areas_counter;
			if (big_areas_counter == digits_quantity)
				break;
		}
		{
			int big_areas_counter = 0;
			MarkConnectedAreas(all_points, marked_areas, areas_parameters, black_level, black_level + 1);

			sort(areas_parameters.begin(), areas_parameters.end(), CompareAreaSizes());

			int max_area_size = areas_parameters[areas_parameters.size() - 1].size;
			big_areas_counter = 0;
			for (size_t i = 0; i < areas_parameters.size(); ++i)
				if (((double) areas_parameters[i].size)/max_area_size >= 0.25)
					++big_areas_counter;
			if (big_areas_counter == digits_quantity)
				break;
		}
		{
			int big_areas_counter = 0;
			MarkConnectedAreas(all_points, marked_areas, areas_parameters, black_level + 1, black_level);

			sort(areas_parameters.begin(), areas_parameters.end(), CompareAreaSizes());

			int max_area_size = areas_parameters[areas_parameters.size() - 1].size;
			big_areas_counter = 0;
			for (size_t i = 0; i < areas_parameters.size(); ++i)
				if (((double) areas_parameters[i].size)/max_area_size >= 0.25)
					++big_areas_counter;
			if (big_areas_counter == digits_quantity)
				break;
		}
	}
/*
	if (area_sizes.size() > big_areas_counter)
	{
		for (size_t i = 0; i < area_sizes.size(); ++i)
		{
			int i_order_statistics = 0;
			for (size_t j = 0; j < area_sizes.size(); ++j)
			{
				if (area_sizes[j] > area_sizes[i])
					++i_order_statistics;
			}
			if (i_order_statistics >= big_areas_counter)
			{
				ClearConnectedArea(marked_areas, i + 1);
			}
		}
	}
*/
	for (int i = 0; i < areas_parameters.size() - digits_quantity; ++i)
	{
		ClearConnectedArea(marked_areas, areas_parameters[i].label);
	}
	//PrintDigit(marked_areas);

	/*
	vector<int> digit_labels;
	for (size_t line = 0; line < marked_areas.size(); ++line)
	{
		for (size_t col = 0; col < marked_areas[0].size(); ++col)
		{
			if (digit_labels.size() == 0 && col > marked_areas[0].size()/3)
				break;
			if (digit_labels.size() == 1 && col > 2*marked_areas[0].size()/3)
				break;
			int label = marked_areas[line][col];
			if (label > 0 && !IsInArray(label, digit_labels))
				digit_labels.push_back(label);
			if (digit_labels.size() == 3)
				break;
		}
		if (digit_labels.size() == 3)
			break;
	}
	*/
	vector<int> digit_labels;
	for (size_t col = 0; col < marked_areas[0].size(); ++col)
	{
		int label = marked_areas[marked_areas.size()/2][col];
		if (label > 0 && !IsInArray(label, digit_labels))
			digit_labels.push_back(label);
	}
	digits.resize(digit_labels.size());
	for (int i = 0; i < digit_labels.size(); ++i)
	{
		ExtractDigit(marked_areas, digit_labels[i], digits[i]);
		//PrintDigit(digits[i]);
	}
}

void PrintDigit(matrix &d)
{
	for (unsigned int line = 0; line < d.size(); ++line)
	{
		for (unsigned int col = 0; col < d[line].size(); ++col)
		{
			if (d[line][col] == 0)
				cout << '.';
			else if (d[line][col] == 1)
				cout << '%';
			else if (d[line][col] == 2)
				cout << '#';
			else if (d[line][col] == 3)
				cout <<	'@';
			else
				cout <<	' ';
		}
		//	cout << ((d[line][col] > 0) ? '@' : '.');
		cout << endl;
	}
}

void Recognize(const matrix &all_points, string &result_digits)
{
	vector<matrix> digits;
	SeparateIntelligently(all_points,digits);

	vector<matrix> resized_digits(digits.size());
	for (int i = 0; i < digits.size(); ++i)
	{
		ResizeDigit(digits[i], 8, 16, resized_digits[i]);
		result_digits.push_back( RecognizeDigit(resized_digits[i]) + '0');
		//PrintDigit(resized_digits[i]);
		//cout << endl;
	}
}

void FileInput(matrix &all_points, int f_num)
{
	char f_name[16];
	sprintf(f_name, "samples/%03d", f_num);
	vector<string> lines;
	std::ifstream file_input_stream(f_name);
	//file_input_stream.open(f_name, std::ios::ea
	if (!file_input_stream)
	{
		cout << "can't open file " << f_name << endl;
	}
	while (1)
	{
		string input;
		getline(file_input_stream, input);
		if (NotOfDots(input))
		{
			lines.push_back(input);
		}
		else if (lines.size() > 0)
			break;
	}
	file_input_stream.close();

	all_points.resize(lines.size());
	for (int line = 0; line < lines.size(); ++line)
	{
		for (unsigned int col = 0; col < lines[0].size(); ++col)
		{
			if (lines[line].at(col) == '.')
				all_points[line].push_back(0);
			else if (lines[line].at(col) == '%')
				all_points[line].push_back(1);
			else if (lines[line].at(col) == '#')
				all_points[line].push_back(2);
			else
				all_points[line].push_back(3);
		}
	}
}

void CheckResult (string &digits, int f_num)
{
	char f_name[16];
	sprintf(f_name, "samples/%03d.a", f_num);
	vector<string> lines;
	std::ifstream file_input_stream(f_name);

	if (!file_input_stream)
	{
		cout << "can't open file " << f_name << endl;
		return;
	}

	string real_digits;
	getline(file_input_stream , real_digits);
	if (digits == real_digits)
		cout << "OK" << endl;
	else
		cout << "FAILED: " << digits << " != " << real_digits << endl;


}

void test_samples()
{
	for (int sample = 1; sample <= 19; ++sample)
	{
		matrix all_points;
		FileInput(all_points, sample);
		//Input(all_points);

		string results;
		Recognize(all_points, results);
		cout << sample << ".";
		CheckResult(results, sample);
		string fake;
		getline(cin,fake);
		//cout << results << endl;
	}

}

int main()
{
	//test_samples();
	matrix all_points;
	Input(all_points);

	string results;
	Recognize(all_points, results);
	cout << results << endl;
	
//	Save(resized_digits);
	return 0;
}