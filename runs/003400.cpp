#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <list>

/*
About programe.
Let us consider words in the dictionary and make some groups of them. Each group consists of words which has the same code.
Also there're ratings of each word in the group.
Code is the sequence of digits which user should enter to get suitable word. WordStorage is the class which realises such group.
For example code of the word "cat" is 228.
In fact these groups can be generated by calling function CreateDataBase (istream&) which is member of class Tree.
At first words in each WordStorage are sorted in alphabetic order. All the groups are stored in map< Code, WordStorage> _dataBase
in the class Tree. Here Code is vector<unsigned int>.
So if you know the code of the word with number of stars after it in the input string you can find this word by taping something like this
string word = tree._dataBase [code].Choose ( number_of_stars).
Function string WordStorage::Choose ( unsigned int) increments rating of the word and moves it upper than other words with the same
rating without changing order of other words in the group. 
For example if we have pairs <"act", 1> , <"bat",1> , <"cat",1> then ChooseWord ( 1) will return "bat". Words in the group will be moved.
Let's see how ChooseWord moves the words in the group.
<"bat", 2> , <"act",1> , <"cat",1> => ChooseWord ( 1) => "act" => <"act", 2> , <"bat",2> , <"cat",1> =>
ChooseWord ( 2) => "cat". 


For more efficiency all the groups are stored in the tree. Classes Node and Leaf realise this tree. Each node contains pairs of digit and
pointer to the next node. Here digit means that all the groups after this node have codes with this digit on suitable place. Place of the digit
in the code is level of this node in the tree hierarchy. For example if we have codes 223, 225, 4, the tree will be like this.
Root has two pairs ( all the pairs are stored in the map). They are <2, first pointer to node>, <4, second pointer to node>.
After passing throw the first pointer we see another node with pair <2, third pointer to node>.
Passing throw the third pointer we will find node with pairs <3, Node*> and <5, Node*>.
All other pointers in this tree are Leaf* in fact. Each leaf contains pointer to the object of WordStorage class. So you can use 
WordStorage::Choose to get suitable word. Moving throw the tree we can quickly find group we need. If number of the groups is big searching 
the tree will be much faster than searching using Tree::_dataBase [code]. Of course these classes can be used as a library not only in this programme.

After work with the dictionary programme begin to parse the input string of digits spaces and stars. It is very simple after creating data structures.
If you give some file as an input programme will print resulting words. But you can also tape new words when programme works and it will parse 
them and print results. So it is simple analyser. If some data is incorrect there will be generated an exception. Then it will be caught and 
programme will ask you if you want to reenter the input string. To close the programme click cross on the top right corner of the window.


О программе.
Рассмотрим слова, находящиеся в словаре, и разобьём их на группы. Каждая группа состоит из слов с одним и тем же кодом.
Код - это последовательность цифр, которые необходимо набрать пользователю для получения нужного слова.
Например, код слова "cat" - 228.
Такие группы можно сгенерировать, вызвав функцию CreateDataBase (istream&), которая находится в классе Tree. 
Сначала слова в каждом WordStorage отсортированы в алватном порядке. Все полученные группы хранятся в map< Code, WordStorage> _dataBase 
в классе Tree. Здесь Code - это vector<unsigned int>. 
Итак, зная код слова и количество звёздочек, стоящих после него во входной строке, можно найти это слово примерно так:
string word = tree._dataBase [code].Choose ( number_of_stars).
Функция string WordStorage :: Choose ( unsigned int) увеличевает на единицу рейтинг соответствующего слова и передвигает его выше остальных 
слов с таким же рейтингом, не меняя при этом порядке остальных слов в группе.
Например, если у нас есть <"act", 1> , <"bat",1> , <"cat",1> то ChooseWord ( 1) вернёт "bat". Порядок слов в группе изменится.
Можно посмотреть как именно меняется порядок при соответствующих вызовах ChooseWord.
<"bat", 2> , <"act",1> , <"cat",1> => ChooseWord ( 1) => "act" => <"act", 2> , <"bat",2> , <"cat",1> =>
ChooseWord ( 2) => "cat". 

Для большей эффективности все группы хранятся в дереве. Оно реализовано с помощью классов Node и Leaf. Каждый узел содежит пары вида цифра-указатель на 
следующий узел (pair<unsigned int, Node*>). Здесь цифра означает, что у всех групп, достижимых через указатель из данной пары, в кодах на 
соответствующем месте будет ровно эта цифра. Место этой цифры в коде есть уровень узла в иерархии дерева ( у корня - ноль, у его потомков - 1, и т.д.).
Например, если у нас есть коды 223, 225, 4, дерево будет выглядеть следующим образом.
В корне две пары ( для хранения пар в узлах приминён map). Это <2,первый указатель на Node*>, <4, второй указатель>. 
Пройдя по первому указателю, обнаружим узел с одной парой <2, третий указатель>. 
Пройдя по третьему указателю, найдём пары <3, Node*>, <5, Node*>. 
Все прочие указатели в данном дереве на самом деле не Node*, а Leaf* ( Leaf - потомок Node). Каждый такой лист хранит указатель на WordStorage, 
так что оказавшись в Leaf*, можно вызывать ChooseWord. Поиск по такому дереву при известном коде слова гораздо быстрее поиска по map с 
помощью _dataBase [code].

После обработки словаря программа ( класс Parser) начинает разбирать входную строку, состоящую из цифр, пробелов и звёздочек. После создания 
соответствующих структур данных, парсинг становится совсем простым. Если подать программе на вход некоторый файл, программа просто напечатает результат 
в стандартный выходной поток. Но можно работать в режиме реального времени. При обнаружении в данных какой-либо ошибки, программа спросит пользователя, 
не попробовать ли другие данные или не завершить ли работу. Для закрытия программа нажмите крестик в правом верхнем углу окна.
*/
using namespace std;

typedef vector<unsigned int> Code;
//Этот класс хранит пары слово-встречаемость, для которых одинаков набор цифр, набираемых пользователем на телефоне.
//Например в один экземпляр этого класса следует положить act cat bat, а в другой tea tec veb.

class WordStorage  : public list < pair <string, unsigned int> >
{

public:
	string ChooseWord ( unsigned int count);//count - количество звёздочек после набора цифр во входном файле.

	void Add ( string word, unsigned int rating);
	void Log ();

protected:
	iterator GetMaxValue ();
	iterator GetMaxValue ( iterator);
};

void WordStorage :: Log ()
{

	for ( iterator cur = begin (); cur != end (); cur ++)
		cout << "(" << cur ->first << " ; " << cur ->second << ")  ";
}

void WordStorage ::Add ( string word, unsigned int rating)
{

	iterator cur = begin ();
	for ( ; cur != end () && cur -> first < word; cur ++);

	if ( cur == end ()) push_back ( pair <string,unsigned int> ( word, rating) );
	else
	{

		insert ( cur, pair <string,unsigned int> ( word, rating) );
	}
}

WordStorage::iterator WordStorage :: GetMaxValue ()
{

	iterator res = begin ();
	for ( iterator cur = begin (); cur != end (); cur ++)
		if ( cur -> second > res -> second) res = cur;//строгое неравенство даёт сразу же и первый результат по алфавитному порядку

	return res;
}

WordStorage::iterator WordStorage :: GetMaxValue ( iterator cur)
{

	iterator mem = cur;
	cur ++;
	for ( ; cur != end () && cur -> second != mem -> second; cur ++);

	if ( cur != end () && cur -> second == mem -> second) return cur;

	unsigned int up = mem ->second;
	iterator res = begin ();
	for ( ; res != end () && res ->second >= up; res ++);

	if ( res == end ()) return GetMaxValue ();

	for ( cur = begin (); cur != end (); cur ++)
		if ( res ->second < cur->second && res ->second < up && cur ->second < up) res = cur;

	return res;
}

string WordStorage :: ChooseWord ( unsigned int count)
{

	if ( size () == 1) { iterator it = begin (); it ->second ++; return it ->first;}

	iterator cur = GetMaxValue ();
	for ( unsigned int i = 0; i < count; i ++)
		cur = GetMaxValue ( cur);

	cur ->second += 1;
	string res = cur ->first;

	push_front ( pair<string, unsigned int> ( *cur));
	erase ( cur);

	return res;
}

class Node
{

public:

	void Destroy ();

	map < unsigned int, Node* > _children;

	virtual WordStorage* GetWordStorage () { return ( WordStorage*) NULL; }
	virtual void Log ();
	
	virtual ~Node () {}

	typedef map < unsigned int, Node* > :: iterator iter;
};

void Node :: Log ()
{

	cout << "Node " << this << " :";

	for ( iter cur = _children.begin (); cur != _children.end (); cur ++)
		cout << " ( " << cur ->first << "," << cur ->second << " )  ";

	cout << endl;

	for ( iter cur = _children.begin (); cur != _children.end (); cur ++)
		if ( cur ->second) cur ->second->Log ();

	cout << endl;
}

void Node :: Destroy ()
{

	for ( iter cur = _children.begin (); cur != _children.end (); cur ++)
	{

		if ( cur -> second != (Node*) NULL) cur->second->Destroy ();
		delete cur->second;
	}
}

class Leaf : public Node
{

public:

	Leaf ( Code code, WordStorage* wordStorage): _code ( code), _wordStorage ( wordStorage) {}

	virtual void Log ();
	virtual WordStorage* GetWordStorage () { return _wordStorage; }

	virtual ~Leaf () {}

	Code _code;
	WordStorage* _wordStorage;
};

void Leaf :: Log ()
{

	cout << "Leaf " << this << " Code = ";

	for ( int i = 0; i < _code.size (); i ++)
		cout << _code [i];

	cout << endl;
}

class Tree
{

public:
	void Create ( istream& is);

	typedef map<vector<unsigned int>,WordStorage> DataBase;
	typedef map<vector<unsigned int>,WordStorage>::iterator iterDB;

	void Log ();

	DataBase _dataBase;

	Node _root;

	~Tree ();

protected:

	void CreateDataBase ( istream& is);
	void CreateTree ();
	int SetNext ( DataBase :: iterator cur);
	void PutNewBranch ( Code code, Node* node, unsigned int count);
	void PutLeafInsteadOfNode ( Code code, Node* node, Node* node1);
	bool IsThereDigit ( unsigned int digit, Node* parent, Node** node);
};

void Tree :: Log ()
{

	cout << "Tree :: Log\n";
	for ( iterDB cur = _dataBase.begin (); cur != _dataBase.end (); cur ++)
	{

		cout << "code = '";
		for ( int i = 0; i < cur ->first.size (); i ++)
			cout << cur ->first[i];
		cout << "'; words: \n";

		cur ->second.Log ();
		cout << endl;
	}
	cout << endl;

	cout << "nodes:\n";

	_root.Log ();

	cout << endl;
}

Tree :: ~Tree ()
{

	_root.Destroy ();
}

unsigned int GetCode ( char l)
{

	if ( l >= 'a' && l <= 'c') return 2;
	if ( l >= 'd' && l <= 'f') return 3;
	if ( l >= 'g' && l <= 'i') return 4;
	if ( l >= 'j' && l <= 'l') return 5;
	if ( l >= 'm' && l <= 'o') return 6;
	if ( l >= 'p' && l <= 's') return 7;
	if ( l >= 't' && l <= 'v') return 8;
	if ( l >= 'w' && l <= 'z') return 9;

	throw "GetCode(l) : there was error in the dictionary";

	return 0;
}

vector < unsigned int> GetCode ( string word)
{

	vector < unsigned int> code; 

	for ( unsigned int i = 0; i < word.size (); i ++)
		code.push_back ( GetCode ( word [i]));

	return code;
}

void Tree :: CreateTree ()
{

	for ( DataBase :: iterator cur = _dataBase.begin (); cur != _dataBase.end (); cur ++)
		SetNext ( cur);
}

void Tree :: PutNewBranch ( Code code, Node* node, unsigned int count)
{

	if ( node == (Node*) NULL) throw "NULL pointer in void Tree :: PutNewBranch ( Code code, Node* node, unsigned int count)";

	while ( count != code.size () - 1)
	{
		Node* ptr = new Node ();
		//if ( node == ( Node*) NULL) throw "not enough memory";
		node ->_children [code [count] ] = ptr;
		count ++;
		node = ptr;
	}

	node ->_children [code [count] ] = new Leaf ( code, &_dataBase [code]);
}

void Tree :: PutLeafInsteadOfNode ( Code code, Node* node, Node* parentNode)
{

	if ( parentNode == (Node*) NULL || node == ( Node*) NULL) 
		throw "NULL pointer in void Tree :: PutLeafInsteadOfNode ( Code code, Node* node, Node* parentNode)";

	if ( node -> GetWordStorage ()) throw "there're two equal words in the dictionary";

	Leaf* ptr = new Leaf ( code, & _dataBase [ code]);
	ptr ->_children = node ->_children;

	node ->_children = map<unsigned int, Node*> ();
	delete node;
	node = 0;

	parentNode ->_children [code [code.size () - 1]] = ptr;
}



bool Tree :: IsThereDigit ( unsigned int digit, Node* parent, Node** node)
{

	if ( parent == (Node*)NULL || node == (Node**)NULL || *node == (Node*)NULL) 
		throw "null pointer - bool Tree :: IsThereDigit ( unsigned int digit, Node* parent, Node** node)";

	Node::iter res = parent->_children.find ( digit);

	*node = (Node*) NULL;
	if ( res != parent->_children.end ()) *node = res ->second;
	
	return res != parent->_children.end ();
}

int Tree :: SetNext ( DataBase :: iterator cur)
{

	Code code = cur ->first;
	unsigned int count = 0;

	if ( _root._children.empty ()) PutNewBranch ( code, &_root, 0);
	else
	{

		Node *node = &_root, *parent = &_root;
		while ( IsThereDigit ( code [count], parent, &node) )
		{
			if ( count == code.size () - 1)
			{
				 PutLeafInsteadOfNode ( code, node, parent);
			     return 1;
			}

			count ++;
			parent = node;
		}

		//node is undefined here
		PutNewBranch ( code, parent, count);
		return 0;
	}

	return -1;
}

/*
void Tree :: SetNext ( DataBase :: iterator cur)
{

	Code code = cur ->first;
	unsigned int count = 0;

	if ( _root._children.empty ()) PutNewBranch ( code, &_root, 0);
	else
	{
		Node *node = &_root, *node2 = &_root;
		bool wasNewBranch = false;
		while ( !node->_children.empty ())
		{
			Node::iter res = node->_children.find ( code [count]);

			if ( res != node->_children.end ())
			{
				
				node2 = node;
				node = res -> second;

				if ( count != code.size () - 1) count ++;
				else PutLeafInsteadOfNode ( code, node, node2);
			}
			else 
			{
				PutNewBranch ( code, node, count);
				wasNewBranch = true;
				break;
			}
		}

		if ( ! wasNewBranch)
		{
			if ( count == code.size () - 1)
				//PutLeafInsteadOfNode ( code, node, node2);
			//else
				PutNewBranch ( code, node, count);
		}	
	}
}
*/
void Tree :: Create ( istream& is)
{

	CreateDataBase ( is);
	CreateTree ();
}

void Tree :: CreateDataBase ( istream& is)
{

	_dataBase = DataBase ();
	unsigned int number = 0;

	is >> number;
	if ( number == 0) throw "there must be number of words in the dictionary.";
	

	string word;
	unsigned int rating = 0;
	vector<unsigned int> code;

	for ( unsigned int i = 0; i < number; i ++)
	{

		is >> word >> rating;

		code = GetCode ( word);

		_dataBase [code].Add ( word, rating);
	}
}



class Parser
{

public:
	bool Parse ();
	bool CreateTree ();

	Parser ( istream& is);

protected:
	void CheckSpace ();
	int CountStar ();
	void SetMeaningOfOne ();
	bool IsNumberNotOne ( char c);

	bool ErrorReaction ();

	Tree _tree;
	istream& _is;
	char _next, _cur;
	map<unsigned int, char> _oneIntoSymbol;
};

Parser :: Parser ( istream& is): 
	_is ( is),
	_next ( 0),
	_cur ( 0)
	{

		SetMeaningOfOne ();
	}

void Parser :: SetMeaningOfOne ()
{

	_oneIntoSymbol = map<unsigned int, char> ();
	_oneIntoSymbol [0] = '.';
	_oneIntoSymbol [1] = ',';
	_oneIntoSymbol [2] = '?';
}

int Parser :: CountStar () 
{
	int count = 0;
	for ( ; _next == '*'; count ++)
	{

		if ( _is.eof ()) break;
		_is.get ( _next);
	}

	return count;
}


bool Parser :: IsNumberNotOne ( char c)
{

	return c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9';
}

void Parser :: CheckSpace ()
{

	if ( _cur == ' ')
	{
		cout << ' ';
		while ( _next == ' ' && !_is.eof ()) _is.get ( _next);
		_cur = _next;
		_is.get ( _next);
	}
}


bool Parser :: ErrorReaction ()
{

	cout << "would you like to retry?(y/n)" << endl;
	
	string answer;
	
	cin >> answer;
	
	for ( ; answer != "y" && answer != "n"; cin >> answer)
		cout << "would you like to retry?(y/n)" << endl;
	
	return  answer == "y";
}

bool Parser :: CreateTree ()
{

	_tree._root.Destroy ();
	_tree = Tree ();

	try
	{

		_tree.Create ( _is);
	}
	catch ( const char* str)
	{
		cout << str << endl;
		cout << "can't create data base" << endl;

		return ErrorReaction () && CreateTree ();
	}
	catch ( ...)
	{
		throw;
	}

	return true;
}

bool Parser :: Parse ()
{
	
	try
	{
		_cur = 0, _next = 0;
		_is >> _cur;
		_is.get ( _next);

		while ( !_is.eof ()) 
		{

			if ( _cur == '1')
			{

				int count = CountStar ();
				count = count % _oneIntoSymbol.size ();

				cout << _oneIntoSymbol [count];
			}

			else if ( _cur == ' ')
			{
				CheckSpace ();
				continue;
			}

			else if ( IsNumberNotOne ( _cur))
			{

				Node::iter end = _tree._root._children.end   ();
				Node::iter res = _tree._root._children.find ( (unsigned int)(_cur - '0'));
				Node:: iter res2 = res;
				if ( res == end) throw "there is no such word in the dictionary";
					
				while ( _next > '1' && _next <= '9')
				{
					
					res2 = res ->second ->_children.find ( (unsigned int) (_next - '0') );
					end = res ->second ->_children.end ();
					if ( res2 == end) throw "there is no such word in the dictionary";

					res = res2;

					if ( _is.eof ()) break;
					_is.get ( _next);
				}

				
				//if ( res ->second == (Node*)NULL || res ->second ->GetWordStorage () == (WordStorage*) NULL)
				//	throw "there is no such word in the dictionary";

				//Leaf* leaf = (Leaf*) res ->second;
				
				int count = CountStar ();

				string word = res->second ->GetWordStorage () ->ChooseWord ( count);
				cout << word;
			}
			else if ( _cur != '\n') throw "bad input string content\n";

			_cur = _next;
			_is.get ( _next);
		}

	}
	catch ( const char* str)
	{
		cout << str << endl;
		cout << "can't parse the input string" << endl;

		return ErrorReaction () && Parse ();
	}
	catch ( ...)
	{
		throw;
	}
	return true;
}

int main ()
{

	//istream is ( "example.txt");
	
	Parser parser ( cin);

	parser.CreateTree () ? parser.Parse () : cout << "can't start to parse the string because data base wasn't created\n";

	int a = 0;
	cin >> a;
	//	tree.Log ();
	return 0;
}
