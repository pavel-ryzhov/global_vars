#define f_in "input.txt"
#define f_out "output.txt"
#define f_pic "pic.txt"
#define weight_file "learn.txt"
#define max_n 200
#define max_m 800
#define max_obj 100
#define max_neuro 1000
#define d_n 64
#define d_m 48
#define window_n 4
#define window_m 3
#define destroy_rate 0.7
#define signs_n 10

#include <iostream>
#include <algorithm>
#include <fstream>
#include <string>
#include <vector>
#include <set>

using namespace std;
    
    const int dir[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
    const int s_teta = (window_n * window_m) / 2;
    const int a_teta = 0;
    const int  s_elem = (d_n / window_n) * (d_m / window_m);
    const int a_elem = s_elem;
    const int weight[a_elem][signs_n] = {
{7,9,0,25,0,30,0,80,0,1},
{8,18,12,39,0,37,4,105,3,7},
{9,18,14,69,1,51,5,93,14,26},
{16,33,46,76,19,89,20,93,32,30},
{41,38,66,96,25,94,47,94,57,66},
{78,48,86,98,46,72,60,65,66,87},
{77,65,86,96,53,66,57,68,79,76},
{73,63,91,102,55,90,53,68,85,84},
{86,77,96,103,60,91,50,85,93,86},
{93,91,103,84,66,91,55,82,103,94},
{100,83,101,93,71,99,101,82,113,117},
{59,91,65,87,73,91,100,80,90,73},
{31,106,44,60,72,93,69,81,54,32},
{14,86,32,71,65,101,65,81,32,31},
{7,93,11,62,66,97,59,102,25,43},
{0,82,0,30,50,72,50,80,13,15},
{17,37,24,46,0,31,22,67,13,17},
{27,44,47,58,0,43,23,86,35,32},
{54,60,75,84,22,68,32,89,51,66},
{72,60,88,83,23,93,58,88,81,85},
{73,74,84,81,33,93,62,87,87,71},
{86,79,86,94,55,79,29,87,79,61},
{79,74,84,94,56,88,55,86,78,64},
{67,91,86,101,62,94,54,86,81,105},
{74,105,92,103,78,92,71,86,82,105},
{70,119,100,108,78,99,74,108,93,111},
{80,121,105,108,75,108,84,117,93,102},
{95,110,108,116,79,112,101,118,100,112},
{99,117,108,125,86,119,106,117,85,113},
{56,95,75,125,76,117,67,123,85,88},
{30,93,46,55,57,102,60,123,60,66},
{10,72,22,20,49,35,11,109,25,51},
{27,48,47,40,0,38,23,51,25,34},
{53,58,84,64,4,58,32,78,71,87},
{79,58,80,76,23,87,61,79,82,83},
{72,54,79,60,58,102,66,74,89,50},
{87,57,80,73,69,78,71,71,101,66},
{82,79,79,83,60,71,57,71,91,76},
{77,92,72,62,64,91,54,70,69,68},
{56,105,72,59,80,85,66,68,43,59},
{44,107,74,64,80,73,64,90,43,58},
{63,116,77,86,77,77,70,90,42,72},
{69,109,95,91,77,69,88,108,46,91},
{72,118,93,107,86,73,68,116,63,101},
{96,117,99,121,95,69,74,123,86,115},
{102,94,98,112,75,65,54,130,99,124},
{67,82,74,78,58,38,51,100,83,79},
{25,62,39,53,39,15,22,27,49,48},
{31,44,78,47,0,34,30,39,33,70},
{79,54,80,62,4,66,61,52,65,82},
{93,67,80,63,57,98,100,49,71,61},
{88,84,74,61,69,99,77,46,88,76},
{85,78,66,59,78,93,72,42,92,79},
{81,92,66,56,63,84,61,42,71,62},
{59,86,59,59,76,104,56,44,45,52},
{41,96,63,63,83,92,64,72,27,39},
{38,99,65,82,75,87,65,76,28,46},
{44,104,69,87,79,67,74,100,36,63},
{64,114,69,81,85,64,81,103,59,70},
{69,112,76,87,84,58,57,120,77,78},
{80,115,98,89,86,38,56,128,83,102},
{97,84,107,80,75,33,51,108,105,136},
{99,62,103,71,47,25,50,83,83,114},
{40,55,57,42,39,14,32,24,64,52},
{73,58,69,22,0,31,34,42,36,72},
{81,56,72,38,9,69,100,41,84,72},
{95,61,73,64,66,90,100,40,90,95},
{88,67,60,55,86,90,81,41,89,94},
{89,63,56,52,65,51,72,18,77,66},
{71,53,58,56,75,87,61,17,76,44},
{58,51,61,68,72,61,69,18,54,41},
{32,86,53,75,68,54,61,67,39,32},
{35,88,57,85,76,72,66,71,28,43},
{43,105,62,96,88,75,66,99,37,70},
{51,112,73,95,81,81,51,110,61,75},
{67,100,92,83,88,75,56,103,86,94},
{79,104,107,77,91,54,55,91,104,95},
{85,84,108,83,67,42,17,85,101,113},
{102,61,102,63,48,18,31,53,77,102},
{75,54,81,40,39,8,15,8,45,72},
{79,29,58,8,36,32,95,3,46,79},
{95,61,68,15,45,69,100,24,68,97},
{96,61,66,43,75,70,98,24,89,112},
{92,43,51,46,86,75,76,2,82,87},
{76,43,47,38,76,75,76,3,87,67},
{70,47,47,71,69,101,82,2,74,37},
{51,60,44,69,62,79,78,39,48,37},
{31,76,34,87,65,84,73,58,42,51},
{34,83,40,96,72,92,65,71,58,55},
{43,109,78,95,82,76,55,76,76,66},
{49,101,82,86,94,76,58,103,82,87},
{66,100,90,77,101,70,58,91,85,92},
{78,105,96,86,92,41,53,81,83,101},
{85,63,99,85,65,33,12,74,76,109},
{98,58,91,48,48,31,22,21,54,110},
{100,51,72,26,37,18,34,8,28,94},
{94,35,44,1,52,32,100,0,30,98},
{97,41,45,16,74,60,104,0,57,91},
{100,41,43,28,87,59,98,0,75,107},
{90,36,17,31,96,72,77,0,89,82},
{76,31,14,66,71,66,73,2,78,55},
{63,51,14,71,69,99,92,22,85,67},
{51,62,26,93,56,81,89,59,73,59},
{15,77,50,91,71,61,87,68,68,61},
{18,82,67,77,61,72,72,89,74,62},
{43,97,86,81,91,96,77,97,81,93},
{49,101,85,86,114,115,73,86,85,86},
{68,101,86,89,120,109,67,86,91,98},
{77,84,87,70,91,82,68,76,69,96},
{86,63,97,57,63,59,53,52,60,110},
{98,52,72,33,46,45,46,8,41,107},
{97,51,55,5,37,33,6,0,1,82},
{95,24,40,28,57,40,101,0,24,101},
{98,30,24,28,81,68,98,0,50,89},
{100,30,23,27,95,56,101,0,69,94},
{75,31,22,49,106,60,88,17,86,90},
{68,41,13,53,75,58,93,22,98,75},
{63,63,18,71,66,52,95,45,96,73},
{35,63,45,78,32,49,86,81,93,48},
{15,76,81,84,71,55,62,88,77,62},
{18,80,87,88,74,70,66,76,89,82},
{43,99,80,92,95,97,70,78,81,91},
{49,98,85,88,125,120,99,88,92,80},
{68,100,85,67,122,130,105,84,89,93},
{82,84,90,75,93,106,108,71,94,102},
{86,63,69,69,73,95,51,19,47,109},
{98,52,48,29,58,64,37,8,32,87},
{97,51,31,11,51,35,18,0,7,82},
{98,24,0,4,49,28,104,0,37,54},
{102,30,23,4,86,45,108,0,53,74},
{87,30,28,14,100,33,108,17,87,68},
{75,40,39,29,98,31,90,22,88,61},
{68,53,48,40,67,26,87,27,98,54},
{63,63,55,35,57,28,77,78,95,63},
{51,63,68,49,62,21,58,88,83,56},
{15,67,90,48,75,30,47,68,66,81},
{18,80,84,53,75,73,46,76,67,93},
{42,104,83,74,94,96,56,86,68,63},
{50,98,81,83,126,106,72,84,74,72},
{68,79,81,118,115,94,77,75,99,84},
{82,84,56,105,93,110,103,69,80,84},
{86,63,47,88,75,102,74,8,66,95},
{98,51,31,59,58,93,74,0,55,82},
{94,51,28,29,47,71,37,0,39,81},
{102,24,0,2,80,33,105,0,59,17},
{102,30,14,14,91,25,108,0,81,41},
{87,40,41,24,95,12,107,23,91,50},
{71,43,57,27,77,12,103,27,83,31},
{67,53,55,43,56,11,83,62,81,29},
{63,64,69,40,55,11,56,87,74,30},
{52,53,102,44,55,21,49,66,53,64},
{31,76,79,45,75,52,41,55,42,60},
{34,86,70,47,77,66,40,78,46,46},
{42,104,64,64,96,50,47,82,42,55},
{51,88,75,86,117,84,66,83,53,74},
{73,79,51,86,105,104,73,72,76,79},
{84,84,46,96,87,107,97,44,78,85},
{86,63,41,108,72,92,72,0,81,82},
{93,51,28,97,60,93,75,0,74,82},
{93,46,0,84,51,86,64,0,68,79},
{102,24,20,21,51,38,106,0,75,11},
{90,30,22,36,59,19,107,23,96,21},
{87,41,35,44,61,19,122,39,99,31},
{71,53,46,38,31,22,84,43,93,31},
{67,54,61,45,31,19,61,84,61,35},
{63,64,87,44,30,19,48,82,44,33},
{52,60,72,52,41,50,46,63,43,58},
{31,76,62,59,88,58,53,77,38,41},
{34,85,63,61,85,42,52,83,44,43},
{42,94,71,48,101,55,63,85,52,72},
{54,78,65,70,112,85,82,80,59,76},
{74,79,56,86,101,105,85,66,62,72},
{84,84,53,89,84,85,98,10,65,84},
{81,53,46,110,69,93,88,0,83,82},
{94,51,35,109,57,88,84,0,75,80},
{75,45,18,106,51,87,81,0,74,72},
{80,24,20,59,49,69,101,17,92,32},
{102,41,39,59,51,49,122,37,102,39},
{86,52,48,67,43,46,116,43,106,38},
{71,53,50,57,38,40,84,64,79,38},
{68,54,76,74,38,60,77,79,50,37},
{64,55,76,69,37,52,65,65,36,59},
{52,61,64,61,46,51,47,91,21,57},
{32,75,64,44,93,40,41,84,23,62},
{35,81,67,50,110,67,39,82,51,40},
{46,94,68,52,119,70,52,85,52,65},
{71,77,70,75,109,83,67,75,61,60},
{76,79,68,91,96,93,70,55,76,64},
{80,84,53,93,98,85,83,0,65,74},
{68,48,53,107,100,87,88,0,76,80},
{79,46,39,105,82,88,85,0,76,79},
{42,45,38,97,70,85,75,0,71,65},
{53,33,35,63,17,85,66,23,114,44},
{90,52,51,67,16,75,127,44,111,54},
{86,52,59,79,7,62,117,44,105,54},
{73,54,67,77,37,72,79,69,65,42},
{70,45,78,74,38,62,66,81,50,52},
{63,54,87,53,51,31,54,70,27,69},
{54,62,75,44,52,41,49,88,29,74},
{35,80,73,49,65,60,42,85,34,49},
{57,81,82,55,78,66,41,82,40,49},
{65,84,76,68,113,75,56,82,58,54},
{73,77,79,82,106,77,68,72,74,58},
{70,79,64,90,96,79,84,10,80,67},
{68,77,66,94,103,77,91,0,60,74},
{80,48,48,105,66,88,81,0,75,79},
{77,46,52,101,57,86,84,0,71,48},
{30,45,50,73,49,57,39,0,55,31},
{44,47,52,71,3,72,50,40,85,42},
{68,65,64,93,3,112,71,44,112,77},
{89,66,84,88,3,88,88,65,95,78},
{73,67,104,79,33,78,95,82,74,47},
{72,57,100,85,42,79,74,64,53,82},
{66,77,104,66,49,70,60,90,44,68},
{72,73,95,60,50,58,59,97,47,55},
{66,76,94,64,75,56,49,86,49,44},
{65,71,99,64,77,69,53,83,60,52},
{67,83,88,83,88,74,62,81,62,67},
{71,77,88,82,102,69,97,62,69,74},
{60,86,81,85,95,86,92,10,71,70},
{76,84,82,98,75,78,90,0,63,71},
{77,61,75,100,63,85,62,0,71,68},
{31,59,76,62,52,55,40,0,66,45},
{17,57,68,42,45,21,18,0,34,26},
{29,48,57,57,0,43,41,30,49,8},
{45,75,99,92,0,86,50,64,83,50},
{54,75,108,110,0,120,65,68,101,80},
{98,78,105,103,30,125,93,80,109,89},
{94,79,101,90,31,87,81,90,88,80},
{90,79,101,87,46,79,83,88,87,66},
{86,68,97,79,46,56,77,95,86,58},
{82,75,98,75,78,68,84,83,87,64},
{59,71,107,79,78,66,83,82,73,68},
{55,85,105,80,89,65,64,68,74,60},
{60,80,107,90,98,72,75,36,52,65},
{74,97,102,93,95,84,90,2,70,70},
{55,97,102,63,77,72,100,2,71,42},
{32,71,94,51,61,53,37,0,51,45},
{17,68,83,26,49,27,17,0,33,27},
{7,67,67,5,43,10,5,0,7,8},
{0,57,70,34,0,27,6,31,9,0},
{2,69,78,49,0,53,10,51,17,12},
{15,77,77,55,0,42,29,78,50,12},
{27,71,77,76,30,28,37,75,71,41},
{37,61,69,78,33,64,35,57,71,70},
{56,60,65,82,43,66,45,53,80,59},
{69,70,60,74,68,76,53,80,83,89},
{78,70,61,73,72,87,70,79,68,76},
{82,66,69,62,73,85,106,73,68,73},
{63,70,73,52,78,62,74,62,54,53},
{28,75,73,27,94,43,67,12,39,10},
{9,68,72,13,97,23,51,2,20,10},
{8,80,67,10,77,5,49,2,11,7},
{0,76,70,4,65,1,38,0,7,6},
{0,75,74,0,62,0,38,0,0,0},
{0,86,70,0,57,0,34,0,0,0}};
    
struct component
{
    int x1, x2;
    int y1, y2;
    int l;
    set<int> colors;
    bool valid;
};    
    
    
    int n, m;
    int been[max_n][max_m];
    string pict[max_n], number[max_n];
    int number_n, number_m;
    int signal[max_neuro];
    string ans;
    bool decide;
    
void neuro_view()
{
    int i, j, adr;
    for (i = 0; i < a_elem; i++)
    {
        signal[i] = 0;
    }    

    for (i = 0; i < d_n; i++)
    {
        for (j = 0; j < d_m; j++)
        {
            if (number[i][j] != '.')
            {
                adr = (i/window_n)*(d_m/window_m) + (j/window_m);
                signal[adr]++;
            }
        }
    }                
    for (i = 0; i < s_elem; i++)
    {
        if (signal[i] > s_teta)
        {
            signal[i] = 1;
        }
        else
        {
            signal[i] = 0;
        }
    }
}    

void neuro_read()
{
    int i, j;
    ifstream in;
    in.open(weight_file);
    for (i = 0; i < a_elem; i++)
    {
        for (j = 0; j < signs_n; j++)
        {
//            in >> weight[i][j];
        }
    }        
    in.close();
}    

void neuro_learn(int answer)
{
    int i, j;
    int ans_signal[signs_n];
    bool need2learn = false;
    for (j = 0; j < signs_n; j++)
    {
        ans_signal[j] = 0;
    }    
    
    for (i = 0; i < a_elem; i++)
    {
        if (signal[i] > a_teta)
        {
            for (j = 0; j < signs_n; j++)
            {
                ans_signal[j] += (weight[i][j] * signal[i]);
            }
        }    
    }    
    
    for (j = 0; j < signs_n; j++)
    {
        if (j != answer)
        {
            if (ans_signal[answer] <= ans_signal[j])
            {
                need2learn = true;
                break;
            }    
        }    
    }    
    if (need2learn)
    {
        for (i = 0; i < a_elem; i++)
        {
            if (signal[i] > a_teta)
            {
//                weight[i][answer]++;
            }
        }    
    }    
}    

int neuro_recogn()
{
    int i, j, answer;
    int ans_signal[signs_n];
    for (j = 0; j < signs_n; j++)
    {
        ans_signal[j] = 0;
    }    
    
    for (i = 0; i < a_elem; i++)
    {
        if (signal[i] > a_teta)
        {
            for (j = 0; j < signs_n; j++)
            {
                ans_signal[j] += (weight[i][j] * signal[i]);
            }
        }    
    }    
    
    answer = 0;
    for (i = 1; i < 10; i++)
    {
        if (ans_signal[i] > ans_signal[answer])
        {
            answer = i;
        }
    }
    return answer;
}    


void neuro_write()
{
    ofstream out;    
    int i, j;
    out.open(weight_file);
    for (i = 0; i < a_elem; i++)
    {
        for (j = 0; j < signs_n; j++)
        {
            out << weight[i][j] << ' ';
        }
        out << endl;
    }        
    out.close();
}    

void data_print(string ps[], int pn)
{
    ofstream out(f_pic, ios::app);    
    int i;
    for (i = 0; i < pn; i++)
    {
        out << ps[i] << endl;
    }
}              

void data_read()
{
//    ifstream in;
//    in.open(f_in);
    n = 0; m = 0;    
    while (!cin.eof())
    {
        cin >> pict[n];
        if ((pict[n][0] != '.') && (pict[n][0] != '%')
        && (pict[n][0] != '#') && (pict[n][0] != '@'))
        {
            break;
        }
        else
        {
            n++;
        }    
    }    
    m = pict[0].length();
//    in.close();
}

void data_answer_in()
{
    ifstream in;    
    in.open(f_out);
    in >> ans;
    in.close();
}    

void data_answer_out()
{
//    ofstream out;
//    out.open(f_out);
    cout << ans;
//    out.close();
}    
    
void data_clear_columns()
{
    int i, j, sum;
    for (j = 0; j < m; j++)
    {
        sum = 0;
        for (i = 0; i < n; i++)
        {
            if (pict[i][j] == '@') {sum++;}
//            if (pict[i][j] == '#') {sum++;}
        }
        if (sum == 0)
        {
            for (i = 0; i < n; i++)
            {
                pict[i][j] = '.';
            }
        }
    }
}                    

void data_init(string s[], int x, int y)
{
    int i, j;
    for (i = 0; i < x; i++)
    {
        s[i] = "";
        for (j = 0; j < y; j++)
        {
            s[i] += '.';
        }
    }
}            

void data_resize()
{
    int i, j, x, s, p;
    int step, pen;
    string tmp[max_n];

//resize columns || (number_n, number_m) -> (d_n, number_m)
    data_init(tmp, d_n, d_m);
    s = d_n; p = 0;
    for (i = 0; i < number_n; i++)
    {
        for (x = 0; x < (s / number_n); x++)
        {
            for (j = 0; j < number_m; j++)
            {
                tmp[p][j] = number[i][j]; 
            }
            p++;
        }   
        s = (s % number_n) + d_n;
    }     
    
//resize strings = (d_n, number_m) -> (d_n, d_m)    
    data_init(number, d_n, d_m);
    s = d_m; p = 0;
    for (j = 0; j < number_m; j++)
    {
        for (x = 0; x < (s / number_m); x++)
        {
            for (i = 0; i < d_n; i++)
            {
                number[i][p] = tmp[i][j]; 
            }
            p++;
        }   
        s = (s % number_m) + d_m;
    }     
}    

component bfs(int x, int y, int color_comp, int color_waypoint, set<char> symb_waypoint)
{
    component dim;
    int stek[max_n*max_m][2];
    int begin, end, a, b, u, i, j;
    begin = 0;
    end = 1;
    stek[0][0] = x;
    stek[0][1] = y;
    been[x][y] = color_comp;
    //1 - verh, 2 - pravo, 3 - niz, 4 - levo
    dim.l = 0;
    dim.x1 = x;
    dim.y1 = y;
    dim.x2 = x;
    dim.y2 = y;
    dim.valid = true;
    dim.colors.insert(color_comp);
    while (begin < end)
    {
        dim.l++;
        a = stek[begin][0];
        b = stek[begin][1];
        if (dim.x1 > a) {dim.x1 = a;}
        if (dim.y2 < b) {dim.y2 = b;}
        if (dim.x2 < a) {dim.x2 = a;}
        if (dim.y1 > b) {dim.y1 = b;}     
        for (u = 0; u < 8; u++)
        {
            i = a + dir[u][0];
            j = b + dir[u][1];
            if ((i >= 0) && (i < n) && (j >= 0) && (j < m))
            {
                if (been[i][j] == color_waypoint)
                {
                    if (symb_waypoint.find(pict[i][j]) != symb_waypoint.end()) 
                    {
                        stek[end][0] = i;
                        stek[end][1] = j;
                        been[i][j] = color_comp;
                        end++;
                    }    
                }    
            }    
        }
        begin++;    
    }    
    return dim;
}    

bool number_erase(component v, int min_height)
{
    if (v.l < (destroy_rate*n*m / 100))
    {
        return true;
    }
    if ((v.x2 - v.x1) < (2 * min_height/3 - 1))
    {
        return true;
    }    
    return false;
}    

void number_recognize(component v)
{
    int i, j;
    if (number_erase(v, 0))
    {
        return;
    }    
    
    for (i = v.x1; i <= v.x2; i++)
    {
        number[i - v.x1] = "";
        for (j = v.y1; j <= v.y2; j++)
        {
            if (v.colors.find(been[i][j]) != v.colors.end())
            {
                number[i - v.x1] += '@';
            }
            else
            {
                number[i - v.x1] += '.';                        
            }    
        }
    }    
    number_n = v.x2 - v.x1 + 1;
    number_m = v.y2 - v.y1 + 1;
    data_resize();
//    neuro_read();
    neuro_view();
    if (decide)
    {
        neuro_learn(ans[0] - '0');
        ans.erase(0, 1);
        neuro_write();                
    }    
    else
    {
        ans += (neuro_recogn() + '0');
    }    
}    

void predproc()
{
    int i, j, k;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
        {
            been[i][j] = 0;
        }
    }        
    component dim[max_obj];
    int komp, color;
    set<char> symb_waypoint;
    symb_waypoint.clear();
    symb_waypoint.insert('@');
    symb_waypoint.insert('%');
    symb_waypoint.insert('#');
    komp = 0;
    
    data_clear_columns();    
    for (j = 0; j < m; j++)
    {
        for (i = 0; i < n; i++)    
        {
            if ((symb_waypoint.find(pict[i][j]) != symb_waypoint.end()) && (been[i][j] == 0))
            {
                komp++;                
                dim[komp] = bfs(i, j, komp, 0, symb_waypoint);
            }
        }
    }
    
    int mid_height_comp = 0;
    for (k = 1; k <= komp; k++)
    {
        mid_height_comp += dim[k].x2 - dim[k].x1;
    }
    mid_height_comp /= komp;    
   
    for (k = 1; k <= komp; k++)
    {
        if (number_erase(dim[k], mid_height_comp))
        {
                dim[k].valid = false;
        }    
    }    
/*    
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
        {
            if (pict[i][j] != '.')
            {
                if (dim[been[i][j]][5] == 1)
                {
                    pict[i][j] = '.';
                }    
            }
        }
    }
*/
    vector<component> store;
    component temp;
    color = 0;
    symb_waypoint.erase('%');
    symb_waypoint.erase('#');    
    bool bad_cut;
    for (k = 1; k <= komp; k++)
    {
        if (dim[k].valid)
        {
            bad_cut = false;
            store.clear();
            for (i = dim[k].x1; i <= dim[k].x2; i++)
            {
                for (j = dim[k].y1; j <= dim[k].y2; j++)
                {
                    if ((symb_waypoint.find(pict[i][j]) != symb_waypoint.end()) && (been[i][j] == k))
                    {
                        color--;
                        dim[k].colors.insert(color);                        
                        temp = bfs(i, j, color, k, symb_waypoint);
                        if (number_erase(temp, dim[k].x2 - dim[k].x1))
                        {
                            bad_cut = true;
                        }    
                        else
                        {
                            store.push_back(temp);
                        }    
                    }    
                    if (bad_cut) {break;}
                }    
                if (bad_cut) {break;}
            }    
            if ((!bad_cut) && (store.size() > 1))
            {
                for (i = 0; i < store.size(); i++)
                {
                    number_recognize(store[i]);
                }    
            }    
            else
            {
                number_recognize(dim[k]);
            }    
        }
    }        
}    

int main()
{
    // 1 - obu4enie, 0 - raspoznavanie
    decide = 0;
    data_read();
    if (decide)
    {
        data_answer_in();
    }    
    else
    {
        ans = "";
    }    
    predproc();
    if (!decide)
    {
        data_answer_out();
    }    
    return 0;
}
    
    
