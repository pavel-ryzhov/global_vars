#include <iostream>
#include <string>
#include <vector>
#include <map>

using namespace std;

//структура MYWORD представляет слово
struct MYWORD
{
	MYWORD(){};
	string str; //само слово
	int freq; //текущая частота встречаемости
};

int main()
{
	//весь словарь разбит на двадцать частей. В каждой части хранятся слова конкретной длины. Каждая часть является ассоциативным массивом(map в STL).
	//ключ - это последовательность "нажатых на телефоне кнопок" (последовательность цифр). 
	//значение - это упорядоченный вектор подходящих данному ключу слов.
	//на самом деле, не слов, а указателей на слова. Вместо слов в векторах хранятся указатели на эти слова для более быстрых операций с изменением порадка следования и тд.
	//Далее в коментарих буду для краткости писать "слово", имея ввиду "указатель на слово").
	map< vector<int> , vector<MYWORD*> > Dict[20];

	//в позиции [буква - 'a'] стоит номер соответствующей кнопки
	//           a b c  d e f  g h i  j k l  m n o  p q r s  t u v  w x y z
	int mas[] = {2,2,2, 3,3,3, 4,4,4, 5,5,5, 6,6,6, 7,7,7,7, 8,8,8, 9,9,9,9};

	//temp
	int N;
	MYWORD *w;

	cin>>N; // узнаем количество слов в словаре
	for (int i = 0; i<N; i++) //и все их заносим в словарь
	{
		MYWORD *w = new MYWORD; //резервируем память для нового слова
		cin>>w->str>>w->freq; //считываем слово и его частоту
		
		unsigned int len = w->str.length(); // len = длина слова
		vector<int> vi; //вектор для последовательности кнопок, соответствующей данному слову
		for (unsigned int i = 0; i < len; i++) //пробегаем по слову
		{
			vi.push_back(mas[w->str[i] - 'a']); //и добавляем в vi номер кнопки, соответствующей очередной букве слова
		}

		//пытаемся найти в той части словаря, которая хранит слова длины len, элемент, ключ которого совпадает с vi. 
		map< vector<int>  ,  vector<MYWORD*>  >::iterator mp = Dict[len-1].find(vi);
		if (mp==Dict[len-1].end()) //если ничего не нашли, значит в словаре еще не было слов с такой последовательностью нажатий кнопок
		{
			vector<MYWORD*> vwTemp;
			vwTemp.push_back(w);
			Dict[len-1].insert(pair< vector<int>  , vector<MYWORD*>  > (vi, vwTemp)); //добавляем в карту новый элемент
		}
		else //удалось найти. mp->second - это вектор слов с такой же последовательность кнопок. в этот вектор и надо добавить новое слово
		{
			vector<MYWORD*>::iterator iwt = mp->second.end(); //устанавливаем итератор на конец
			//ищем место, куда надо вставить новое слово. используем тот факт, что по условию слова вводятся в алфавитном порядке
			while ((iwt!=mp->second.begin())&&((*(iwt-1))->freq < w->freq)) iwt--;
			//теперь iwt указывает на слово, перед которым надо вставить новое слова
			mp->second.insert(iwt,w);
		}
	}
	//всё. словарь заполнен и структурирован для быстрого поиска нужного слова.

	//теперь обрабатываем ввод
	//inputword - последовательность цифр, вводимая пользователем
	vector<int> inputword;

	bool bTypingWord = true; //флаг. вводится сейчас слово или нет.
	char cSings[] = {'.',',','?'}; //используется для перебора знаков препинания
	getchar(); //считываем энтер после последнего слова словаря...
	char ch = getchar();
	while (ch != 10) //обрабатываем ввод
	{
		if ((ch>='2')&&(ch<='9')) //вводится слово
		{
			if (!bTypingWord) bTypingWord = true; //устанавливаем флаг ввода слова
			inputword.push_back(ch-'0'); //добавляем номер очередной нажатой кнопки
			ch = getchar();
		}
		if ((ch==' ')||(ch=='1')||(ch=='*')||(ch==10))
		{
			if (bTypingWord) //если до этого вводилось слово
			{
				bTypingWord = false; //сбрасываем флаг ввода слова

				//в данный момент в inpurword содержится последовательность номеров "нажатых на телефоне" кнопок.
				//теперь надо найти соответствующие слова в словаре.
				//ищем в той части словаря, в которой хранятся слова такой же длины, как и количество нажатых кнопок
				map< vector<int>  ,  vector<MYWORD*>  >::iterator mp = Dict[inputword.size()-1].find(inputword); 

				//mp->second - вектор подходящих слов (точнее, указателей на подходящие слова)
				vector<MYWORD*>::iterator iWordNumber = mp->second.begin(); //устанавливаем итератор на начало
				int position = 0; //параллельно с итератором ведём индекс в векторе
				while (ch=='*') //перебираем слова (двигаемся по вектору). вектор упорядочен так, что надо двигать от начала к концу
				{
					if (++iWordNumber == mp->second.end()) //если прошли все возможные слова, а звездочки всё вводятся, начинаем сначала
					{
						iWordNumber = mp->second.begin();
						position = 0;
					}
					++position;
					ch = getchar();
				}
				//звездочки вводить перестали. Теперь iWordNumber указывает на выбранное слово
				cout<<(*iWordNumber)->str; //выводим его
				(*iWordNumber)->freq++; //увеличиваем частоту
				//теперь надо продвинуть это слово по вектору, чтобы оно заняло правильное место с учетом обновленной частоты
				//делаем это только в том случае, если:
				if ((mp->second.size() > 1) //это не единственное слово в векторе. 
				  &&(position!=0)  //это слово не находится в начале вектора. двигать некуда)
				  &&((*iWordNumber)->freq >= (*(iWordNumber-1))->freq)) //частота слова слева все равно больше. то есть двигать не надо
				{
					w = *iWordNumber; //сохраняем во временную переменную
					mp->second.erase(iWordNumber); //удаляем из вектора, чтобы затем вставить в новое место
					iWordNumber = mp->second.begin() + position; //устанавливаем итератор в то место, откуда было удалено слово. 
					//ищем место, куда надо вставить слово
					while ( (iWordNumber != mp->second.begin()) && ((*(iWordNumber-1))->freq <= w->freq)) iWordNumber--;
					mp->second.insert(iWordNumber,w);
				}
				inputword.clear(); //очищаем inputword для следующего ввода (последовательности нажатых на телефоне кнопок).
			}
			if (ch == ' ')
			{
				cout<<' ';
				ch = getchar();
			}
			if (ch == '1') //знак препинания
			{
				int iSignNumber = 0;
				ch = getchar();
				while (ch=='*') //перебираем знаки препинания
				{
					if (iSignNumber==2) iSignNumber=0;
					else iSignNumber++;
					ch = getchar();
				}
				cout<<cSings[iSignNumber]; //выводим знак, стоящий под номером iSignNumber в массове {'.', ',', '?'}
			}
		}
	}
	return 0;
}