#define max_n 200
#define max_m 500
#define max_obj 100
#define max_neuro 1000
#define d_n 64
#define d_m 48
#define window_n 4
#define window_m 3
#define destroy_rate 3.5
#define signs_n 10
#define max_str 4

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>


using namespace std;
    
    const int dir[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
    const int s_teta = (window_n * window_m) / 2;
    const int a_teta = 0;
    const int  s_elem = (d_n / window_n) * (d_m / window_m);
    const int a_elem = s_elem;
    const int weight[a_elem][signs_n] = {
{14,27,0,33,0,24,0,94,6,0},
{14,27,8,39,0,33,0,103,6,0},
{16,29,20,47,2,61,0,99,9,0},
{21,29,33,59,36,78,14,100,33,26},
{43,29,64,79,42,64,41,103,49,72},
{53,32,92,92,76,65,47,89,56,75},
{61,49,86,102,76,71,52,89,63,81},
{62,64,86,102,74,96,56,89,70,83},
{70,74,86,102,68,99,57,89,75,90},
{63,77,83,104,68,84,59,88,80,100},
{66,68,78,81,72,84,62,88,72,86},
{57,70,25,76,73,83,61,88,60,72},
{36,75,16,59,79,83,36,88,37,22},
{21,74,13,58,60,89,21,88,14,21},
{14,76,11,50,52,86,6,89,12,2},
{0,63,0,27,46,40,5,78,2,0},
{22,36,14,39,0,30,13,79,13,0},
{28,37,29,77,0,57,14,80,30,58},
{46,56,55,90,41,93,30,83,50,74},
{54,63,92,92,41,61,46,84,60,79},
{56,66,93,100,55,62,56,84,62,80},
{64,68,95,110,76,65,57,84,70,83},
{71,76,95,114,81,95,57,84,74,92},
{74,76,98,114,75,98,68,84,79,103},
{74,94,98,114,83,97,84,84,79,103},
{73,97,101,114,81,97,92,97,80,103},
{73,101,96,114,91,97,76,97,79,103},
{73,102,97,114,93,97,78,97,78,103},
{72,94,91,114,91,97,64,97,75,87},
{59,81,43,95,73,96,51,97,66,79},
{43,78,21,51,45,89,30,97,45,58},
{14,64,6,16,45,13,9,77,11,21},
{25,34,7,23,0,30,14,46,26,44},
{45,41,49,46,34,65,32,60,51,57},
{54,41,56,46,41,81,48,64,57,62},
{56,42,61,46,50,66,57,64,62,62},
{69,52,61,46,80,69,57,64,66,67},
{71,59,61,59,81,65,62,64,71,68},
{74,90,70,59,78,96,60,64,76,68},
{74,91,70,67,86,74,66,69,76,83},
{74,113,84,89,84,72,63,82,76,83},
{74,110,88,99,92,68,47,82,76,83},
{74,102,91,102,92,47,48,97,75,84},
{74,102,92,105,98,44,37,100,75,85},
{73,97,97,108,91,44,29,108,79,85},
{73,78,86,84,66,40,20,110,76,92},
{60,70,42,55,51,29,13,89,70,79},
{35,64,15,25,45,0,0,32,33,49},
{34,30,29,36,0,53,17,19,39,54},
{54,38,53,40,34,71,48,19,55,61},
{56,39,53,40,48,91,56,19,57,63},
{69,51,53,40,63,87,58,19,67,68},
{71,55,53,40,81,84,64,19,71,68},
{74,59,53,44,76,86,65,19,76,68},
{74,69,53,46,85,104,71,24,76,68},
{74,85,53,66,90,100,62,55,76,83},
{74,94,67,90,92,87,48,59,76,82},
{74,110,80,97,94,58,47,77,76,82},
{74,108,85,93,100,51,43,78,76,80},
{74,97,90,89,96,51,19,100,76,81},
{74,89,97,88,84,43,18,108,75,83},
{73,75,93,57,66,25,12,102,77,91},
{70,69,84,59,45,25,12,80,73,97},
{49,59,40,38,39,0,12,40,45,68},
{49,34,36,13,0,16,34,6,40,60},
{56,34,36,13,14,51,56,6,59,64},
{57,34,36,13,27,51,58,6,62,67},
{74,36,36,30,46,45,67,6,71,67},
{74,43,36,30,47,43,68,6,71,67},
{74,46,50,32,58,75,70,6,76,67},
{74,64,50,52,57,73,77,11,76,67},
{74,78,50,74,94,71,49,60,76,81},
{74,104,64,91,98,76,38,63,76,79},
{74,110,74,97,103,66,31,76,76,80},
{74,103,84,97,98,61,18,83,76,80},
{74,89,94,86,95,60,12,92,76,81},
{74,83,92,69,89,33,10,88,79,84},
{74,75,95,64,65,21,0,82,76,88},
{73,65,90,45,42,0,0,49,66,98},
{62,57,38,25,36,0,0,14,47,57},
{54,32,0,13,11,26,51,0,35,61},
{57,32,0,13,18,52,57,0,57,66},
{71,32,0,13,29,53,68,0,60,66},
{74,36,0,30,52,47,73,0,67,66},
{74,45,0,30,58,52,74,5,71,66},
{74,48,0,49,59,74,81,5,76,65},
{74,64,34,54,60,77,73,33,76,63},
{74,83,34,86,63,80,58,62,76,78},
{74,104,54,102,110,77,52,72,76,78},
{74,111,77,103,101,79,43,76,76,79},
{74,97,87,102,102,73,37,93,75,80},
{74,89,91,79,98,69,36,87,77,80},
{74,83,95,73,90,39,32,80,77,86},
{74,65,97,59,62,36,28,73,67,99},
{74,62,67,46,41,21,0,37,54,100},
{71,54,19,11,34,15,0,14,28,79},
{56,30,0,0,16,32,56,0,5,64},
{71,30,0,15,27,48,68,0,41,65},
{74,29,0,32,54,50,76,0,57,66},
{74,35,0,34,67,50,78,0,69,66},
{74,42,0,54,61,55,77,5,69,63},
{74,39,0,72,62,76,81,20,71,63},
{74,64,20,91,62,94,69,62,76,63},
{74,78,49,93,72,72,67,69,76,76},
{74,104,76,96,103,76,57,76,76,79},
{74,99,89,83,106,102,58,78,79,79},
{74,95,87,84,101,121,58,87,77,79},
{74,89,94,93,99,118,52,84,71,79},
{74,73,94,60,86,83,43,75,67,95},
{74,65,74,49,57,48,39,52,59,100},
{74,62,55,29,39,43,32,14,24,83},
{60,54,11,2,34,16,13,0,1,75},
{57,31,0,12,30,33,66,0,4,53},
{74,21,0,14,42,47,75,0,29,64},
{74,21,0,18,67,53,83,0,50,66},
{74,23,0,24,65,48,79,14,57,63},
{74,30,0,60,65,47,75,20,73,61},
{74,49,0,67,63,47,83,32,71,61},
{74,69,29,88,67,67,83,68,71,61},
{74,78,81,86,67,66,73,77,76,76},
{74,99,86,87,103,68,72,81,79,78},
{74,94,87,78,107,98,72,73,73,81},
{74,92,89,90,105,112,72,84,73,78},
{74,85,92,68,106,124,72,77,65,85},
{74,73,93,83,89,104,72,66,56,96},
{74,65,59,63,63,93,63,38,42,90},
{74,62,39,9,50,69,43,14,26,80},
{58,54,0,4,46,38,29,0,0,74},
{69,21,0,12,26,13,67,0,29,9},
{74,19,0,12,59,19,83,0,54,22},
{74,19,0,18,70,18,83,14,64,61},
{74,23,0,19,67,18,77,20,65,61},
{74,40,3,42,62,23,83,23,74,61},
{74,51,32,39,57,20,84,67,80,61},
{74,69,61,46,58,47,74,76,80,61},
{74,76,87,52,64,47,73,67,80,79},
{74,99,86,60,98,80,73,72,79,80},
{74,94,86,74,102,89,73,85,78,75},
{74,88,92,77,108,99,73,80,78,85},
{74,76,88,98,97,93,72,76,73,94},
{74,73,57,95,88,105,72,60,65,84},
{74,65,48,73,65,93,71,14,61,81},
{74,55,0,63,54,87,65,0,39,74},
{55,53,0,22,47,48,43,0,28,70},
{74,19,0,0,29,0,77,0,55,30},
{74,19,0,0,53,0,83,0,60,41},
{74,23,3,0,56,0,86,15,69,45},
{74,32,5,6,70,0,84,23,70,51},
{74,40,33,6,54,9,84,35,80,51},
{74,56,63,18,54,9,74,74,80,52},
{74,69,88,18,54,40,73,65,80,55},
{74,76,86,47,55,66,73,63,80,69},
{74,97,83,54,96,73,73,71,80,66},
{74,90,85,72,104,60,73,82,78,89},
{74,88,63,87,103,85,73,77,74,92},
{74,76,53,81,103,92,73,71,74,79},
{74,73,46,91,97,97,73,48,69,79},
{74,65,0,94,76,89,71,0,64,75},
{63,54,0,88,49,87,71,0,63,73},
{54,53,0,57,47,71,60,0,51,62},
{73,19,0,0,46,0,80,0,63,30},
{74,19,3,0,48,0,86,15,69,30},
{74,23,5,0,56,0,87,23,76,32},
{74,33,35,0,49,0,84,25,80,35},
{74,47,47,0,49,0,82,69,80,39},
{74,56,88,0,50,0,74,81,80,41},
{74,64,85,37,50,64,73,61,80,43},
{74,76,79,59,60,65,81,72,80,58},
{74,93,87,70,104,48,81,82,80,72},
{74,91,81,55,106,80,81,81,78,87},
{74,82,51,66,104,90,81,77,78,79},
{74,76,34,73,95,91,81,60,74,72},
{74,73,13,89,89,85,81,23,74,75},
{69,56,20,90,66,88,80,0,64,74},
{55,53,20,92,50,73,77,0,64,70},
{47,48,20,82,49,72,72,0,63,44},
{63,19,0,21,37,10,78,14,65,36},
{74,23,5,21,45,10,96,18,76,36},
{74,29,35,21,43,10,87,25,80,36},
{74,33,47,21,36,10,84,39,80,36},
{74,47,71,37,41,35,84,77,80,36},
{74,56,89,37,36,35,84,66,80,43},
{74,67,89,49,36,63,84,72,80,54},
{74,72,85,47,50,56,84,86,80,72},
{74,93,74,59,100,65,84,82,80,80},
{74,91,70,60,107,81,84,80,79,74},
{74,79,54,69,98,82,84,76,78,78},
{74,76,49,89,85,93,84,44,78,68},
{68,73,36,88,79,83,83,0,70,75},
{62,56,36,90,72,74,80,0,64,72},
{54,48,36,90,66,73,80,0,64,64},
{41,48,36,77,63,65,69,0,62,43},
{56,21,5,21,33,16,80,15,67,30},
{72,30,31,21,33,16,94,25,80,36},
{74,31,55,37,26,20,96,25,80,36},
{74,40,71,37,26,41,84,52,80,36},
{74,47,93,30,26,37,84,79,80,43},
{74,46,94,22,30,16,84,65,80,54},
{74,63,85,34,37,63,84,76,80,67},
{74,70,83,53,47,79,84,82,80,70},
{74,93,82,62,105,80,84,82,80,73},
{74,85,72,70,99,81,84,77,78,65},
{74,79,67,76,97,83,84,67,78,68},
{67,76,54,89,84,66,83,22,78,72},
{67,70,60,89,81,66,80,0,65,71},
{55,53,60,87,72,74,80,0,64,65},
{49,50,60,81,64,71,80,0,62,45},
{34,50,37,49,65,10,42,0,47,39},
{36,30,33,36,14,29,30,19,49,30},
{60,44,61,56,14,55,87,25,78,38},
{74,49,75,56,14,55,94,39,80,48},
{74,53,100,56,14,56,85,75,80,52},
{74,57,96,68,14,57,84,66,80,57},
{74,65,89,54,20,59,84,74,80,58},
{74,66,89,60,27,81,84,85,80,60},
{74,70,89,68,50,82,84,83,80,75},
{74,87,86,71,102,82,84,82,79,67},
{74,82,81,89,94,74,84,75,78,69},
{67,87,74,88,88,66,83,47,78,73},
{62,86,62,87,82,66,80,22,69,71},
{55,75,66,86,74,74,70,0,62,64},
{51,66,66,79,68,69,70,0,62,46},
{38,63,66,31,53,19,46,0,60,39},
{22,63,35,13,52,1,17,0,27,31},
{17,45,44,57,0,50,15,19,16,3},
{44,58,84,67,0,52,30,38,47,45},
{58,58,99,75,0,69,81,47,68,57},
{71,63,96,67,0,92,91,75,77,71},
{74,75,96,66,0,67,93,75,80,67},
{74,69,95,67,6,68,85,72,80,67},
{74,66,95,67,14,74,84,83,79,65},
{74,69,96,76,52,76,84,82,79,78},
{67,87,101,88,102,68,84,81,78,71},
{67,92,99,86,95,66,72,54,69,70},
{67,96,97,86,83,69,70,32,64,67},
{55,96,90,88,82,67,70,1,62,47},
{48,91,87,36,76,47,65,0,62,44},
{34,75,87,27,54,3,43,0,43,39},
{24,72,79,2,40,1,17,0,27,31},
{14,66,46,0,38,0,1,0,6,1},
{0,52,50,32,0,27,0,18,0,0},
{0,61,42,51,0,56,0,32,1,12},
{17,49,57,45,0,49,10,60,11,19},
{17,57,57,49,0,43,14,69,31,27},
{42,55,57,63,0,60,33,57,44,41},
{48,56,55,66,4,57,47,72,51,35},
{53,51,55,71,26,62,60,81,59,30},
{61,53,62,52,42,61,80,80,64,43},
{58,71,67,47,91,57,80,66,61,49},
{48,82,68,20,80,48,44,47,48,13},
{28,80,68,14,80,19,38,23,36,6},
{19,74,63,4,82,1,11,1,23,2},
{14,74,83,4,79,0,0,0,6,0},
{0,66,56,0,54,0,0,0,0,0},
{0,69,57,0,41,0,0,0,0,0},
{0,52,47,0,38,0,0,0,0,0}};

struct black_string{
    int n;
    int left[max_str];
    int right[max_str];
};    

    
    int n, m;
    int komp;
    int color;
    int been[max_n][max_m];
    int dim[max_obj][6];
    string pict[max_n], number[max_n];
    int been_n[max_n][max_m];
    int number_n, number_m;
    int signal[max_neuro];
    string ans;
    
void neuro_view()
{
    int i, j, adr;
    for (i = 0; i < a_elem; i++)
    {
        signal[i] = 0;
    }    

    for (i = 0; i < d_n; i++)
    {
        for (j = 0; j < d_m; j++)
        {
            if (number[i][j] != '.')
            {
                adr = (i/window_n)*(d_m/window_m) + (j/window_m);
                signal[adr]++;
            }
        }
    }                
    for (i = 0; i < s_elem; i++)
    {
        if (signal[i] > s_teta)
        {
            signal[i] = 1;
        }
        else
        {
            signal[i] = 0;
        }
    }
    
}    

int neuro_recogn()
{
    int i, j, answer;
    int ans_signal[signs_n];
    for (j = 0; j < signs_n; j++)
    {
        ans_signal[j] = 0;
    }    
    
    for (i = 0; i < a_elem; i++)
    {
        if (signal[i] > a_teta)
        {
            for (j = 0; j < signs_n; j++)
            {
                ans_signal[j] += (weight[i][j] * signal[i]);
            }
        }    
    }    
    
    answer = 0;
    for (i = 1; i < 10; i++)
    {
        if (ans_signal[i] > ans_signal[answer])
        {
            answer = i;
        }
    }
    return answer;
}    

void data_read()
{
    n = 0; m = 0;
    while (!cin.eof())
    {
        cin >> pict[n];
        if ((pict[n][0] != '.') && (pict[n][0] != '%')
        && (pict[n][0] != '#') && (pict[n][0] != '@'))
        {
            break;
        }
        else
        {
            n++;
        }    
    }    
    m = pict[0].length();
}

void data_answer_out()
{
    cout << ans;
}    
    
void data_clear_columns()
{
    int i, j, sum;
    for (j = 0; j < m; j++)
    {
        sum = 0;
        for (i = 0; i < n; i++)
        {
            if (pict[i][j] == '@') {sum++;}
            if (pict[i][j] == '#') {sum++;}
        }
        if (sum == 0)
        {
            for (i = 0; i < n; i++)
            {
                pict[i][j] = '.';
            }
        }
    }
}                    

void data_init(string s[], int x, int y)
{
    int i, j;
    for (i = 0; i < x; i++)
    {
        s[i] = "";
        for (j = 0; j < y; j++)
        {
            s[i] += '.';
        }
    }
}            

void data_resize()
{
    int i, j, x, s, p;
    int step, pen;
    string tmp[max_n];

//resize columns || (number_n, number_m) -> (d_n, number_m)
    data_init(tmp, d_n, d_m);
    s = d_n; p = 0;
    for (i = 0; i < number_n; i++)
    {
        for (x = 0; x < (s / number_n); x++)
        {
            for (j = 0; j < number_m; j++)
            {
                tmp[p][j] = number[i][j]; 
            }
            p++;
        }   
        s = (s % number_n) + d_n;
    }     
    
//resize strings = (d_n, number_m) -> (d_n, d_m)    
    data_init(number, d_n, d_m);
    s = d_m; p = 0;
    for (j = 0; j < number_m; j++)
    {
        for (x = 0; x < (s / number_m); x++)
        {
            for (i = 0; i < d_n; i++)
            {
                number[i][p] = tmp[i][j]; 
            }
            p++;
        }   
        s = (s % number_m) + d_m;
    }     
}    

void bfs(int x, int y, int sv)
{
    int stek[max_n*max_m][2];
    int begin, end, a, b, u, i, j;
    begin = 0;
    end = 1;
    stek[0][0] = x;
    stek[0][1] = y;
    been[x][y] = sv;
    //1 - verh, 2 - pravo, 3 - niz, 4 - levo
    dim[sv][0] = 0;
    dim[sv][1] = x;
    dim[sv][2] = y;
    dim[sv][3] = x;
    dim[sv][4] = y;
    dim[sv][5] = 0;
    while (begin < end)
    {
        dim[sv][0]++;
        a = stek[begin][0];
        b = stek[begin][1];
        if (dim[sv][1] > a) {dim[sv][1] = a;}
        if (dim[sv][2] < b) {dim[sv][2] = b;}
        if (dim[sv][3] < a) {dim[sv][3] = a;}
        if (dim[sv][4] > b) {dim[sv][4] = b;}     
        for (u = 0; u < 8; u++)
        {
            i = a + dir[u][0];
            j = b + dir[u][1];
            if ((i >= 0) && (i < n) && (j >= 0) && (j < m))
            {
                if ((pict[i][j] != '.') && (been[i][j] == -1))
                {
                    stek[end][0] = i;
                    stek[end][1] = j;
                    been[i][j] = sv;
                    end++;
                }    
            }    
        }
        begin++;    
    }    
}    

void predproc()
{
    int i, j;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
        {
            been[i][j] = -1;
        }
    }        
    komp = 0;
    
    data_clear_columns();    
    for (j = 0; j < m; j++)
    {
        for (i = 0; i < n; i++)    
        {
            if ((pict[i][j] != '.') && (been[i][j] == -1))
            {
                bfs(i, j, komp);
                komp++;
            }
        }
    }
    
    for (i = 0; i < komp; i++)
    {
        if (dim[i][0] < (destroy_rate*n*m / 100))
        {
            dim[i][5] = 1;
        }    
    }    
    for (i = 0; i < komp; i++)
    {
        for (j = 0; j < komp; j++)
        {
            
            if ((dim[i][1] < dim[j][1]) && (dim[i][2] > dim[j][2])
            && (dim[i][3] > dim[j][3]) && (dim[i][4] < dim[j][4]))
            {
                if (dim[j][5] != 1)
                {
                    dim[i][5] = 1;
                }    
            }
        }
    }            
    
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
        {
            if (pict[i][j] != '.')
            {
                if (dim[been[i][j]][5] == 1)
                {
                    pict[i][j] = '.';
                }    
            }
        }
    }
}    

void dfs(int x, int y, int go_type)
{
    //go_type  0 - white pix, 1 - black pix
    int u, i, j;
    switch (go_type) 
    {
        case 0:
            if (number[x][y] != '.') {return;}
            if (been_n[x][y] != -1)  {return;}
            been_n[x][y] = 0;
            for (u = 0; u < 8; u++)
            if ((u % 2) == 0)
            {
                i = x + dir[u][0];
                j = y + dir[u][1];
                if ((i >= 0) && (i < number_n) && (j >= 0) && (j < number_m))
                {
                    dfs(i, j, go_type);
                }
            }            
            break;
        case 1:
            if (number[x][y] != '@') {return;}
            if (been_n[x][y] == color)  {return;}
            been_n[x][y] = color;
            for (u = 0; u < 8; u++)
            {
                i = x + dir[u][0];
                j = y + dir[u][1];
                if ((i >= 0) && (i < number_n) && (j >= 0) && (j < number_m))
                {
                    dfs(i, j, go_type);
                }
            }            
            break;
   }        
} 

void data_number_cut_columns()
{
    int i, j;
    bool clear;
    string tmp[max_n];

    for (i = 0; i < number_n; i++)
    {
        tmp[i] = "";
    }    
    clear = true;
    for (j = 0; j < number_m; j++)
    {
        for (i = 0; i < number_n; i++)
        {
            if (number[i][j] == '@')
            {
                clear = false;
                break;
            }
        }
        if (!clear)
        {
            for (i = 0; i < number_n; i++)
            {
                tmp[i] += number[i][j];
            }
        }
    }
    number_m = tmp[0].length();
    for (i = 0; i < number_n; i++)
    {
        number[i] = tmp[i];
    }    
}                

black_string pro_line(int i)
{
    black_string a;
    int j;
    bool black;
    a.n = 0; j = 0; black = false;
    while (j < number_m)
    {
        if (number[i][j] == '@')
        {
            if (!black)
            {
                a.left[a.n] = j;
                black = true;
            }    
        }
        else
        {
            if (black)
            {
                a.right[a.n] = j;
                a.n++;
                black = false;
            }
        }            
        j++;
    }    
    if (black)
    {
        a.right[a.n] = j;
        a.n++;
    }    
    return a;
}       

void eraze_segm(int up_down)
{
    int i, j;
    bool er = true;
    for (j = 0; j < number_m; j++)
    {
        if (been_n[((up_down + 1)/2)*(number_n - 1)][j] == color)
        {
            er = false;
            break;
        }
    }    
    if (!er) {return;}
    for (i = 0; i < number_n; i++)
    {
        for (j = 0; j< number_m; j++)
        {
            if (been_n[i][j] == color)
            {
                number[i][j] = '.';
            }
        }
    }
}

void data_number_proceed_string(black_string prev, black_string now, int i, int up_down)
{
    int k, j;
    black_string todo;
    todo.n = 0;
    if ((prev.n == 1) && (now.n > prev.n))
    {
        for (k = 0; k < now.n; k++)
        {
            if (max(now.left[k], prev.left[0]) <= min(now.right[k], prev.right[0]))
            {
                todo.left[todo.n] = now.left[k];
                todo.right[todo.n] = now.right[k];
                todo.n++;
            }
        }        
        if (todo.n > 0)
        {
            for (k = 0; k < todo.n; k++)
            {
                color++;
                for (j = todo.left[k]; j < todo.right[k]; j++)
                {
                    been_n[i][j] = color;
                }
                for (j = max(todo.left[k] - 1, 0); j < min(todo.right[k] + 1, number_m); j++)
                {
//                    if (number[i + up_down][j] == '@')
//                    {
                        dfs(i + up_down, j, 1);
//                        break;
//                    }
                }        
                eraze_segm(up_down);
            }
        }        
    }
}    

void data_number_delete_strings()
{
    int i, j, k;
// 1 : i++, -1 : i--
    black_string prev, now;
    prev.n = 0;
    for (i = 0; i < (number_n/3); i++)
    {
        now = pro_line(i);
        data_number_proceed_string(prev, now, i, 1);
        prev = now;
    }        
    prev.n = 0;
    for (i = number_n - 1; i > 2*(number_n/3); i--)
    {
        now = pro_line(i);
        data_number_proceed_string(prev, now, i, -1);
        prev = now;
    }        
    
}                    

void data_number_cut()
{
    int i, j, k;
    black_string v;
//connect
    for (i = 0; i < number_n/6; i++)
    {
        v = pro_line(i);
        if (v.n > 1)
        {
            for (j = v.left[0]; j < v.right[v.n - 1]; j++)
            {
                number[i][j] = '@';
            }
        }
    }            
            
    
//fill intro    
    for (i = 0; i < number_n; i++)
    {
        for (j = 0; j < number_m; j++)
        {
            been_n[i][j] = -1;
        }
    }
    for (i = 0; i < number_n; i++)
    {
        dfs(i, 0, 0);
        dfs(i, number_m - 1, 0);
    }    
    for (j = 0; j < number_m; j++)
    {
        dfs(0, j, 0);
        dfs(number_n - 1, j, 0);
    }    
    for (i = 0; i < number_n; i++)
    {
        for (j = 0; j < number_m; j++)
        {
            if (been_n[i][j] == -1)
            {
                number[i][j] = '@';
            }    
        }
    }
    
    color = 0;
    data_number_delete_strings();
    data_number_cut_columns();
}            

void get_number_and_go()
{
    int i, j, u, k = 0;
    for (u = 0; u < komp; u++)
    {
        if (dim[u][5] != 1)
        {
            for (i = dim[u][1]; i <= dim[u][3]; i++)
            {
                number[i - dim[u][1]] = "";
                for (j = dim[u][4]; j <= dim[u][2]; j++)
                {
                    
                    if (been[i][j] == u)
                    {
                        number[i - dim[u][1]] += '@';
                    }
                    else
                    {
                        number[i - dim[u][1]] += '.';                        
                    }    
                }
            }
            number_n = dim[u][3] - dim[u][1] + 1;
            number_m = dim[u][2] - dim[u][4] + 1;
            data_resize();
            
            neuro_view();
            ans += (neuro_recogn() + '0');
        }    
    }    
}    

int main()
{
    // 1 - obu4enie, 0 - raspoznavanie
    data_read();
    predproc();
    predproc();
    ans = "";
    get_number_and_go();
    data_answer_out();
    return 0;
}
    
    
