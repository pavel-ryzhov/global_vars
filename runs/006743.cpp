#include <cstdlib>
#include <iostream>

using namespace std;

typedef struct {	// Слово в словаре
	char s[20];		// само слово
	int freq;		// частота использования слова
	int comb;		// комбинация клавиш
	int usedAgo;	// дополнительный признак сортировки - как давно слово использовалось
} word;

typedef word *wpoint;	// указатель на слово
typedef wpoint *vocab;	// словарь, массив указателей на слова

// возврат клавиши, на которой находится буква
int charToNum (char c) {
	if ( c < 112 )
		return (c - 97)/3 + 2;	// первые пять цифр (2 - 6)
	else if ( c > 115 )
		return (c > 118)? 9:8;	
	else
		return 7;
}

// считывание словаря
void readVoc (int &n, vocab &V) {
	cin >> n;							// считали количество слов
	V = new wpoint [n];					// создали массив из н указателей на слова
	for (int i=0 ; i<n ; i++ ) {		// циклически заполняем словарь
		V[i] = new word;				// создали указатель
		cin >> V[i]->s;					// прочитали слово
		V[i]->comb = 0;					// заполняем поле комбинации клавиш
		int k = 0;						// счетчик цикла
		while ( V[i]->s[k] )			// побуквенно разобираем слово
			V[i]->comb = V[i]->comb *10 + charToNum (V[i]->s[k++]);	// переводим буквы в клавиши (цифры)
		cin >> V[i]->freq;				// считываем частоту использования слова
		V[i]->usedAgo = 0;				// задаем начальное значение дополнительного признака сортиовки
	}
}

// сортировка по частоте и последовательности использования в пределах одной комбинации клавиш
void sortByFreq (int n, vocab &V) {		// принимает не весь словарь, а только слова с одинаковым значением поля comb
	if ( n < 2 )						// если слово только одно - сразу возврат
		return;
	for ( int i=0 ; i<n ; i++ ) {		// внешний цикл, сортировка выборкой максимального
		int max = i;					// номер максимального по умолчанию
		int t = 0;						// флаг, истина если i-тый элемент надо поменять с каким-либо местами
		for ( int j=i+1 ; j<n ; j++ ) {	// нутренний цикл, начиная с i+1 элемента ищем те, которые должны стоять раньше него
			if ( (V[j]->freq > V[max]->freq) || ((V[j]->freq == V[max]->freq)&&(V[j]->usedAgo < V[max]->usedAgo)) ) {
				// если у j-того элемента больше частота использования или, если частота одинаковая, j-тый элемент использовался последним
				max = j;	// индекс максимального теперь равен j
				t = 1;		// установили флаг в истину
			}
		}			
		if ( t ) {				// если флаг истина - то надо поменять элементы местами
			wpoint temp = V[i];	// сохраняем значение i-того во временный
			V[i] = V[max];		// i-тому присваиваем значение максимального
			V[max] = temp;		// а максимальному, значение i-того
		}
	}
}

// выборка из словаря слов, подходящих под набор клавиш, с сортировкой
vocab usersWords (int combination, int n, vocab V, int &len) {
	len = 0;					// длина "подсловаря" слов, с подходящим набором клавиш
	int first, t, f;			// индекс первого подходящего слова в словаре и два флага
	f = 0;						// флаг истины, если нашли индекс первого подходящего элемента
	for ( int i=0 ; i<n ; i++ ) {	// цикл поиска нужных слов
		t = (V[i]->comb == combination)? 1:0;	// флаг истина, если значение комбинации клавиш у слова равно требуемому
		if ( t ) {				// если комбинации клавиш совпадают
			len++;				// увеличиваем длину "подсловаря"
			if ( !f ) {			// если первый элемент подсловаря не найден, то это он
				first = i;		// запоминаем значение индекса первого совпадения комбинаций клавиш
				f = 1;			// устанавливаем флаг в истину - мы нашли первый элемент подсловаря
			}
		} else if ( f )			// если нужные слова закончились, то выходим из цикла
			break;
	}
	vocab result = new wpoint [len];	// создаем результирующий словарь длины len
	for ( int i=0 ; i<len ; i++ )		// цикл заполнения результирующего словаря
		result[i] = V[i+first];			// заполняем результирующий словарь
	sortByFreq (len, result);			// сортируем его
	return result;						// и возвращаем
}

// возвращает слово по комбинации клавиш "от пробела до пробела"
char *getWord (char *s, int n, vocab V, char &mark) { // s - комбинация клавиш "от пробела до пробела", mark - знак препинания
	int i = 0;			// счетчик по строке s
	int comb = 0;		// комбинация клавиш
	while ( s[i] && (s[i] != '*') && (s[i] != '1') ) {	//пока s - цифра, значащая букву (от 2 до 9)
		comb  = comb*10 + s[i] - 48;	// циклически переводим s к типу инт и записываем результат в comb
		i++;							// увеличиваем счетчик
	}
	int m;				// длина словаря подходящих под комбинацию слов
	vocab W = usersWords (comb, n, V, m);	// создаем словарь нужных слов
	int j = 0;			// счетчик количества нажатий на звездочку (*)
	while ( s[i] == '*' ) {	// пока s равно звездочке
		j++;			// прибавляем к счетчику единицу
		if ( j == m )	// если больше чем слов в словаре
			j = 0;		// то возвращаемся в начало словаря
		i++;			// увеличиваем счетчик s
	}
	char *result = W[j]->s;		// результирующее слово
	W[j]->freq += 1;			// увеличиваем этому слову частоту использования
	for ( int k=0 ; k<m ; k++ )	// всем словам с этой комбинацией клавиш увеличичваем давность использования
		W[k]->usedAgo += 1;		// см. строчку выше
	W[j]->usedAgo = 0;			// устанавливаем использованному слову давность использования нулем
	if ( s[i] == '\0' ) {		// если входная строка закончилась
		mark = '\0';			// то знака препинания нет
		return result;			// возвращаем результирующее слово
	} else {					// иначе есть знак препинания
		i++;					// прибавляем счетчик строки s
	}
	j = 0;						// обнулим счетчик количества звездочек
	while ( s[i] == '*' ) {		// циклически посчитаем количество звездочек
		j++;					//
		if ( j == 3 )			// если больше, чем различных знаков препинания
			j = 0;				// то возвращаем счетчик в ноль
		i++;					// читаем входную строку дальше
	}
	switch ( j ) {				// выбираем, какой знак препинания нам нужен
		case 0: {				// если звздочек ноль
			mark = '.';			// то это точка
			break;				// выходим из оператора switch
				}
		case 1: {				// если одна звездочка
			mark = ',';			// то это запятая
			break;				// выходим из оператора switch
				}
		case 2: {				// если звездочек две
			mark = '?';			// то это знак вопроса
			break;				// выходим из оператора switch
				}
		default: mark = '.';	// по умолчанию - точка
	}
	return result;				// возвращаем результирующее слово
}

// возвращает результирующую строку
char *getResultString (char *s, int n, vocab V) {	// s - строка, введенная пользователем, вместо нулей в ней пробелы
	int i, j;					// счетчики - входной строки и результата
	i = j = 0;					// установили счетчики в ноль
	char *result = new char;	// создали результрующую строку
	while ( s[i] ) {			// пока входная строка не закончилась
		int k = 0;				// дополнительный счетчик - для слов
		char *temp = new char;	// создаем слово
		while ( s[i] && (s[i] != ' ') )	// циклически заполняем его из входа, пока не встретим пробел или конец строки
			temp[k++] = s[i++];	// см. строчку выше
		temp[k] = '\0';			// закрыли строку temp
		char ch;				// знак препинания
		temp = getWord (temp, n, V, ch);	// переписали временную переменную, теперь в ней слово, а не набор цифр, и записали знак препинания (ch)
		k = 0;					// обнулили счетчики строки temp
		while ( temp[k] )		// пока строка temp не закончилась
			result[j++] = temp[k++];	// побуквенно переписываем ее в результирующую строку
		if ( ch )				// если после слова был знак препинания
			result[j++] = ch;	// записываем его в результирующую строку
		if ( s[i] == ' ' )		// если входная строка не закончилась, т.е. дальше идет пробел
			result[j++] = s[i++];	// записываем в результирующую строку пробел
	}
	result[j] = '\0';			// закрываем результирующую строку
	return result;				// и возвращаем ее
}

// основная программа
int main(int argc, char *argv[]) {
	vocab V;									// объявление словаря
	int n;										// количество слов в словаре
	readVoc (n, V);								// считывание словаря со входного потока
	if ( !n )									// если словарь пуст - завершить исполнение
		return 0;								// --
	char *task = new char;						// объявление строки с заданием (символы, набранные пользователем)
	cin.ignore();								// игнорирование знаков \n, для правильного расположения каретки
	cin.getline (task, 100000, '\n');			// считывание строки-задания
	char *out = getResultString (task, n, V);	// объявление строки с ответом и запись ответа
	cout << out << '\n';						// вывод ответа на экран
	system ("pause");
}