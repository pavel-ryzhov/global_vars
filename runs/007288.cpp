/*
дерево представляется как массив (динамический) звеньев. 
Первоначально каждое звено содержит ссылки на все соседние звенья. 
Каждая ссылка хранит длину пути до звена, на которое ссылается.

Затем дерево преобразуется к виду "предок - наследник". Теперь каждое звено содержит:
1. ссылку на своего предка (с информацией о длине пути до него)
2. глубину данного звена в дереве.

Для нахождения минимального расстояния между двумя звеньями делаем следующее:
1. выравниваем глубины двух звеньев. то есть, от более глубоко звена поднимаемся по дереву, сохраняя пройденное расстояние.
2. одновременно поднимаемся по дереву(прибавляя пройденное расстояние) от этих двух звеньев до тех пор, 
	пока не встретимся в каком-то звене (являющемся ближайшим общим предком).
*/


#include <vector>
#include <iostream>
using namespace std;

struct LINK				//ссылка.
{						//to - номер вершины, на которую ссылается ссылка)
	int length;			//этот номер совпадаем с индексом вершины в массиве tree, представляющем дерево
	int to;				//length - длина пути до вершины, на которую идет сслыка
};						//

struct ZVENO			//звено)
{						//deep - глубина. глубина нулевого звена равна нулю
	int deep;			//
	LINK parent;		//ссылка на предка. эта ссылка появляется после обработки дерева
	vector<LINK> links;	//вектор, содержит ссылки на все соседние звенья. этот вектор инициализируется при заполнении дерева,
};						//используется при обработке дерева. При вычислении расстояния не используется.

ZVENO *tree;			//само дерево

int findL(int z1, int z2); //возвращает расстояние между звеньями с номерами z1 и z2;
void process(int n, int anc); //рекурсивная функция, обрабатывает дерево. n - номер обрабатываемого звена, anc - номер предка

int main()
{
	int N, z1,z2,l;
	LINK temp;
	cin>>N; //узнаем количество звеньев
	tree = new ZVENO [N]; //создаем динамический массив, описывающий дерево из N звеньев.
	for (int i = 0; i<N-1; i++) //заполняем дерево
	{
		cin>>z1>>z2>>l; //z1 - номер первой вершины, z2 - номер второй, l - расстояние между ними
		temp.length = l;	//инициализируем временную ссылку. длина = l; номер звена, на которое идет ссылка = e-1
		temp.to = z2-1;		//(-1, так как индексация в массиве идет с нуля, а при вводе - с единицы.
		tree[z1-1].links.push_back(temp); //добавляем эту ссылку в первое(из двух введенных) звено.
		//теперь надо сделать обратное. добавить во второе звено ссылку, указывающую на первое.
		temp.to = z1-1;		//теперь ссылка указывает на первое
		tree[z2-1].links.push_back(temp); //добавляем ее во второе.
	}
	//ввод дерева закончен. теперь надо его обработать - привести к представлению "предок - наследник"
	tree[0].deep = 0; //выбираем звено tree[0] в качестве корневого. его глубина равна 0
	for (unsigned int i = 0; i < tree[0].links.size(); i++) //проходим по всем ссылкам в корневом звене
	{
		process(tree[0].links[i].to, 0); //обрабатываем звено, на которое указывает i-ая ссылка в корневном звене.
	}
	//теперь дерево приведено к виду "предок - наследник".
	cin>>N; //узнаем количество запросов
	for (int i = 0; i<N; i++) //обрабатываем все N запросов
	{
		cin>>z1>>z2;
		cout<<findL(z1-1,z2-1)<<endl; //выводим расстояние между запрошенными звеньями.
	}
	return 0;
}

int findL(int z1, int z2) //находит расстояние между звеньями z1 и z2
{
	int len = 0; //сюда будем накапливать расстояние
	if (z1==z2) return 0; //это пожно проверить сразу

	//выравниваем глубины.
	while (tree[z1].deep < tree[z2].deep) //если звено z2 глубже, то поднимаем его до выравнивания.
	{
		len += tree[z2].parent.length; //добавляем длину пути предка
		z2 = tree[z2].parent.to; //и поднимаемся до предка
	}
	while (tree[z1].deep > tree[z2].deep) //тоже самое с z1. если z1 глубже, то поднимаем его
	{
		len += tree[z1].parent.length;
		z1 = tree[z1].parent.to;
	}
	//теперь глубины одинаковы. теперь, если подниматься синхронно - то обязательно встретимся (в самом близком общем предке)
	while (z1 != z2) //пока не встретились
	{
		len += tree[z1].parent.length;	//поднимаем z1
		z1 = tree[z1].parent.to;		//

		len += tree[z2].parent.length;	//поднимаем z2
		z2 = tree[z2].parent.to;		//
	}
	//теперь в len содержится всё пройденное расстояние. это и есть расстояние между z1 и z2.
	return len;
}

void process (int n, //номер обрабатываемого звена
			  int anc) //номер предка для данного звена
{
	tree[n].deep = tree[anc].deep + 1; //устанавливаем глубину, на единицу большую, чем глубина предка
	for (unsigned int i = 0; i < tree[n].links.size(); i++) //проходим по всем ссылкам в обрабатываемом звене
	{
		if (tree[n].links[i].to == anc) //когда попали на ссылку, указывающую на предка, инициализируем ссылку parent в данном звене
		{
			tree[n].parent.to = anc;
			tree[n].parent.length = tree[n].links[i].length;
		}
		else process(tree[n].links[i].to, n); //если эта ссылка указывает не на предка (а значит на наследника),
											  //то запускаем обработку звена, на которое идет ссылка. 
	}										  //Таким образом рекурсивно обрабатывается всё дерево
}