#define f_in "input.txt"
#define f_out "output.txt"
#define f_pic "pic.txt"
#define weight_file "learn.txt"
#define max_n 200
#define max_m 800
#define max_obj 100
#define max_neuro 1000
#define d_n 64
#define d_m 48
#define window_n 4
#define window_m 3
#define destroy_rate 0.7
#define signs_n 10

#include <iostream>
#include <algorithm>
#include <fstream>
#include <string>
#include <vector>
#include <set>

using namespace std;
    
    const int dir[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
    const int s_teta = (window_n * window_m) / 2;
    const int a_teta = 0;
    const int  s_elem = (d_n / window_n) * (d_m / window_m);
    const int a_elem = s_elem;
    const int weight[a_elem][signs_n] = {
{6,9,0,23,0,28,0,73,0,2},
{8,16,11,43,0,33,4,96,3,7},
{9,16,14,62,1,48,4,85,12,23},
{14,31,43,68,17,81,19,87,27,27},
{42,34,60,90,24,85,45,87,52,62},
{74,44,80,92,43,66,58,61,62,83},
{73,61,80,89,50,63,55,63,72,71},
{68,60,86,95,52,86,51,63,82,79},
{79,72,89,96,58,87,49,80,89,82},
{87,85,96,85,61,85,54,77,100,91},
{95,78,94,93,64,93,96,77,109,110},
{57,88,62,88,67,88,95,75,84,67},
{30,102,41,61,68,90,63,77,51,30},
{13,82,34,64,62,94,61,76,31,29},
{6,87,11,58,59,95,54,95,24,39},
{0,76,0,30,47,67,45,76,14,15},
{16,35,24,35,0,29,20,61,10,17},
{24,41,44,48,0,40,21,80,31,31},
{53,57,69,77,20,63,30,82,48,63},
{69,57,82,90,21,87,55,81,77,81},
{70,70,77,75,30,88,59,81,85,67},
{81,74,80,83,52,74,28,81,73,57},
{74,70,80,84,53,84,53,81,72,58},
{60,86,83,91,60,90,52,81,78,98},
{68,99,87,95,72,89,68,81,78,98},
{66,112,95,99,72,93,69,102,87,103},
{77,113,99,101,69,101,78,111,87,94},
{91,105,101,108,75,106,95,112,93,105},
{94,110,101,118,81,112,98,111,82,105},
{54,90,73,119,72,109,64,116,82,82},
{25,87,43,51,51,97,57,116,56,61},
{9,67,21,20,45,34,10,102,21,47},
{24,44,44,35,0,35,21,46,22,33},
{52,52,78,61,4,56,30,72,69,83},
{75,52,73,73,21,79,57,73,78,79},
{69,50,72,56,55,96,63,68,83,46},
{81,53,73,66,63,71,67,67,97,58},
{76,73,72,75,57,66,54,67,84,69},
{71,90,69,55,59,88,50,65,63,63},
{51,100,69,54,73,83,61,63,43,56},
{40,100,67,59,72,69,58,84,41,54},
{58,109,71,79,70,71,64,84,36,67},
{65,103,89,83,70,62,82,101,41,82},
{68,112,87,97,82,70,64,107,54,91},
{89,112,93,115,88,62,72,116,82,106},
{97,89,91,107,70,59,51,122,96,116},
{63,76,70,75,52,34,48,94,82,74},
{23,57,36,46,37,14,22,26,43,44},
{29,40,72,40,0,32,29,35,29,69},
{75,50,73,57,4,62,57,48,60,78},
{87,63,73,58,54,90,95,46,66,57},
{83,78,67,55,63,91,73,42,83,68},
{79,71,59,59,72,85,65,38,87,74},
{75,83,59,55,57,78,55,38,68,58},
{56,80,54,51,70,96,52,40,38,47},
{38,90,58,54,74,85,58,68,23,36},
{34,94,60,70,69,77,59,71,23,43},
{39,97,64,79,73,60,69,93,31,58},
{60,106,64,77,79,57,77,96,50,66},
{66,106,70,81,80,53,52,110,69,74},
{74,109,92,94,80,35,53,120,78,95},
{90,79,101,79,70,29,48,100,102,128},
{93,57,97,68,43,22,47,77,79,110},
{37,49,55,38,37,13,30,23,56,51},
{67,53,64,13,0,27,33,38,32,71},
{76,51,66,30,10,64,95,37,81,66},
{89,54,66,57,62,83,95,35,85,88},
{82,60,54,47,78,81,74,37,84,86},
{84,56,50,50,60,46,66,15,73,62},
{66,45,52,53,70,81,54,15,73,40},
{56,46,56,64,67,56,63,16,49,37},
{27,81,50,71,64,53,56,63,34,29},
{29,82,53,77,73,71,64,66,22,42},
{38,97,58,89,83,71,64,90,29,67},
{47,104,68,87,77,74,48,101,55,71},
{64,93,87,84,83,68,53,95,81,90},
{73,97,102,75,85,51,52,83,100,91},
{80,79,102,77,64,40,15,79,96,109},
{97,55,96,59,43,15,30,49,72,99},
{72,48,74,37,36,8,15,7,41,70},
{75,26,53,0,34,29,89,3,43,75},
{90,54,62,8,43,64,95,22,64,92},
{90,54,61,37,69,62,92,22,82,105},
{87,38,45,39,79,67,70,1,78,81},
{72,38,41,51,71,67,69,2,82,61},
{65,39,41,67,64,92,75,2,71,34},
{49,57,41,66,57,73,75,38,46,36},
{26,74,32,79,63,79,69,54,39,50},
{28,79,37,87,68,85,61,65,53,54},
{38,102,75,87,78,71,52,71,72,65},
{45,93,78,85,89,70,53,95,77,84},
{63,93,85,72,95,65,53,84,80,89},
{72,99,91,81,87,38,50,77,79,94},
{80,58,92,82,61,32,12,69,70,103},
{91,53,84,45,43,31,21,21,49,104},
{95,46,64,24,35,20,32,7,24,87},
{88,31,39,1,48,29,95,0,29,93},
{91,36,40,16,68,56,96,0,53,86},
{95,36,38,27,79,54,93,0,71,100},
{85,31,14,42,89,66,71,0,81,76},
{71,28,11,61,65,59,67,2,74,51},
{59,45,11,65,62,92,85,21,80,62},
{49,60,22,84,53,75,86,55,70,54},
{15,74,46,86,69,59,84,63,67,57},
{17,78,63,73,59,69,69,82,72,58},
{38,91,82,74,85,89,71,89,79,89},
{45,93,80,78,107,107,68,79,81,81},
{63,95,80,87,112,100,64,80,86,90},
{71,78,81,65,85,76,65,72,66,89},
{81,58,90,53,60,56,49,49,57,104},
{91,47,65,32,42,43,44,7,39,100},
{91,46,51,6,35,34,6,0,1,78},
{90,22,35,25,53,36,96,0,24,94},
{92,27,22,25,74,64,92,0,50,83},
{95,27,21,24,86,54,95,0,65,89},
{70,28,20,45,99,57,80,16,77,84},
{63,38,10,50,68,53,86,21,91,70},
{59,58,16,64,61,47,91,42,90,69},
{38,60,40,70,31,44,83,74,87,45},
{15,73,76,77,68,51,59,80,73,58},
{17,75,82,85,70,67,64,70,86,76},
{38,93,74,88,89,91,67,72,76,82},
{45,91,79,85,117,113,91,83,85,72},
{63,93,79,62,114,120,98,79,82,86},
{77,78,84,70,86,100,101,67,87,96},
{81,58,64,63,67,91,47,18,46,103},
{91,47,43,19,52,61,34,7,33,83},
{91,46,28,9,47,34,17,0,7,78},
{92,22,0,3,46,25,96,0,35,52},
{97,27,21,3,80,41,100,0,48,69},
{82,27,24,24,93,29,100,16,81,62},
{70,37,36,28,91,29,84,21,81,56},
{64,51,46,38,65,23,83,24,91,52},
{59,58,54,33,54,25,73,72,91,58},
{49,60,65,48,59,17,54,80,80,50},
{15,65,84,48,72,27,44,63,66,73},
{17,75,77,52,71,70,43,71,67,83},
{37,96,76,69,89,89,53,82,65,60},
{45,91,74,80,118,95,65,79,70,68},
{63,72,76,110,108,87,71,71,92,80},
{77,78,51,102,87,102,97,66,73,80},
{81,58,43,70,71,97,68,7,61,91},
{91,46,28,55,54,86,68,0,53,78},
{88,46,25,20,44,65,38,0,37,77},
{97,22,0,1,73,31,97,0,52,16},
{97,27,13,9,85,24,100,0,74,39},
{82,38,36,18,87,11,102,21,83,45},
{65,41,53,23,72,11,97,24,75,27},
{63,51,53,37,53,10,79,58,79,26},
{59,58,67,30,52,10,52,79,70,27},
{50,50,96,44,54,19,46,61,50,59},
{26,74,72,46,72,50,38,51,42,58},
{28,80,63,47,74,62,37,75,45,45},
{37,96,60,63,91,45,45,77,39,52},
{45,81,71,80,111,76,60,78,51,70},
{69,72,46,81,99,98,66,68,72,75},
{79,78,43,92,82,101,92,42,72,80},
{81,58,37,102,69,86,68,0,75,78},
{85,46,25,91,55,87,69,0,68,78},
{87,43,0,79,49,78,61,0,62,75},
{97,22,18,25,46,36,98,0,68,10},
{86,27,19,32,54,16,102,21,86,21},
{82,39,33,40,57,19,116,35,93,27},
{66,51,44,35,29,19,81,40,87,27},
{63,51,59,36,29,16,58,77,60,31},
{59,58,80,35,31,16,45,75,40,28},
{50,56,67,47,41,45,45,59,39,52},
{26,74,59,59,84,55,51,74,37,39},
{28,78,60,60,81,39,50,78,43,39},
{37,86,68,48,96,50,60,80,46,68},
{49,72,62,65,106,79,75,74,57,71},
{70,72,53,78,95,100,76,62,59,69},
{79,78,49,82,79,80,92,10,61,80},
{75,49,43,101,66,87,83,0,76,78},
{88,46,32,102,54,82,77,0,70,76},
{71,41,18,98,50,81,77,0,68,67},
{78,22,18,56,45,65,94,16,85,28},
{97,39,37,56,45,47,116,33,96,36},
{81,50,46,64,38,42,109,40,100,33},
{66,51,48,51,34,37,80,59,75,34},
{64,51,70,63,34,55,73,73,48,33},
{60,49,70,67,34,48,61,59,33,54},
{50,58,61,59,41,43,45,86,15,52},
{27,72,60,45,87,37,39,79,22,55},
{29,74,64,49,103,62,38,77,48,38},
{39,86,64,53,112,64,47,80,50,62},
{66,70,65,68,104,77,61,69,58,59},
{72,72,62,83,90,88,62,52,72,62},
{74,78,46,86,91,80,77,0,61,70},
{62,46,46,99,92,81,83,0,70,76},
{75,43,35,98,73,82,78,0,71,75},
{38,41,34,89,64,78,70,0,67,59},
{50,31,33,59,16,80,60,21,105,39},
{86,50,48,62,14,71,120,40,105,49},
{81,50,56,74,6,58,110,40,97,49},
{69,51,63,70,34,69,76,63,59,37},
{65,42,72,64,35,54,61,76,48,46},
{59,49,81,50,45,29,50,68,25,63},
{52,59,71,41,46,38,47,83,24,66},
{32,75,70,52,61,55,41,80,33,44},
{53,74,77,55,75,63,40,77,38,47},
{59,77,71,69,106,70,50,76,53,53},
{68,70,74,75,99,71,61,66,69,56},
{64,72,58,81,90,73,76,10,75,62},
{62,71,60,90,96,71,83,0,55,70},
{76,46,45,97,62,82,76,0,69,75},
{73,43,49,93,51,80,80,0,67,43},
{28,41,47,62,45,51,36,0,49,29},
{40,47,49,73,1,66,44,35,82,37},
{65,63,61,84,1,106,66,40,106,71},
{84,63,80,79,1,82,81,62,87,72},
{69,64,99,71,29,70,92,78,67,43},
{67,53,95,75,36,73,71,61,48,73},
{61,71,99,56,43,65,58,85,38,63},
{66,69,91,61,44,53,57,91,46,50},
{60,71,90,64,70,52,48,81,47,41},
{58,65,93,64,74,64,48,77,59,51},
{61,75,82,74,83,67,56,75,56,65},
{65,70,82,75,95,65,90,58,63,69},
{55,78,74,79,89,80,84,10,66,66},
{70,79,75,91,72,72,85,0,59,67},
{73,59,68,92,58,79,60,0,67,62},
{29,56,70,51,45,50,37,0,61,40},
{16,52,62,39,40,19,17,0,30,25},
{30,47,55,54,0,41,38,27,48,7},
{41,71,95,92,0,83,44,61,80,46},
{51,71,102,113,0,112,59,65,97,74},
{91,73,99,95,28,116,88,75,103,81},
{91,73,95,78,29,79,77,83,83,76},
{87,73,95,76,42,73,79,83,84,62},
{82,62,93,70,42,52,75,88,83,54},
{77,69,94,76,72,65,80,77,83,62},
{51,65,101,71,74,64,79,76,66,66},
{49,78,99,74,83,62,59,63,66,56},
{56,73,101,84,90,66,70,34,47,61},
{71,88,96,85,89,78,87,1,66,67},
{54,91,96,55,74,66,95,1,67,37},
{30,68,87,40,58,48,35,0,46,40},
{15,64,77,26,44,24,16,0,29,26},
{6,62,61,6,39,10,4,0,5,8},
{0,52,66,30,0,26,5,29,4,1},
{3,63,72,54,0,51,9,46,14,12},
{16,71,71,50,0,38,24,72,45,13},
{27,67,71,71,28,29,31,70,69,38},
{34,58,62,74,31,63,31,53,69,62},
{54,57,58,78,41,61,41,49,76,53},
{60,64,55,71,64,70,46,74,75,83},
{73,64,56,67,67,79,65,73,62,72},
{77,61,62,53,69,78,99,68,63,68},
{56,64,66,42,73,56,71,58,51,49},
{24,70,66,20,87,38,64,11,38,9},
{9,62,65,15,90,23,47,1,19,10},
{8,75,61,10,73,6,45,1,11,7},
{0,72,64,5,61,1,36,0,7,6},
{0,70,68,0,57,0,36,0,0,1},
{0,80,64,0,52,0,32,0,0,1}};

    
struct component
{
    int x1, x2;
    int y1, y2;
    int l;
    set<int> colors;
    bool valid;
};    
    
    
    int n, m;
    int been[max_n][max_m];
    string pict[max_n], number[max_n];
    int number_n, number_m;
    int signal[max_neuro];
    string ans;
    bool decide;
    
void neuro_view()
{
    int i, j, adr;
    for (i = 0; i < a_elem; i++)
    {
        signal[i] = 0;
    }    

    for (i = 0; i < d_n; i++)
    {
        for (j = 0; j < d_m; j++)
        {
            if (number[i][j] != '.')
            {
                adr = (i/window_n)*(d_m/window_m) + (j/window_m);
                signal[adr]++;
            }
        }
    }                
    for (i = 0; i < s_elem; i++)
    {
        if (signal[i] > s_teta)
        {
            signal[i] = 1;
        }
        else
        {
            signal[i] = 0;
        }
    }
}    

void neuro_read()
{
    int i, j;
    ifstream in;
    in.open(weight_file);
    for (i = 0; i < a_elem; i++)
    {
        for (j = 0; j < signs_n; j++)
        {
//            in >> weight[i][j];
        }
    }        
    in.close();
}    

void neuro_learn(int answer)
{
    int i, j;
    int ans_signal[signs_n];
    bool need2learn = false;
    for (j = 0; j < signs_n; j++)
    {
        ans_signal[j] = 0;
    }    
    
    for (i = 0; i < a_elem; i++)
    {
        if (signal[i] > a_teta)
        {
            for (j = 0; j < signs_n; j++)
            {
                ans_signal[j] += (weight[i][j] * signal[i]);
            }
        }    
    }    
    
    for (j = 0; j < signs_n; j++)
    {
        if (j != answer)
        {
            if (ans_signal[answer] <= ans_signal[j])
            {
                need2learn = true;
                break;
            }    
        }    
    }    
    if (need2learn)
    {
        for (i = 0; i < a_elem; i++)
        {
            if (signal[i] > a_teta)
            {
//                weight[i][answer]++;
            }
        }    
    }    
}    

int neuro_recogn()
{
    int i, j, answer;
    int ans_signal[signs_n];
    for (j = 0; j < signs_n; j++)
    {
        ans_signal[j] = 0;
    }    
    
    for (i = 0; i < a_elem; i++)
    {
        if (signal[i] > a_teta)
        {
            for (j = 0; j < signs_n; j++)
            {
                ans_signal[j] += (weight[i][j] * signal[i]);
            }
        }    
    }    
    
    answer = 0;
    for (i = 1; i < 10; i++)
    {
        if (ans_signal[i] > ans_signal[answer])
        {
            answer = i;
        }
    }
    return answer;
}    


void neuro_write()
{
    ofstream out;    
    int i, j;
    out.open(weight_file);
    for (i = 0; i < a_elem; i++)
    {
        for (j = 0; j < signs_n; j++)
        {
            out << weight[i][j] << ' ';
        }
        out << endl;
    }        
    out.close();
}    

void data_print(string ps[], int pn)
{
    ofstream out(f_pic, ios::app);    
    int i;
    for (i = 0; i < pn; i++)
    {
        out << ps[i] << endl;
    }
}              

void data_read()
{
//    ifstream in;
//    in.open(f_in);
    n = 0; m = 0;    
    while (!cin.eof())
    {
        cin >> pict[n];
        if ((pict[n][0] != '.') && (pict[n][0] != '%')
        && (pict[n][0] != '#') && (pict[n][0] != '@'))
        {
            break;
        }
        else
        {
            n++;
        }    
    }    
    m = pict[0].length();
//    in.close();
}

void data_answer_in()
{
    ifstream in;    
    in.open(f_out);
    in >> ans;
    in.close();
}    

void data_answer_out()
{
//    ofstream out;
//    out.open(f_out);
    cout << ans;
//    out.close();
}    
    
void data_clear_columns()
{
    int i, j, sum;
    for (j = 0; j < m; j++)
    {
        sum = 0;
        for (i = 0; i < n; i++)
        {
            if (pict[i][j] == '@') {sum++;}
//            if (pict[i][j] == '#') {sum++;}
        }
        if (sum == 0)
        {
            for (i = 0; i < n; i++)
            {
                pict[i][j] = '.';
            }
        }
    }
}                    

void data_init(string s[], int x, int y)
{
    int i, j;
    for (i = 0; i < x; i++)
    {
        s[i] = "";
        for (j = 0; j < y; j++)
        {
            s[i] += '.';
        }
    }
}            

void data_resize()
{
    int i, j, x, s, p;
    int step, pen;
    string tmp[max_n];

//resize columns || (number_n, number_m) -> (d_n, number_m)
    data_init(tmp, d_n, d_m);
    s = d_n; p = 0;
    for (i = 0; i < number_n; i++)
    {
        for (x = 0; x < (s / number_n); x++)
        {
            for (j = 0; j < number_m; j++)
            {
                tmp[p][j] = number[i][j]; 
            }
            p++;
        }   
        s = (s % number_n) + d_n;
    }     
    
//resize strings = (d_n, number_m) -> (d_n, d_m)    
    data_init(number, d_n, d_m);
    s = d_m; p = 0;
    for (j = 0; j < number_m; j++)
    {
        for (x = 0; x < (s / number_m); x++)
        {
            for (i = 0; i < d_n; i++)
            {
                number[i][p] = tmp[i][j]; 
            }
            p++;
        }   
        s = (s % number_m) + d_m;
    }     
}    

component bfs(int x, int y, int color_comp, int color_waypoint, set<char> symb_waypoint)
{
    component dim;
    int stek[max_n*max_m][2];
    int begin, end, a, b, u, i, j;
    begin = 0;
    end = 1;
    stek[0][0] = x;
    stek[0][1] = y;
    been[x][y] = color_comp;
    //1 - verh, 2 - pravo, 3 - niz, 4 - levo
    dim.l = 0;
    dim.x1 = x;
    dim.y1 = y;
    dim.x2 = x;
    dim.y2 = y;
    dim.valid = true;
    dim.colors.insert(color_comp);
    while (begin < end)
    {
        dim.l++;
        a = stek[begin][0];
        b = stek[begin][1];
        if (dim.x1 > a) {dim.x1 = a;}
        if (dim.y2 < b) {dim.y2 = b;}
        if (dim.x2 < a) {dim.x2 = a;}
        if (dim.y1 > b) {dim.y1 = b;}     
        for (u = 0; u < 8; u++)
        {
            i = a + dir[u][0];
            j = b + dir[u][1];
            if ((i >= 0) && (i < n) && (j >= 0) && (j < m))
            {
                if (been[i][j] == color_waypoint)
                {
                    if (symb_waypoint.find(pict[i][j]) != symb_waypoint.end()) 
                    {
                        stek[end][0] = i;
                        stek[end][1] = j;
                        been[i][j] = color_comp;
                        end++;
                    }    
                }    
            }    
        }
        begin++;    
    }    
    return dim;
}    

bool number_erase(component v, int min_height)
{
    if (v.l < (destroy_rate*n*m / 100))
    {
        return true;
    }
    if ((v.x2 - v.x1) < (2 * min_height/3 - 1))
    {
        return true;
    }    
    return false;
}    

void number_recognize(component v)
{
    int i, j;
    if (number_erase(v, 0))
    {
        return;
    }    
    
    for (i = v.x1; i <= v.x2; i++)
    {
        number[i - v.x1] = "";
        for (j = v.y1; j <= v.y2; j++)
        {
            if (v.colors.find(been[i][j]) != v.colors.end())
            {
                number[i - v.x1] += '@';
            }
            else
            {
                number[i - v.x1] += '.';                        
            }    
        }
    }    
    number_n = v.x2 - v.x1 + 1;
    number_m = v.y2 - v.y1 + 1;
    data_resize();
//    neuro_read();
    neuro_view();
    if (decide)
    {
        neuro_learn(ans[0] - '0');
        ans.erase(0, 1);
        neuro_write();                
    }    
    else
    {
        ans += (neuro_recogn() + '0');
    }    
}    

void predproc()
{
    int i, j, k;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
        {
            been[i][j] = 0;
        }
    }        
    component dim[max_obj];
    int komp, color;
    set<char> symb_waypoint;
    symb_waypoint.clear();
    symb_waypoint.insert('@');
    symb_waypoint.insert('%');
    symb_waypoint.insert('#');
    komp = 0;
    
    data_clear_columns();    
    for (j = 0; j < m; j++)
    {
        for (i = 0; i < n; i++)    
        {
            if ((symb_waypoint.find(pict[i][j]) != symb_waypoint.end()) && (been[i][j] == 0))
            {
                komp++;                
                dim[komp] = bfs(i, j, komp, 0, symb_waypoint);
            }
        }
    }
    
    int mid_height_comp = 0;
    for (k = 1; k <= komp; k++)
    {
        mid_height_comp += dim[k].x2 - dim[k].x1;
    }
    mid_height_comp /= komp;    
   
    for (k = 1; k <= komp; k++)
    {
        if (number_erase(dim[k], mid_height_comp))
        {
                dim[k].valid = false;
        }    
    }    
/*    
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
        {
            if (pict[i][j] != '.')
            {
                if (dim[been[i][j]][5] == 1)
                {
                    pict[i][j] = '.';
                }    
            }
        }
    }
*/
    vector<component> store;
    component temp;
    color = 0;
    symb_waypoint.erase('%');
    symb_waypoint.erase('#');    
    bool bad_cut;
    for (k = 1; k <= komp; k++)
    {
        if (dim[k].valid)
        {
            bad_cut = false;
            store.clear();
            for (i = dim[k].x1; i <= dim[k].x2; i++)
            {
                for (j = dim[k].y1; j <= dim[k].y2; j++)
                {
                    if ((symb_waypoint.find(pict[i][j]) != symb_waypoint.end()) && (been[i][j] == k))
                    {
                        color--;
                        dim[k].colors.insert(color);                        
                        temp = bfs(i, j, color, k, symb_waypoint);
                        if (number_erase(temp, dim[k].x2 - dim[k].x1))
                        {
                            bad_cut = true;
                        }    
                        else
                        {
                            store.push_back(temp);
                        }    
                    }    
                    if (bad_cut) {break;}
                }    
                if (bad_cut) {break;}
            }    
            if ((!bad_cut) && (store.size() > 1))
            {
                for (i = 0; i < store.size(); i++)
                {
                    number_recognize(store[i]);
                }    
            }    
            else
            {
                number_recognize(dim[k]);
            }    
        }
    }        
}    

int main()
{
    // 1 - obu4enie, 0 - raspoznavanie
    decide = 0;
    data_read();
    if (decide)
    {
        data_answer_in();
    }    
    else
    {
        ans = "";
    }    
    predproc();
    if (!decide)
    {
        data_answer_out();
    }    
    return 0;
}
    
    
